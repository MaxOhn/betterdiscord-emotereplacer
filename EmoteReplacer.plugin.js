/**
 * @name EmoteReplacer
 * @version 1.12.1
 * @description Check for known emote names and replace them with an embedded image of the emote. Also supports modifiers similar to BetterDiscord's emotes. Standard emotes: https://yentis.github.io/emotes/
 * @license MIT
 * @author Yentis
 * @authorId 68834122860077056
 * @website https://github.com/Yentis/betterdiscord-emotereplacer
 * @source https://raw.githubusercontent.com/Yentis/betterdiscord-emotereplacer/master/EmoteReplacer.plugin.js
 */

"use strict";

var https$1 = require("https"), require$$1$1 = require("fs"), require$$0 = require("path"), require$$14 = require("events"), require$$0$2 = require("http"), require$$2$1 = require("url"), require$$3 = require("querystring"), require$$4 = require("zlib"), require$$0$1 = require("util"), require$$1$2 = require("stream"), require$$0$3 = require("assert"), require$$3$1 = require("buffer"), require$$0$4 = require("string_decoder"), require$$4$1 = require("timers");

function _interopDefaultLegacy(e) {
    return e && "object" == typeof e && "default" in e ? e : {
        default: e
    };
}

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    return e && Object.keys(e).forEach((function(k) {
        if ("default" !== k) {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
                enumerable: !0,
                get: function() {
                    return e[k];
                }
            });
        }
    })), n.default = e, Object.freeze(n);
}

var https__default = _interopDefaultLegacy(https$1), require$$1__default = _interopDefaultLegacy(require$$1$1), require$$0__default = _interopDefaultLegacy(require$$0), require$$14__default = _interopDefaultLegacy(require$$14), require$$0__default$2 = _interopDefaultLegacy(require$$0$2), require$$2__default = _interopDefaultLegacy(require$$2$1), require$$3__default = _interopDefaultLegacy(require$$3), require$$4__default = _interopDefaultLegacy(require$$4), require$$0__default$1 = _interopDefaultLegacy(require$$0$1), require$$1__default$1 = _interopDefaultLegacy(require$$1$2), require$$0__default$3 = _interopDefaultLegacy(require$$0$3), require$$3__default$1 = _interopDefaultLegacy(require$$3$1), require$$0__default$4 = _interopDefaultLegacy(require$$0$4), require$$4__default$1 = _interopDefaultLegacy(require$$4$1);

function setLogger(pluginName) {
    Logger = new LoggerClass(pluginName);
}

class LoggerClass {
    pluginName;
    constructor(pluginName) {
        this.pluginName = pluginName;
    }
    debug(...args) {
        console.debug(this.pluginName, ...args);
    }
    info(...args) {
        console.info(this.pluginName, ...args);
    }
    warn(...args) {
        console.warn(this.pluginName, ...args);
    }
    error(...args) {
        console.error(this.pluginName, ...args);
    }
}

let Logger;

const PLUGIN_CHANGELOG = [ {
    title: "Improved",
    type: "improved",
    items: [ "Removed reliance on Gifsicle binaries, you may now remove the gifsicle file in your plugin folder" ]
}, {
    title: "Fixed",
    type: "fixed",
    items: [ "Plugin not starting properly on first install" ]
} ], DEFAULT_SETTINGS = {
    emoteSize: 48,
    autocompleteEmoteSize: 15,
    autocompleteItems: 10,
    customEmotes: {},
    requirePrefix: !0,
    prefix: ";",
    resizeMethod: "smallest",
    showStandardEmotes: !0
};

function httpsGetPromise(url) {
    return new Promise(((resolve, reject) => {
        https__default.default.get(url, (res => {
            let data = "";
            res.on("data", (chunk => {
                data += chunk;
            })), res.on("end", (() => {
                const statusCode = res.statusCode ?? 0;
                0 !== statusCode && (statusCode < 200 || statusCode >= 400) ? reject(new Error(res.statusMessage)) : resolve(data);
            }));
        })).on("error", (error => {
            reject(error);
        }));
    }));
}

function httpsGetStream(url) {
    return new Promise(((resolve, reject) => {
        https__default.default.get(url, (res => {
            resolve(res);
        })).on("error", (error => {
            reject(error);
        }));
    }));
}

function loadImagePromise(url) {
    return new Promise(((resolve, reject) => {
        const image = new Image;
        image.onload = () => {
            resolve(image);
        }, image.onerror = () => {
            reject(new Error(`Failed to load image from url: ${url}`));
        }, image.src = url;
    }));
}

class BaseService {
    plugin;
    zeresPluginLibrary;
    constructor(plugin, zeresPluginLibrary) {
        this.plugin = plugin, this.zeresPluginLibrary = zeresPluginLibrary;
    }
}

class CompletionsService extends BaseService {
    static TAG=CompletionsService.name;
    static TEXTAREA_KEYDOWN_LISTENER="textAreaKeydown";
    static TEXTAREA_WHEEL_LISTENER="textAreaWheel";
    static TEXTAREA_BLUR_LISTENER="textAreaBlur";
    static AUTOCOMPLETE_DIV_WHEEL_LISTENER="autocompleteDivWheel";
    static EMOTE_ROW_MOUSEENTER_LISTENER="emoteRowMouseenter";
    static EMOTE_ROW_MOUSEDOWN_LISTENER="emoteRowMousedown";
    emoteService;
    settingsService;
    modulesService;
    listenersService;
    htmlService;
    draft="";
    cached;
    start(emoteService, settingsService, modulesService, listenersService, htmlService) {
        return this.emoteService = emoteService, this.settingsService = settingsService, 
        this.modulesService = modulesService, this.listenersService = listenersService, 
        this.htmlService = htmlService, this.listenersService.addListenersWatchers[CompletionsService.TAG] = {
            onAddListeners: () => {
                this.addListeners();
            }
        }, this.addListeners(), Promise.resolve();
    }
    addListeners() {
        const textArea = this.htmlService.getTextAreaField();
        if (void 0 === textArea) return;
        this.listenersService.removeListener(CompletionsService.TEXTAREA_KEYDOWN_LISTENER), 
        this.listenersService.removeListener(CompletionsService.TEXTAREA_WHEEL_LISTENER), 
        this.listenersService.removeListener(CompletionsService.TEXTAREA_BLUR_LISTENER);
        const keydownListener = {
            element: textArea,
            name: "keydown",
            callback: evt => {
                this.browseCompletions(evt);
            }
        };
        textArea.addEventListener(keydownListener.name, keydownListener.callback), this.listenersService.addListener(CompletionsService.TEXTAREA_KEYDOWN_LISTENER, keydownListener);
        const wheelListener = {
            element: textArea,
            name: "wheel",
            callback: evt => {
                this.scrollCompletions(evt);
            }
        };
        textArea.addEventListener(wheelListener.name, wheelListener.callback), this.listenersService.addListener(CompletionsService.TEXTAREA_WHEEL_LISTENER, wheelListener);
        const blurListener = {
            element: textArea,
            name: "blur",
            callback: () => {
                this.destroyCompletions();
            }
        };
        textArea.addEventListener(blurListener.name, blurListener.callback), this.listenersService.addListener(CompletionsService.TEXTAREA_BLUR_LISTENER, blurListener);
    }
    browseCompletions(event) {
        if (!this.emoteService.shouldCompleteEmote(this.draft) && !this.emoteService.shouldCompleteCommand(this.draft)) return;
        let options, delta = 0;
        const autocompleteItems = Math.round(this.settingsService.settings.autocompleteItems);
        switch (event.which) {
          case 9:
          case 13:
            if (!this.prepareCompletions()) break;
            event.stopPropagation(), event.preventDefault(), this.insertSelectedCompletion();
            break;

          case 38:
            delta = -1;
            break;

          case 40:
            delta = 1;
            break;

          case 33:
            delta = -autocompleteItems, options = {
                locked: !0,
                clamped: !0
            };
            break;

          case 34:
            delta = autocompleteItems, options = {
                locked: !0,
                clamped: !0
            };
        }
        0 !== delta && this.prepareCompletions() && (event.stopPropagation(), event.preventDefault(), 
        this.scrollWindow(delta, options));
    }
    prepareCompletions() {
        const candidateText = this.draft, lastText = this.cached?.candidateText;
        if (lastText !== candidateText) if (this.emoteService.shouldCompleteEmote(candidateText)) {
            const {completions, matchText, matchStart} = this.emoteService.getCompletionsEmote(candidateText);
            this.cached = {
                candidateText,
                completions,
                matchText,
                matchStart,
                selectedIndex: 0,
                windowOffset: 0
            };
        } else if (this.emoteService.shouldCompleteCommand(candidateText)) {
            const {completions, matchText, matchStart} = this.emoteService.getCompletionsCommands(candidateText);
            this.cached = {
                candidateText,
                completions,
                matchText,
                matchStart,
                selectedIndex: 0,
                windowOffset: 0
            };
        }
        const {completions} = this.cached ?? {};
        return void 0 !== completions && 0 !== completions.length;
    }
    insertSelectedCompletion() {
        const {completions, matchText, selectedIndex} = this.cached ?? {}, curDraft = this.draft, matchTextLength = matchText?.length ?? 0;
        if (void 0 === completions || void 0 === selectedIndex) return;
        this.modulesService.draft.clearDraft(this.modulesService.selectedChannelStore.getChannelId(), 0);
        const selectedCompletion = completions[selectedIndex];
        if (!selectedCompletion) return;
        const completionValueArguments = "string" == typeof selectedCompletion.data ? void 0 : selectedCompletion.data.arguments;
        let suffix = " ";
        completionValueArguments && (completionValueArguments.some((argument => "" === argument)) || (suffix = "-")), 
        selectedCompletion.name += suffix;
        const newDraft = curDraft.substring(0, curDraft.length - matchTextLength);
        this.modulesService.componentDispatcher.ComponentDispatch.dispatch("INSERT_TEXT", {
            plainText: newDraft + selectedCompletion.name
        }), this.destroyCompletions();
    }
    destroyCompletions() {
        if (this.htmlService.getTextAreaContainer()) {
            const completions = this.htmlService.getTextAreaContainer()?.querySelectorAll(`.${this.plugin.meta.name}`);
            completions?.forEach((completion => {
                completion.remove();
            }));
        }
        this.cached = void 0, this.renderCompletions.cancel();
    }
    renderCompletions=_.debounce((() => {
        const channelTextArea = this.htmlService.getTextAreaContainer();
        if (!channelTextArea) return;
        const oldAutoComplete = channelTextArea?.querySelectorAll(`.${this.plugin.meta.name}`) ?? [], discordClasses = this.modulesService.classes, isEmote = this.emoteService.shouldCompleteEmote(this.draft);
        for (const autoComplete of oldAutoComplete) autoComplete.remove();
        if (!this.emoteService.shouldCompleteEmote(this.draft) && !this.emoteService.shouldCompleteCommand(this.draft) || !this.prepareCompletions()) return;
        const {completions, matchText, selectedIndex} = this.cached ?? {}, firstIndex = this.cached?.windowOffset ?? 0, matchList = completions?.slice(firstIndex, firstIndex + Math.round(this.settingsService.settings.autocompleteItems)), autocompleteDiv = document.createElement("div");
        this.htmlService.addClasses(autocompleteDiv, discordClasses.Autocomplete.autocomplete, this.plugin.meta.name);
        const autocompleteListener = {
            element: autocompleteDiv,
            name: "wheel",
            callback: evt => {
                this.scrollCompletions(evt, {
                    locked: !0
                });
            }
        };
        autocompleteDiv.addEventListener(autocompleteListener.name, autocompleteListener.callback), 
        this.listenersService.addListener(CompletionsService.AUTOCOMPLETE_DIV_WHEEL_LISTENER, autocompleteListener), 
        channelTextArea.append(autocompleteDiv);
        const autocompleteInnerDiv = document.createElement("div");
        this.htmlService.addClasses(autocompleteInnerDiv, discordClasses.Autocomplete.autocompleteInner), 
        autocompleteDiv.append(autocompleteInnerDiv);
        const titleRow = document.createElement("div");
        this.htmlService.addClasses(titleRow, discordClasses.Autocomplete.autocompleteRowVertical), 
        autocompleteInnerDiv.append(titleRow);
        const selector = document.createElement("div");
        this.htmlService.addClasses(selector, discordClasses.Autocomplete.base), titleRow.append(selector);
        const contentTitle = document.createElement("h3");
        this.htmlService.addClasses(contentTitle, discordClasses.Autocomplete.contentTitle, discordClasses.Wrapper.base, discordClasses.Size.size12), 
        contentTitle.innerText = isEmote ? "Emoji matching " : "Commands ", selector.append(contentTitle);
        const matchTextElement = document.createElement("strong");
        matchTextElement.textContent = matchText ?? "", contentTitle.append(matchTextElement), 
        matchList?.forEach((({name, data}, index) => {
            const emoteRow = document.createElement("div");
            emoteRow.setAttribute("aria-disabled", "false"), this.htmlService.addClasses(emoteRow, discordClasses.Autocomplete.clickable, discordClasses.Autocomplete.autocompleteRowVertical, discordClasses.Autocomplete.autocompleteRowVerticalSmall);
            const mouseEnterListener = {
                element: emoteRow,
                name: "mouseenter",
                callback: () => {
                    this.cached || (this.cached = {}), this.cached.selectedIndex = index + firstIndex;
                    for (const child of titleRow.parentElement?.children ?? []) {
                        child.setAttribute("aria-selected", "false");
                        for (const nestedChild of child.children) this.htmlService.addClasses(nestedChild, discordClasses.Autocomplete.base);
                    }
                }
            };
            emoteRow.addEventListener(mouseEnterListener.name, mouseEnterListener.callback), 
            this.listenersService.addListener(`${CompletionsService.EMOTE_ROW_MOUSEENTER_LISTENER}${index}`, mouseEnterListener);
            const mouseDownListener = {
                element: emoteRow,
                name: "mousedown",
                callback: evt => {
                    evt.preventDefault(), this.cached || (this.cached = {}), this.cached.selectedIndex = index + firstIndex, 
                    this.insertSelectedCompletion();
                }
            };
            emoteRow.addEventListener(mouseDownListener.name, mouseDownListener.callback), this.listenersService.addListener(`${CompletionsService.EMOTE_ROW_MOUSEDOWN_LISTENER}${index}`, mouseDownListener), 
            autocompleteInnerDiv.append(emoteRow);
            const emoteSelector = document.createElement("div");
            this.htmlService.addClasses(emoteSelector, discordClasses.Autocomplete.base), emoteRow.append(emoteSelector), 
            index + firstIndex === selectedIndex && emoteRow.setAttribute("aria-selected", "true");
            const emoteContainer = document.createElement("div");
            if (this.htmlService.addClasses(emoteContainer, discordClasses.Autocomplete.autocompleteRowContent), 
            emoteSelector.append(emoteContainer), isEmote) {
                const containerIcon = document.createElement("div");
                this.htmlService.addClasses(containerIcon, discordClasses.Autocomplete.autocompleteRowIcon), 
                emoteContainer.append(containerIcon);
                const settingsAutocompleteEmoteSize = this.settingsService.settings.autocompleteEmoteSize, containerImage = document.createElement("img");
                containerImage.src = "string" == typeof data ? data : "", containerImage.alt = name, 
                containerImage.title = name, containerImage.style.minWidth = `${Math.round(settingsAutocompleteEmoteSize)}px`, 
                containerImage.style.minHeight = `${Math.round(settingsAutocompleteEmoteSize)}px`, 
                containerImage.style.width = `${Math.round(settingsAutocompleteEmoteSize)}px`, containerImage.style.height = `${Math.round(settingsAutocompleteEmoteSize)}px`, 
                this.htmlService.addClasses(containerImage, discordClasses.Autocomplete.emojiImage), 
                containerIcon.append(containerImage);
            }
            const containerContent = document.createElement("div");
            if (containerContent.style.color = "var(--interactive-active)", this.htmlService.addClasses(containerContent, discordClasses.Autocomplete.autocompleteRowContentPrimary), 
            emoteContainer.append(containerContent), isEmote || "string" == typeof data) containerContent.textContent = name; else {
                containerContent.style.display = "flex", containerContent.style.flexDirection = "column";
                const containerContentName = document.createElement("span");
                containerContentName.style.paddingBottom = "0.5em", containerContentName.textContent = name, 
                containerContent.append(containerContentName);
                const containerContentInfo = document.createElement("span");
                containerContentInfo.style.color = "var(--interactive-normal)", containerContentInfo.textContent = data.info, 
                containerContent.append(containerContentInfo);
            }
        }));
    }), 250);
    scrollCompletions(e, options) {
        const delta = Math.sign(e.deltaY);
        this.scrollWindow(delta, options);
    }
    scrollWindow(delta, {locked = !1, clamped = !1} = {}) {
        if (!this.cached) return;
        const {completions, selectedIndex: prevSel, windowOffset} = this.cached, autocompleteItems = Math.round(this.settingsService.settings.autocompleteItems);
        if (!completions) return;
        const num = completions.length;
        let sel = (prevSel ?? 0) + delta;
        sel = clamped ? _.clamp(sel, 0, num - 1) : sel % num + (sel < 0 ? num : 0), this.cached.selectedIndex = sel;
        const boundLower = _.clamp(sel + 2 - (autocompleteItems - 1), 0, num - autocompleteItems), boundUpper = _.clamp(sel - 2, 0, num - autocompleteItems);
        this.cached.windowOffset = _.clamp((windowOffset ?? 0) + (locked ? delta : 0), boundLower, boundUpper), 
        this.renderCompletions(), this.renderCompletions.flush();
    }
    stop() {
        this.draft = "", this.cached = void 0;
    }
}

class EmoteService extends BaseService {
    listenersService;
    settingsService;
    htmlService;
    emoteNames;
    modifiers=[];
    start(listenersService, settingsService, htmlService) {
        return this.listenersService = listenersService, this.settingsService = settingsService, 
        this.htmlService = htmlService, this.initEmotes(), Promise.resolve();
    }
    initEmotes() {
        Promise.all([ this.getEmoteNames(), this.getModifiers() ]).then((([emoteNames, modifiers]) => {
            this.setEmoteNames(emoteNames), this.modifiers = modifiers, this.htmlService.getTextAreaField() && this.listenersService.requestAddListeners(CompletionsService.TAG);
        })).catch((error => {
            Logger.warn("Failed to get emote names and/or modifiers", error);
        }));
    }
    refreshEmotes() {
        this.emoteNames = void 0, BdApi.showToast("Reloading emote database...", {
            type: "info"
        }), this.getEmoteNames().then((names => {
            this.setEmoteNames(names), BdApi.showToast("Emote database reloaded!", {
                type: "success"
            });
        })).catch((error => {
            Logger.warn("Failed to get emote names", error);
        }));
    }
    async getEmoteNames() {
        if (!this.settingsService.settings.showStandardEmotes) return {};
        const data = await httpsGetPromise("https://raw.githubusercontent.com/Yentis/yentis.github.io/master/emotes/emotes.json"), emoteNames = JSON.parse(data);
        return Object.keys(emoteNames).forEach((key => {
            const split = emoteNames[key]?.split("."), [name, extension] = split ?? [];
            void 0 !== name && void 0 !== extension && (emoteNames[name] = `https://raw.githubusercontent.com/Yentis/yentis.github.io/master/emotes/images/${key}.${extension}`);
        })), emoteNames;
    }
    setEmoteNames(emoteNames) {
        const customEmotes = {};
        Object.entries(this.settingsService.settings.customEmotes).forEach((([name, url]) => {
            customEmotes[this.getPrefixedName(name)] = url;
        }));
        const standardNames = {};
        Object.entries(emoteNames).forEach((([name, url]) => {
            const prefixedName = this.getPrefixedName(name);
            standardNames[prefixedName] = url;
        })), this.emoteNames = {
            ...standardNames,
            ...customEmotes
        };
    }
    async getModifiers() {
        const data = await httpsGetPromise("https://raw.githubusercontent.com/Yentis/betterdiscord-emotereplacer/master/modifiers.json");
        return JSON.parse(data);
    }
    getPrefixedName(name) {
        const settingsPrefix = this.settingsService.settings.prefix;
        return name.toLowerCase().startsWith(settingsPrefix) && (name = name.replace(settingsPrefix, "")), 
        `${settingsPrefix}${name}`;
    }
    shouldCompleteEmote(input) {
        const prefix = this.settingsService.settings.requirePrefix ? this.escapeRegExp(this.settingsService.settings.prefix) : "";
        return new RegExp("(?:^|\\s)" + prefix + "\\w{2,}$").test(input);
    }
    shouldCompleteCommand(input) {
        return this.getRegexCommand().test(input);
    }
    escapeRegExp(input) {
        return input.replace(/[-\\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    getRegexCommand() {
        const prefix = this.settingsService.settings.requirePrefix ? this.escapeRegExp(this.settingsService.settings.prefix) : "";
        return new RegExp("((?<!\\/)(?:" + prefix + "|<)[\\w:>]*\\.)([\\w\\.-]*)$");
    }
    getCompletionsEmote(text) {
        const settingsPrefix = this.settingsService.settings.prefix, prefix = this.settingsService.settings.requirePrefix ? this.escapeRegExp(settingsPrefix) : "", match = text.match(new RegExp("(^|\\s)(" + prefix + "\\w{2,})$"));
        if (null === match) return {
            completions: [],
            matchText: void 0,
            matchStart: -1
        };
        const emoteArray = [];
        Object.entries(this.emoteNames ?? {}).forEach((([key, value]) => {
            emoteArray.push({
                name: key,
                data: value
            });
        }));
        const matchText = (match[2] ?? "").toLowerCase(), completions = emoteArray.filter((emote => {
            const matchWithoutPrefix = matchText.startsWith(settingsPrefix) ? matchText.replace(settingsPrefix, "") : matchText;
            return -1 !== emote.name.toLowerCase().search(matchWithoutPrefix) && emote;
        })), matchStart = (match.index ?? 0) + (match[1] ?? "").length;
        return {
            completions,
            matchText,
            matchStart
        };
    }
    getCompletionsCommands(text) {
        const regex = this.getRegexCommand(), match = text.match(regex);
        if (null === match) return {
            completions: [],
            matchText: void 0,
            matchStart: -1
        };
        const commandPart = match[2]?.substring(match[2].lastIndexOf(".") + 1) ?? "", commandArray = [];
        return this.modifiers.forEach((modifier => {
            commandArray.push({
                name: modifier.name,
                data: modifier
            });
        })), {
            completions: commandArray.filter((command => "" === commandPart || -1 !== command.name.toLowerCase().search(commandPart))),
            matchText: commandPart,
            matchStart: (match.index ?? 0) + (match[0] ?? "").length
        };
    }
    stop() {
        this.emoteNames = void 0, this.modifiers = [];
    }
}

class AttachService extends BaseService {
    modulesService;
    canAttach=!1;
    pendingUpload;
    onMessagesLoaded;
    onChannelSelect;
    async start(modulesService) {
        this.modulesService = modulesService;
        const userId = await this.getUserId();
        this.initChannelSubscription(userId);
    }
    getUserId() {
        return new Promise((resolve => {
            const getCurrentUser = this.modulesService.userStore.getCurrentUser;
            let user = getCurrentUser();
            if (user) {
                const userId = user.id;
                return this.setCanAttach(this.modulesService.selectedChannelStore.getChannelId(), userId), 
                void resolve(userId);
            }
            this.onMessagesLoaded = data => {
                user = getCurrentUser();
                const userId = user?.id ?? "";
                this.onMessagesLoaded && (this.modulesService.dispatcher.unsubscribe("LOAD_MESSAGES_SUCCESS", this.onMessagesLoaded), 
                this.onMessagesLoaded = void 0), userId && (this.setCanAttach(data.channelId, userId), 
                resolve(userId));
            }, this.modulesService.dispatcher.subscribe("LOAD_MESSAGES_SUCCESS", this.onMessagesLoaded);
        }));
    }
    setCanAttach(_channelId, userId) {
        const channelId = _channelId ?? "";
        if (!channelId) return void (this.canAttach = !0);
        const channel = this.modulesService.channelStore.getChannel(channelId);
        if (!channel) return void (this.canAttach = !0);
        if (!channel.guild_id) return void (this.canAttach = !0);
        const attachFilesPermission = this.modulesService.discordPermissions.Permissions.ATTACH_FILES;
        this.canAttach = this.modulesService.permissions.can(attachFilesPermission, channel, userId);
    }
    initChannelSubscription(userId) {
        this.onChannelSelect = data => {
            this.setCanAttach(data.channelId, userId);
        }, this.modulesService.dispatcher.subscribe("CHANNEL_SELECT", this.onChannelSelect);
    }
    stop() {
        this.onMessagesLoaded && (this.modulesService.dispatcher.unsubscribe("LOAD_MESSAGES_SUCCESS", this.onMessagesLoaded), 
        this.onMessagesLoaded = void 0), this.onChannelSelect && (this.modulesService.dispatcher.unsubscribe("CHANNEL_SELECT", this.onChannelSelect), 
        this.onChannelSelect = void 0), this.canAttach = !1, this.pendingUpload = void 0;
    }
}

class SettingsService extends BaseService {
    static ADD_BUTTON_CLICK_LISTENER="addButtonClick";
    static REFRESH_BUTTON_CLICK_LISTENER="refreshButtonClick";
    static DELETE_BUTTON_CLICK_LISTENER="deleteButtonClick";
    listenersService;
    settings=DEFAULT_SETTINGS;
    start(listenersService) {
        this.listenersService = listenersService;
        const savedSettings = BdApi.loadData(this.plugin.meta.name, "settings");
        return this.settings = Object.assign({}, DEFAULT_SETTINGS, savedSettings), Promise.resolve();
    }
    getSettingsElement() {
        const emoteService = this.plugin.emoteService;
        if (!emoteService) return new HTMLElement;
        const Settings = this.zeresPluginLibrary.Settings, settings = [];
        let emoteName;
        this.pushRegularSettings(settings, emoteService);
        const emoteNameTextbox = new Settings.Textbox(void 0, "Emote name", void 0, (val => {
            emoteName = val;
        }));
        let imageUrl;
        const imageUrlTextbox = new Settings.Textbox(void 0, "Image URL (must end with .gif or .png, 128px recommended)", void 0, (val => {
            imageUrl = val;
        })), addButton = document.createElement("button");
        addButton.type = "button", addButton.classList.add("bd-button"), addButton.textContent = "Add";
        const addSettingField = new Settings.SettingField(void 0, void 0, void 0, addButton), customEmotesContainer = document.createElement("div"), addListener = {
            element: addButton,
            name: "click",
            callback: () => {
                if (!emoteName) return void BdApi.showToast("No emote name entered!", {
                    type: "error"
                });
                if (!imageUrl) return void BdApi.showToast("No image URL entered!", {
                    type: "error"
                });
                if (!imageUrl.endsWith(".gif") && !imageUrl.endsWith(".png")) return void BdApi.showToast("Image URL must end with .gif or .png!", {
                    type: "error"
                });
                const emoteNames = emoteService.emoteNames ?? {};
                if (emoteNames[emoteService.getPrefixedName(emoteName)]) return void BdApi.showToast("Emote name already exists!", {
                    type: "error"
                });
                this.settings.customEmotes[emoteName] = imageUrl, emoteNames[emoteService.getPrefixedName(emoteName)] = imageUrl;
                const emoteNameTextboxInput = emoteNameTextbox.getElement().querySelector("input");
                emoteNameTextboxInput && (emoteNameTextboxInput.value = "");
                const imageUrlTextboxInput = imageUrlTextbox.getElement().querySelector("input");
                imageUrlTextboxInput && (imageUrlTextboxInput.value = ""), BdApi.saveData(this.plugin.meta.name, "settings", this.settings), 
                emoteService.emoteNames = emoteNames, BdApi.showToast(`Emote ${emoteName} has been saved!`, {
                    type: "success"
                }), customEmotesContainer.append(this.createCustomEmoteContainer(emoteName, customEmotesContainer, emoteService));
            }
        };
        addButton.addEventListener(addListener.name, addListener.callback), this.listenersService.addListener(SettingsService.ADD_BUTTON_CLICK_LISTENER, addListener), 
        Object.keys(this.settings.customEmotes).forEach((key => {
            customEmotesContainer.append(this.createCustomEmoteContainer(key, customEmotesContainer, emoteService));
        }));
        const customEmoteGroup = new Settings.SettingGroup("Custom emotes");
        customEmoteGroup.append(emoteNameTextbox, imageUrlTextbox, addSettingField, customEmotesContainer), 
        settings.push(customEmoteGroup);
        const refreshButton = document.createElement("button");
        refreshButton.type = "button", refreshButton.classList.add("bd-button"), refreshButton.textContent = "Refresh emote list";
        const refreshSettingField = new Settings.SettingField(void 0, void 0, void 0, refreshButton), refreshListener = {
            element: refreshButton,
            name: "click",
            callback: () => {
                emoteService.refreshEmotes();
            }
        };
        return refreshButton.addEventListener(refreshListener.name, refreshListener.callback), 
        this.listenersService.addListener(SettingsService.REFRESH_BUTTON_CLICK_LISTENER, refreshListener), 
        settings.push(refreshSettingField), Settings.SettingPanel.build((() => {
            BdApi.saveData(this.plugin.meta.name, "settings", this.settings);
        }), ...settings);
    }
    pushRegularSettings(settings, emoteService) {
        const Settings = this.zeresPluginLibrary.Settings;
        settings.push(new Settings.Slider("Emote Size", "The size of emotes. (default 48)", 32, 128, this.settings.emoteSize, (val => {
            this.settings.emoteSize = Math.round(val);
        }), {
            units: "px",
            markers: [ 32, 48, 64, 96, 128 ]
        })), settings.push(new Settings.Slider("Autocomplete Emote Size", "The size of emotes in the autocomplete window. (default 15)", 15, 64, this.settings.autocompleteEmoteSize, (val => {
            this.settings.autocompleteEmoteSize = Math.round(val);
        }), {
            units: "px",
            markers: [ 15, 32, 48, 64 ]
        })), settings.push(new Settings.Slider("Autocomplete Items", "The amount of emotes shown in the autocomplete window. (default 10)", 1, 25, this.settings.autocompleteItems, (val => {
            this.settings.autocompleteItems = Math.round(val);
        }), {
            units: " items",
            markers: [ 1, 5, 10, 15, 20, 25 ]
        })), settings.push(new Settings.Switch("Require prefix", "If this is enabled, the autocomplete list will not be shown unless the prefix is also typed.", this.settings.requirePrefix, (checked => {
            this.settings.requirePrefix = checked;
        }))), settings.push(new Settings.Switch("Show standard custom emotes", "If this is enabled, the standard custom emotes will be visible.", this.settings.showStandardEmotes, (checked => {
            this.settings.showStandardEmotes = checked, emoteService.refreshEmotes();
        }))), settings.push(new Settings.Textbox("Prefix", "The prefix to check against for the above setting. It is recommended to use a single character not in use by other chat functionality, other prefixes may cause issues.", this.settings.prefix, _.debounce((val => {
            if (val === this.settings.prefix) return;
            const previousPrefix = this.settings.prefix;
            this.settings.prefix = val, BdApi.saveData(this.plugin.meta.name, "settings", this.settings);
            const previousEmoteNames = Object.assign({}, emoteService.emoteNames), emoteNames = {};
            Object.entries(previousEmoteNames).forEach((([name, value]) => {
                const prefixedName = emoteService.getPrefixedName(name.replace(previousPrefix, ""));
                emoteNames[prefixedName] = value;
            })), emoteService.emoteNames = emoteNames;
        }), 2000))), settings.push(new Settings.RadioGroup("Resize Method", "How emotes will be scaled down to fit your selected emote size", this.settings.resizeMethod, [ {
            name: "Scale down smallest side",
            value: "smallest"
        }, {
            name: "Scale down largest side",
            value: "largest"
        } ], (val => {
            this.settings.resizeMethod = val;
        })));
    }
    createCustomEmoteContainer(emoteName, container, emoteService) {
        const Settings = this.zeresPluginLibrary.Settings, customEmoteContainer = document.createElement("div");
        customEmoteContainer.style.display = "flex";
        const containerImage = document.createElement("img");
        containerImage.src = this.settings.customEmotes[emoteName] ?? "", containerImage.alt = emoteName, 
        containerImage.title = emoteName, containerImage.style.minWidth = `${Math.round(this.settings.autocompleteEmoteSize)}px`, 
        containerImage.style.minHeight = `${Math.round(this.settings.autocompleteEmoteSize)}px`, 
        containerImage.style.width = `${Math.round(this.settings.autocompleteEmoteSize)}px`, 
        containerImage.style.height = `${Math.round(this.settings.autocompleteEmoteSize)}px`, 
        containerImage.style.marginRight = "0.5rem", customEmoteContainer.append(containerImage);
        const deleteButton = document.createElement("button");
        deleteButton.type = "button", deleteButton.classList.add("bd-button", "bd-button-danger"), 
        deleteButton.innerHTML = '<svg class="" fill="#FFFFFF" viewBox="0 0 24 24" style="width: 20px; height: 20px;"><path fill="none" d="M0 0h24v24H0V0z"></path><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"></path><path fill="none" d="M0 0h24v24H0z"></path></svg>', 
        customEmoteContainer.append(deleteButton);
        const deleteListener = {
            element: deleteButton,
            name: "click",
            callback: () => {
                delete this.settings.customEmotes[emoteName], emoteService.emoteNames && delete emoteService.emoteNames[emoteService.getPrefixedName(emoteName)], 
                BdApi.saveData(this.plugin.meta.name, "settings", this.settings), BdApi.showToast(`Emote ${emoteName} has been deleted!`, {
                    type: "success"
                }), container.querySelector(`#${emoteName}`)?.remove();
            }
        };
        deleteButton.addEventListener(deleteListener.name, deleteListener.callback), this.listenersService.addListener(`${SettingsService.DELETE_BUTTON_CLICK_LISTENER}${emoteName}`, deleteListener);
        const targetEmote = this.settings.customEmotes[emoteName], existingEmote = new Settings.SettingField(emoteName, targetEmote, void 0, customEmoteContainer, {
            noteOnTop: !0
        });
        return existingEmote.getElement().id = emoteName, existingEmote.getElement();
    }
    stop() {}
}

class ListenersService extends BaseService {
    listeners={};
    addListenersWatchers={};
    start() {
        return Promise.resolve();
    }
    addListener(id, listener) {
        this.listeners[id] && this.removeListener(id), this.listeners[id] = listener;
    }
    removeListener(id) {
        const listener = this.listeners[id];
        if (!listener) return;
        const {element, name, callback} = listener;
        element && element.removeEventListener(name, callback), delete this.listeners[id];
    }
    requestAddListeners(targetId) {
        Object.entries(this.addListenersWatchers).forEach((([id, addListenersWatcher]) => {
            id === targetId && addListenersWatcher.onAddListeners();
        }));
    }
    stop() {
        Object.keys(this.listeners).forEach((id => {
            this.removeListener(id);
        }));
    }
}

let gifsicle = {
    tool: {
        workerLocalUrl: 'var gifsicle=function(){Me="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(Me=Me||__filename);var Me,c=function(e){var j,r,h=void 0!==(e=e||{})?e:{},t=(h.ready=new Promise(function(e,r){j=e}),h.preRun=h.preRun||[],h.preRun.push(function(){if(h.folder&&h.folder.length)for(let e=0;e<h.folder.length;e++){var r=h.folder[e];T.mkdir(r)}T.mkdir("/tem"),T.mkdir("/out");var t=h.input;for(let e=0;e<t.length;e++){var n=t[e];T.writeFile("/"+n.name,new Uint8Array(n.file))}}),h.postRun=h.postRun||[],h.postRun.push(function(){let r=[],t=T.readdir("/out");t.splice(0,2);for(let e=0;e<t.length;e++){var n=t[e],o=T.readFile("/out/"+n);r.push({file:o,name:n})}h.output(r)}),{});for(r in h)h.hasOwnProperty(r)&&(t[r]=h[r]);var n,o,i,O,a=[],C="./this.program",u=function(e,r){throw r},L=!1,c=!1,L="object"==typeof window,c="function"==typeof importScripts,s="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,I=!L&&!s&&!c,f="";s?(f=c?require("path").dirname(f)+"/":__dirname+"/",n=function(e,r){return i=i||require("fs"),e=(O=O||require("path")).normalize(e),i.readFileSync(e,r?null:"utf8")},o=function(e){e=n(e,!0);return H((e=e.buffer?e:new Uint8Array(e)).buffer),e},1<process.argv.length&&(C=process.argv[1].replace(/\\\\/g,"/")),a=process.argv.slice(2),process.on("uncaughtException",function(e){if(!(e instanceof Fe))throw e}),process.on("unhandledRejection",D),u=function(e){process.exit(e)},h.inspect=function(){return"[Emscripten Module object]"}):I?("undefined"!=typeof read&&(n=function(e){return read(e)}),o=function(e){return"function"==typeof readbuffer?new Uint8Array(readbuffer(e)):(H("object"==typeof(e=read(e,"binary"))),e)},"undefined"!=typeof scriptArgs?a=scriptArgs:void 0!==arguments&&(a=arguments),"function"==typeof quit&&(u=function(e){quit(e)}),"undefined"!=typeof print&&((console="undefined"==typeof console?{}:console).log=print,console.warn=console.error="undefined"!=typeof printErr?printErr:print)):(L||c)&&(c?f=self.location.href:document.currentScript&&(f=document.currentScript.src),f=0!==(f=Me?Me:f).indexOf("blob:")?f.substr(0,f.lastIndexOf("/")+1):"",n=function(e){var r=new XMLHttpRequest;return r.open("GET",e,!1),r.send(null),r.responseText},c&&(o=function(e){var r=new XMLHttpRequest;return r.open("GET",e,!1),r.responseType="arraybuffer",r.send(null),new Uint8Array(r.response)}));var l,d,p,m=h.print||console.log.bind(console),w=h.printErr||console.warn.bind(console);for(r in t)t.hasOwnProperty(r)&&(h[r]=t[r]);t=null,h.arguments&&(a=h.arguments),h.thisProgram&&(C=h.thisProgram),h.quit&&(u=h.quit),h.wasmBinary&&(l=h.wasmBinary),h.noExitRuntime&&(d=h.noExitRuntime),"object"!=typeof WebAssembly&&w("no native wasm support detected");var I=new WebAssembly.Table({initial:64,maximum:64,element:"anyfunc"}),U=!1;function H(e,r){e||D("Assertion failed: "+r)}var q="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function g(e,r,t){for(var n=r+t,o=r;e[o]&&!(n<=o);)++o;if(16<o-r&&e.subarray&&q)return q.decode(e.subarray(r,o));for(var i="";r<o;){var a,s,u=e[r++];128&u?(s=63&e[r++],192==(224&u)?i+=String.fromCharCode((31&u)<<6|s):(a=63&e[r++],(u=224==(240&u)?(15&u)<<12|s<<6|a:(7&u)<<18|s<<12|a<<6|63&e[r++])<65536?i+=String.fromCharCode(u):(s=u-65536,i+=String.fromCharCode(55296|s>>10,56320|1023&s)))):i+=String.fromCharCode(u)}return i}function W(e,r){return e?g(E,e,r):""}function X(e,r,t,n){if(!(0<n))return 0;for(var o=t,i=t+n-1,a=0;a<e.length;++a){var s=e.charCodeAt(a);if((s=55296<=s&&s<=57343?65536+((1023&s)<<10)|1023&e.charCodeAt(++a):s)<=127){if(i<=t)break;r[t++]=s}else if(s<=2047){if(i<=t+1)break;r[t++]=192|s>>6,r[t++]=128|63&s}else if(s<=65535){if(i<=t+2)break;r[t++]=224|s>>12,r[t++]=128|s>>6&63,r[t++]=128|63&s}else{if(i<=t+3)break;r[t++]=240|s>>18,r[t++]=128|s>>12&63,r[t++]=128|s>>6&63,r[t++]=128|63&s}}return r[t]=0,t-o}function G(e){for(var r=0,t=0;t<e.length;++t){var n=e.charCodeAt(t);(n=55296<=n&&n<=57343?65536+((1023&n)<<10)|1023&e.charCodeAt(++t):n)<=127?++r:r+=n<=2047?2:n<=65535?3:4}return r}function V(e){var r=G(e)+1,t=Se(r);return X(e,y,t,r),t}var v,y,E,K,k;function Y(e){v=e,h.HEAP8=y=new Int8Array(e),h.HEAP16=K=new Int16Array(e),h.HEAP32=k=new Int32Array(e),h.HEAPU8=E=new Uint8Array(e),h.HEAPU16=new Uint16Array(e),h.HEAPU32=new Uint32Array(e),h.HEAPF32=new Float32Array(e),h.HEAPF64=new Float64Array(e)}f=h.INITIAL_MEMORY||16777216;function Z(e){for(;0<e.length;){var r,t=e.shift();"function"==typeof t?t(h):"number"==typeof(r=t.func)?void 0===t.arg?h.dynCall_v(r):h.dynCall_vi(r,t.arg):r(void 0===t.arg?null:t.arg)}}p=h.wasmMemory||new WebAssembly.Memory({initial:f/65536,maximum:32768}),f=(v=p?p.buffer:v).byteLength,Y(v),k[9776]=5282144;var $=[],J=[],Q=[],ee=[];function re(){if(h.preRun)for("function"==typeof h.preRun&&(h.preRun=[h.preRun]);h.preRun.length;)e=h.preRun.shift(),$.unshift(e);var e;Z($)}function te(){if(h.postRun)for("function"==typeof h.postRun&&(h.postRun=[h.postRun]);h.postRun.length;)e=h.postRun.shift(),ee.unshift(e);var e;Z(ee)}var ne=Math.abs,oe=Math.ceil,ie=Math.floor,ae=Math.min,_=0,b=null;function se(){_++,h.monitorRunDependencies&&h.monitorRunDependencies(_)}function ue(){var e;_--,h.monitorRunDependencies&&h.monitorRunDependencies(_),0==_&&b&&(e=b,b=null,e())}function D(e){throw h.onAbort&&h.onAbort(e),m(e+=""),w(e),U=!0,e="abort("+e+"). Build with -s ASSERTIONS=1 for more info.",new WebAssembly.RuntimeError(e)}function ce(e,r){return String.prototype.startsWith?e.startsWith(r):0===e.indexOf(r)}h.preloadedImages={},h.preloadedAudios={};var fe="data:application/octet-stream;base64,";var le="file://";function de(e){return ce(e,le)}var S,F,P="data:application/wasm;base64,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ACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAAC5ABAQN/IAAhAQJAAkAgAEEDcUUNACAALQAARQRAQQAPCwNAIAFBAWoiAUEDcUUNASABLQAADQALDAELA0AgASICQQRqIQEgAigCACIDQX9zIANB//37d2pxQYCBgoR4cUUNAAsgA0H/AXFFBEAgAiAAaw8LA0AgAi0AASEDIAJBAWoiASECIAMNAAsLIAEgAGsLSgECfwJAIAAtAAAiAkUgAiABLQAAIgNHcg0AA0AgAS0AASEDIAAtAAEiAkUNASABQQFqIQEgAEEBaiEAIAIgA0YNAAsLIAIgA2sLoggBC38gAEUEQCABEBoPCyABQUBPBEBB3JwCQTA2AgBBAA8LIABBfGoiBygCACIIQXhxIQIgCEEDcSIDQQFGQeCtAigCACILIABBeGoiBktyGkEQIAFBC2pBeHEgAUELSRshBAJAAkAgA0UEQCAEQYACSSACIARBBHJJcg0BIAIgBGtBsLECKAIAQQF0TQ0CDAELIAIgBmohBSACIARPBEAgAiAEayIBQRBJDQIgByAIQQFxIARyQQJyNgIAIAQgBmoiAiABQQNyNgIEIAUgBSgCBEEBcjYCBCACIAEQpQEgAA8LIAVB6K0CKAIARgRAQdytAigCACACaiICIARNDQEgByAIQQFxIARyQQJyNgIAIAQgBmoiASACIARrIgJBAXI2AgRB3K0CIAI2AgBB6K0CIAE2AgAgAA8LIAVB5K0CKAIARgRAQditAigCACACaiICIARJDQECQCACIARrIgFBEE8EQCAHIAhBAXEgBHJBAnI2AgAgBCAGaiIDIAFBAXI2AgQgAiAGaiICIAE2AgAgAiACKAIEQX5xNgIEDAELIAcgCEEBcSACckECcjYCACACIAZqIgEgASgCBEEBcjYCBEEAIQFBACEDC0HkrQIgAzYCAEHYrQIgATYCACAADwsgBSgCBCIDQQJxDQAgA0F4cSACaiIJIARJDQAgCSAEayEMAkAgA0H/AU0EQCAFKAIIIgIgA0EDdiIDQQN0QfitAmpHGiACIAUoAgwiAUYEQEHQrQJB0K0CKAIAQX4gA3dxNgIADAILIAIgATYCDCABIAI2AggMAQsgBSgCGCEKAkAgBSAFKAIMIgJHBEAgCyAFKAIIIgFNBEAgASgCDBoLIAEgAjYCDCACIAE2AggMAQsCQCAFQRRqIgEoAgAiAw0AIAVBEGoiASgCACIDDQBBACECDAELA0AgASELIAMiAkEUaiIBKAIAIgMNACACQRBqIQEgAigCECIDDQALIAtBADYCAAsgCkUNAAJAIAUgBSgCHCIBQQJ0QYCwAmoiAygCAEYEQCADIAI2AgAgAg0BQdStAkHUrQIoAgBBfiABd3E2AgAMAgsgCkEQQRQgCigCECAFRhtqIAI2AgAgAkUNAQsgAiAKNgIYIAUoAhAiAQRAIAIgATYCECABIAI2AhgLIAUoAhQiAUUNACACIAE2AhQgASACNgIYCyAMQQ9NBEAgByAIQQFxIAlyQQJyNgIAIAYgCWoiASABKAIEQQFyNgIEIAAPCyAHIAhBAXEgBHJBAnI2AgAgBCAGaiIBIAxBA3I2AgQgBiAJaiICIAIoAgRBAXI2AgQgASAMEKUBIAAPCyABEBoiAkUEQEEADwsgAiAAQXxBeCAHKAIAIgNBA3EbIANBeHFqIgMgASADIAFJGxAYGiAAEBYgAiEACyAAC8EBAgN/AX4CQAJAIAApA3AiBFBFBEAgACkDeCAEWQ0BCyAAEGsiAkF/Sg0BCyAAQQA2AmhBfw8LIAAoAgghAQJAAkAgACkDcCIEUA0AIAQgACkDeEJ/hXwiBCABIAAoAgQiA2usWQ0AIAAgAyAEp2o2AmgMAQsgACABNgJoCwJAIAFFBEAgACgCBCEADAELIAAgACkDeCABIAAoAgQiAGtBAWqsfDcDeAsgAEF/aiIALQAAIAJHBEAgACACOgAACyACC5gLAgV/D34jAEHgAGsiBSQAIAJCIIYgAUIgiIQhDyAEQi+GIANCEYiEIQ0gBEL///////8/gyIOQg+GIANCMYiEIRAgAiAEhUKAgICAgICAgIB/gyEKIAJC////////P4MiC0IgiCERIA5CEYghEiAEQjCIp0H//wFxIQcCQAJ/IAJCMIinQf//AXEiCUF/akH9/wFNBEBBACAHQX9qQf7/AUkNARoLIAFQIAJC////////////AIMiDEKAgICAgIDA//8AVCAMQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQoMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhCiADIQEMAgsgASAMQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhCkIAIQEMAwsgCkKAgICAgIDA//8AhCEKQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAIAEgDIQhAkIAIQEgAlAEQEKAgICAgIDg//8AIQoMAwsgCkKAgICAgIDA//8AhCEKDAILIAEgDIRQBEBCACEBDAILIAIgA4RQBEBCACEBDAILIAxC////////P1gEQCAFQdAAaiABIAsgASALIAtQIgYbeSAGQQZ0rXynIgZBcWoQKCAFKQNYIgtCIIYgBSkDUCIBQiCIhCEPIAtCIIghEUEQIAZrIQYLIAYgAkL///////8/Vg0AGiAFQUBrIAMgDiADIA4gDlAiCBt5IAhBBnStfKciCEFxahAoIAUpA0giAkIPhiAFKQNAIgNCMYiEIRAgAkIvhiADQhGIhCENIAJCEYghEiAGIAhrQRBqCyEGIA1C/////w+DIgIgAUL/////D4MiAX4iEyADQg+GQoCA/v8PgyIDIA9C/////w+DIgx+fCIEQiCGIg4gASADfnwiDSAOVK0gAiAMfiIVIAMgC0L/////D4MiC358IhQgEEL/////D4MiDiABfnwiECAEIBNUrUIghiAEQiCIhHwiEyACIAt+IhYgAyARQoCABIQiD358IgMgDCAOfnwiESABIBJC/////weDQoCAgIAIhCIBfnwiEkIghnwiF3whBCAHIAlqIAZqQYGAf2ohBgJAIAsgDn4iGCACIA9+fCICIBhUrSACIAEgDH58Igwg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AAsLAkACQCAAIAhHBEAgBigCECIFIABBBHRqIgcoAgAgAUYNAQsCQEEAIAggCEEHcRtFBEAgBigCECEFDAELIAYoAhAgCEEEdEGAAWoQHiIFRQ0DIAYgBTYCECAGKAIUIQgLIAUgAEEEdCIJaiIHQRBqIAcgCCAAa0EEdBDCASAGIAYoAhRBAWo2AhQgBigCECIFIAlqQQA2AgQMAQsgBygCBEEFRw0AIAUgAEEEdGooAgwiBygCABAWIAcoAgQQFiAHEBYgBigCECEFCyAFIABBBHRqIgAgBDYCDCAAIAI2AgggACADNgIEIAAgATYCAEEAIQoLIAoLaQEBfyMAQYACayIFJAAgBEGAwARxIAIgA0xyRQRAIAUgASACIANrIgJBgAIgAkGAAkkiARsQGxogAUUEQANAIAAgBUGAAhAnIAJBgH5qIgJB/wFLDQALCyAAIAUgAhAnCyAFQYACaiQAC2gBAX8gAEEASCABQQFIckVBAEEAQRRBARAXIgIbRQRAIAIQFkEADwsgAiAANgIAIAIgACABIAAgAUobIgA2AgQgAkEAQQggABAXIgE2AhAgAkIANwIIIAIhACABBH8gAAUgABAWQQALCyUBAX8jAEEQayICJAAgAiABNgIMQQBBAEEDIAAgARBdQQEQAgALwQkCBH8EfiMAQfAAayIFJAAgBEL///////////8AgyEKAkACQCABQn98IgtCf1EgAkL///////////8AgyIJIAsgAVStfEJ/fCILQv///////7///wBWIAtC////////v///AFEbRQRAIANCf3wiC0J/UiAKIAsgA1StfEJ/fCILQv///////7///wBUIAtC////////v///AFEbDQELIAFQIAlCgICAgICAwP//AFQgCUKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEEIAEhAwwCCyADUCAKQoCAgICAgMD//wBUIApCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhBAwCCyABIAlCgICAgICAwP//AIWEUARAQoCAgICAgOD//wAgAiABIAOFIAIgBIVCgICAgICAgICAf4WEUCIGGyEEQgAgASAGGyEDDAILIAMgCkKAgICAgIDA//8AhYRQDQEgASAJhFAEQCADIAqEQgBSDQIgASADgyEDIAIgBIMhBAwCCyADIAqEUEUN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BiAEIAFBAnRqKAIARQ0AC0F/QQEgAEEJSRshBwwFCwsgAEEgIAogByAMayIOIAsgCyAOSBsiE2oiByAPIA8gB0gbIgEgByAJECsgACAQIAoQJyAAQTAgASAHIAlBgIAEcxArIABBMCATIA5BABArIAAgDCAOECcgAEEgIAEgByAJQYDAAHMQKwwBCwtBACEHDAELQX8hBwsgCEHQAGokACAHC20BAn9BAEHMAEEBEBciAAR/IABCADcCACAAQgA3AhggAEEANgI8IABB//8DOwEUIABBADYCSCAAQgA3AkAgAEEGNgIoIABCADcCICAAQgA3AiwgAEIANwIIIABBADYCECAAQgA3AjQgAAVBAAsLEAAgACABIAJBAEEAELoBGgt8AQJ/IAAgAC0ASiIBQX9qIAFyOgBKIAAoAhQgACgCHEsEQCAAQQBBACAAKAIkEQMAGgsgAEEANgIcIABCADcDECAAKAIAIgFBBHEEQCAAIAFBIHI2AgBBfw8LIAAgACgCLCAAKAIwaiICNgIIIAAgAjYCBCABQRt0QR91C2kBAn8CQCAAKAIUIAAoAhxNDQAgAEEAQQAgACgCJBEDABogACgCFA0AQX8PCyAAKAIEIgEgACgCCCICSQRAIAAgASACa6xBASAAKAIoEQ8AGgsgAEEANgIcIABCADcDECAAQgA3AgRBAAtAAQF/IwBBEGsiBSQAIAUgASACIAMgBEKAgICAgICAgIB/hRAuIAAgBSkDADcDACAAIAUpAwg3AwggBUEQaiQACykBAX8jAEEQayICJAAgAiABNgIMQYjoASgCACAAIAEQhQEgAkEQaiQAC7cBAQR/AkAgAigCECIDBH8gAwUgAhDBAQ0BIAIoAhALIAIoAhQiBWsgAUkEQCACIAAgASACKAIkEQMADwsCQCACLABLQQBIDQAgASEEA0AgBCIDRQ0BIAAgA0F/aiIEai0AAEEKRw0ACyACIAAgAyACKAIkEQMAIgQgA0kNASABIANrIQEgACADaiEAIAIoAhQhBSADIQYLIAUgACABEBgaIAIgAigCFCABajYCFCABIAZqIQQLIAQLgwEBA38jAEEQayICJAAgAiABOgAPAkAgACgCECIDRQRAIAAQwQENASAAKAIQIQMLAkAgACgCFCIEIANPDQAgACwASyABQf8BcUYNACAAIARBAWo2AhQg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IAAgBiAEoKKhDwsgAUEDdCIBQcCIAmorAwAgACAGIASgoiABQeCIAmorAwChIAChoSIAmiAAIANCAFMbIQALIAAPCyAARBgtRFT7Ifk/IACmIANC////////////AINCgICAgICAgPj/AFYbC5IBAQN8RAAAAAAAAPA/IAAgAKIiAkQAAAAAAADgP6IiA6EiBEQAAAAAAADwPyAEoSADoSACIAIgAiACRJAVyxmgAfo+okR3UcEWbMFWv6CiRExVVVVVVaU/oKIgAiACoiIDIAOiIAIgAkTUOIi+6fqovaJExLG0vZ7uIT6gokStUpyAT36SvqCioKIgACABoqGgoAtGAQF/IwBBIGsiASQAAn8gACABQQhqEBEiAEUEQEE7IQBBASABLQAIQQJGDQEaC0HcnAIgADYCAEEACyEAIAFBIGokACAAC+EBAQN/IwBBIGsiBEIANwMYIARCADcDECAEQgA3AwggBEIANwMAIAEtAAAiAkUEQEEADwsgAS0AAUUEQCAAIQEDQCABIgNBAWohASADLQAAIAJGDQALIAMgAGsPCwNAIAQgAkEDdkEccWoiAyADKAIAQQEgAkEfcXRyNgIAIAEtAAEhAiABQQFqIQEgAg0ACyAAIQMCQCAALQAAIgJFDQAgACEBA0AgBCACQQN2QRxxaigCACACQR9xdkEBcUUEQCABIQMMAgsgAS0AASECIAFBAWoiAyEBIAINAAsLIAMgAGsLewECfwJAIAAoAgQiAyAAKAIIIgJIBEAgACgCACECDAELIAAgAkEBdEECIAIbIgM2AgggACAAKAIAQQQgAxAXIgI2AgAgAkUEQEEADwsgACgCBCEDCyACIANBAnRqIAE2AgAgACADQQFqNgIEIAEgASgCSEEBajYCSEEBCw4AIAAgABAcQQFqEJICCwkAIAAgARCTAgt7AQF/IwBBkAFrIgQkACAEIAA2AiwgBCAANgIEIARBADYCACAEQX82AkwgBEF/IABB/////wdqIABBAEgbNgIIIARCABA0IAQgAkEBIAMQtwEhAyABBEAgASAAIAQoAgQgBCgCeGogBCgCCGtqNgIACyAEQZABaiQAIAMLpQEBBX8jAEGAAmsiBCQAAkAgAkECSA0AIAEgAkECdGoiByAENgIAIABFDQAgBCEDA0AgAyABKAIAIABBgAIgAEGAAkkbIgUQ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AAsMAgsgAkEDTQ0AA0AgACABKAIANgIAIAFBBGohASAAQQRqIQAgAkF8aiICQQNLDQALCyACRQ0AA0AgACABLQAAOgAAIABBAWohACABQQFqIQEgAkF/aiICDQALCwuhBgIFfwR+IwBBgAFrIgUkAAJAAkACQCADIARCAEIAEEhFDQAgAyAEELoCIQcgAkIwiKciCUH//wFxIgZB//8BRg0AIAcNAQsgBUEQaiABIAIgAyAEECAgBSAFKQMQIgIgBSkDGCIBIAIgARDEASAFKQMIIQIgBSkDACEEDAELIAEgAkL///////8/gyAGrUIwhoQiCiADIARC////////P4MgBEIwiKdB//8BcSIHrUIwhoQiCxBIQQBMBEAgASAKIAMgCxBIBEAgASEEDAILIAVB8ABqIAEgAkIAQgAQICAFKQN4IQIgBSkDcCEEDAELIAYEfiABBSAFQeAAaiABIApCAEKAgICAgIDAu8AAECAgBSkDaCIKQjCIp0GIf2ohBiAFKQNgCyEEIAdFBEAgBUHQAGogAyALQgBCgICAgICAwLvAABAgIAUpA1giC0IwiKdBiH9qIQcgBSkDUCEDCyAKQv///////z+DQoCAgICAgMAAhCIKIAtC////////P4NCgICAgICAwACEIg19IAQgA1StfSIMQn9VIQggBCADfSELIAYgB0oEQANAAn4gCARAIAsgDIRQBEAgBUEgaiABIAJCAEIAECAgBSkDKCECIAUpAyAhBAwFCyALQj+IIQogDEIBhgwBCyAKQgGGIQogBCELIARCP4gLIQwgCiAMhCIKIA19IAtCAYYiBCADVK19IgxCf1UhCCAEIAN9IQsgBkF/aiIGIAdKDQALIAchBgsCQCAIRQ0AIAsiBCAMIgqEQgBSDQAgBUEwaiABIAJCAEIAECAgBSkDOCECIAUpAzAhBAwBCyAKQv///////z9YBEADQCAEQj+IIQEgBkF/aiEGIARCAYYhBCABIApCAYaEIgpCgICAgICAwABUDQALCyAJQYCAAnEhByAGQQBMBEAgBUFAayAEIApC////////P4MgBkH4AGogB3KtQjCGhEIAQoCAgICAgMDDPxAgIAUpA0ghAiAFKQNAIQQMAQsgCkL///////8/gyAGIAdyrUIwhoQhAgsgACAENwMAIAAgAjcDCCAFQYABaiQAC4IRAgV/DH4jAEHAAWsiBSQAIARC////////P4MhEiACQv///////z+DIQwgAiAEhUKAgICAgICAgIB/gyERIARCMIinQf//AXEhBwJAAkACQCACQjCIp0H//wFxIglBf2pB/f8BTQRAIAdBf2pB/v8BSQ0BCyABUCACQv///////////wCDIgpCgICAgICAwP//AFQgCkKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCERDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIREgAyEBDAILIAEgCkKAgICAgIDA//8AhYRQBEAgAyACQoCAgICAgMD//wCFhFAEQEIAIQFCgICAgICA4P//ACERDAMLIBFCgICAgICAwP//AIQhEUIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQEIAIQEMAgsgASAKhFANAiACIAOEUARAIBFCgICAgICAwP//AIQhEUIAIQEMAgsgCkL///////8/WARAIAVBsAFqIAEgDCABIAwgDFAiBht5IAZBBnStfKciBkFxahAoQRAgBmshBiAFKQO4ASEMIAUpA7ABIQELIAJC////////P1YNACAFQaABaiADIBIgAyASIBJQIggbeSAIQQZ0rXynIghBcWoQKCAGIAhqQXBqIQYgBSkDqAEhEiAFKQOgASEDCyAFQZABaiASQoCAgICAgMAAhCIUQg+GIANCMYiEIgJChMn5zr/mvIL1ACACfSIEEDogBUGAAWpCACAFKQOYAX0gBBA6IAVB8ABqIAUpA4gBQgGGIAUpA4ABQj+IhCIEIAIQOiAFQeAAaiAEQgAgBSkDeH0QOiAFQdAAaiAFKQNoQgGGIAUpA2BCP4iEIgQgAhA6IAVBQGsgBEIAIAUpA1h9EDogBUEwaiAFKQNIQgGGIAUpA0BCP4iEIgQgAhA6IAVBIGogBEIAIAUpAzh9EDogBUEQaiAFKQMoQgGGIAUpAyBCP4iEIgQgAhA6IAUgBEIAIAUpAxh9EDogBiAJIAdraiEGAn5CACAFKQMIQgGGIAUpAwBCP4iEQn98IgpC/////w+DIgQgAkIgiCIOfiIQIApCIIgiCiACQv////8PgyILfnwiAkIghiINIAQgC358IgsgDVStIAogDn4gAiAQVK1CIIYgAkIgiIR8fCALIAQgA0IRiEL/////D4MiDn4iECAKIANCD4ZCgID+/w+DIg1+fCICQiCGIg8gBCANfnwgD1StIAogDn4gAiAQVK1CIIYgAkIgiIR8fHwiAiALVK18IAJCAFKtfH0iC0L/////D4MiDiAEfiIQIAogDn4iDSAEIAtCIIgiD358IgtCIIZ8Ig4gEFStIAogD34gCyANVK1CIIYgC0IgiIR8fCAOQgAgAn0iAkIgiCILIAR+IhAgAkL/////D4MiDSAKfnwiAkIghiIPIAQgDX58IA9UrSAKIAt+IAIgEFStQiCGIAJCIIiEfHx8IgIgDlStfCACQn58IhAgAlStfEJ/fCILQv////8PgyICIAxCAoYgAUI+iIRC/////w+DIgR+Ig4gAUIeiEL/////D4MiCiALQiCIIgt+fCINIA5UrSANIBBCIIgiDiAMQh6IQv//7/8Pg0KAgBCEIgx+fCIPIA1UrXwgCyAMfnwgAiAMfiITIAQgC358Ig0gE1StQiCGIA1CIIiEfCAPIA1CIIZ8Ig0gD1StfCANIAogDn4iEyAQQv////8PgyIQIAR+fCIPIBNUrSAPIAIgAUIChkL8////D4MiE358IhUgD1StfHwiDyANVK18IA8gCyATfiILIAwgEH58IgwgBCAOfnwiBCACIAp+fCICQiCIIAIgBFStIAwgC1StIAQgDFStfHxCIIaEfCIMIA9UrXwgDCAVIA4gE34iBCAKIBB+fCIKQiCIIAogBFStQiCGhHwiBCAVVK0gBCACQiCGfCAEVK18fCIEIAxUrXwiAkL/////////AFgEQCABQjGGIARC/////w+DIgEgA0L/////D4MiCn4iDEIAUq19QgAgDH0iECAEQiCIIgwgCn4iDSABIANCIIgiC358Ig5CIIYiD1StfSACQv////8PgyAKfiABIBJC/////w+DfnwgCyAMfnwgDiANVK1CIIYgDkIgiIR8IAQgFEIgiH4gAyACQiCIfnwgAiALfnwgDCASfnxCIIZ8fSESIAZBf2ohBiAQIA99DAELIARCIYghCyABQjCGIAJCP4YgBEIBiIQiBEL/////D4MiASADQv////8PgyIKfiIMQgBSrX1CACAMfSIOIAEgA0IgiCIMfiIQIAsgAkIfhoQiDUL/////D4MiDyAKfnwiC0IghiITVK19IAwgD34gCiACQgGIIgpC/////w+DfnwgASASQv////8Pg358IAsgEFStQiCGIAtCIIiEfCAEIBRCIIh+IAMgAkIhiH58IAogDH58IA0gEn58QiCGfH0hEiAKIQIgDiATfQshASAGQYCAAU4EQCARQoCAgICAgMD//wCEIRFCACEBDAELIAZB//8AaiEHIAZBgYB/TARAAkAgBw0AIAQgAUIBhiADViASQgGGIAFCP4iEIgEgFFYgASAUURutfCIBIARUrSACQv///////z+DfCICQoCAgICAgMAAg1ANACACIBGEIREMAgtCACEBDAELIAQgAUIBhiADWiASQgGGIAFCP4iEIgEgFFogASAUURutfCIBIARUrSACQv///////z+DIAetQjCGhHwgEYQhEQsgACABNwMAIAAgETcDCCAFQcABaiQADwsgAEIANwMAIAAgEUKAgICAgIDg//8AIAIgA4RCAFIbNwMIIAVBwAFqJAAL5AMBC38jAEEgayIMJAAgAi4BFCEQIAEoAhAhEQJAAkAgBSAGRg0AQYCAgBAhCyAFIBBGIg0gBiAQR0cEQEEAIQsgDQ0BIBEgBUEDdGoiCy0AAiARIAZBA3RqIg0tAAJrIg4gBy4BAiIUaiISIBJsIAstAAEgDS0AAWsiEiAHLgEAIhVqIg8gD2xqIAstAAMgDS0AA2siCyAHLgEEIg1qIg8gD2xqIg8gFEECbSAOaiIOIA5sIBVBAm0gEmoiDiAObGogDUECbSALaiILIAtsaiILIA8gC0kbIQsLIAsgCUsNAQsCfyAGIBBGBEBBACENQQAMAQtBACENQQAgBSAQRg0AGiARIAVBA3RqIgUtAAMgESAGQQN0aiIGLQADayAHLgEEQQNsQQRtaiENIAUtAAEgBi0AAWsgBy4BAEEDbEEEbWohEyAFLQACIAYtAAJrIAcuAQJBA2xBBG1qCyEOIAwgDTsBBCAMIA47ARogDCATOwEYIAwgDTsBHCAMIAwoAhg2AgAgDEEIaiAAIAEgAiADQQFqIAQgCCALaiAMIAkQjQEgDCgCDCIAIAooAgQiAU0EQCAAIAFHDQEgDCgCECAKKAIITw0BCyAKIAwpAwg3AgAgCiAMKAIQNgIICyAMQSBqJAALlAIBBH8gACgCAEEATgRAQSEgASABKAJYEQEAIAAtAAAgASABKAJYEQEAAkAgACgCAEH/AUcNACAAKAIIIgJFDQAgAkH/AXEgASABKAJYEQEAIAAoAgQgACgCCCABIAEoAlwRBQALAkAgACgCFEUEQCAAKAIQIgRBgAJPBEBB/wEhAgNAQf8BIAEgASgCWBEBACAAKAIMIAVqQf8BIAEgASgCXBEFACACIgMhBSADQf8BaiICIAAoAhAiBEkNAAsLIAQgA00NASAEIANrIgJB/wFxIAEgASgCWBEBACAAKAIMIANqIAIgASABKAJcEQUADAELIAAoAgwgACgCECABIAEoAlwRBQALQQAgASABKAJYEQEACwugAgEEfwJAAkAgAEUNACAAQeu0ARAdRQRAQdgBQYACECwiAigCECEDQQAhAANAIAMgAEEDdGoiASAAQf8BcSIEQSRuQTNsOgABIAEgBEEGbiIEQQZwQTNsOgACIAEgACAEQQZsa0EzbDoAAyAAQQFqIgBB2AFHDQALDAILAkAgAEGFjQEQHQRAIABB77QBEB0NAQtBgAJBgAIQLCICKAIQIQNBACEAA0AgAyAAQQN0aiIBIAA6AAIgASAAOgADIAEgADoAASAAQQFqIgBBgAJHDQALDAILIABB9LQBEB0NAEECQYACECwiAigCECIAQQA6AAMgAEEAOwABIABB/wE6AAsgAEH//wM7AAkMAQsgAEEAENYBIQILQdiXAiACNgIAC58GAgR/AnwjAEEwayIDJAACQAJAAkACQEHslAIoAgBFBEBB8JQCKAIABEBB2wAgAEH4sAEgABsQmAELQZyVAiAANgIAQQEhBEGEigJBuJUCKAIAQQBHQbSVAigCAEEASnIiBUEBczYCAAJAQeSVAigCAEUEQEHglQIvAQBFIAVBf3NxDQELQZCWAigCACEEC0HQlAIoAgAgASACIAQgA0EYahDWAiIBRQ0EAkACfEHklQIoAgAiAkECRgRAQfiVAisDACABLwESuKIhB0GAlgIrAwAgAS8BFLiiDAELIAJFDQFB6JUCKAIAtyEHQeyVAigCALcLIQggASAHIAhB8JUCKAIAQYiWAigCAEGMlgIoAgAQyAILAkAgBUUNAEG4lQIoAgBFBEBBtJUCKAIAQQFIDQELQdCVAigCAEHYlQIrAwAQ6AFBuJUCKAIAIgIEQCABIAIQ3QELQQAhBEG0lQIoAgBBAUgNACABKAIEIgVBAU4EQCABKAIAIQZBACECA0BBASACIAYgBEECdGooAgAoAhgbIQIgBEEBaiIEIAVHDQALIAJBAEchBAsgA0EgaiABIANBHGoQ5gECQCAEDQAgAygCJCICQbSVAigCAEoNAEG4lQIoAgANACADIAI2AhBBAUGBsQEgA0EQahAZIANBIGoQVgwBC0HAlQIgAygCHEEARzYCAEG8lQIoAgAiAkEDTw0CIAEgA0EgakGYlQIgAkECdEHctwFqKAIAEQIAIgIQ3QEgAhAzIANBIGoQVgtBuJgCKAIAIgIEQCACIAEQ0QELQeCVAigCACICQf//A3EEQCABIAIgAygCGBDuAQsCQCAABEAgAEHCsQEQWSEEDAELQYjoASgCACIEEL4BEKkBDQNBxbEBIQALIAQEQCABIAQQwgIgBBA/QbyYAkEBOgAADAQLIANB3JwCKAIAEFA2AgAgAEG9rwEgAxApDAMLQamlAUG2pQFB5wdB4bABEAAAC0G1sQFBABAtAAtBxbEBQc6xAUEAECkLIAEQPAtB8JQCKAIABEBB3QAQXAtBnJUCQQA2AgAgA0EwaiQAC4AUARV/IwBBQGoiCCQAIAAoAjwiBEEANgKkASAEQX82ApgBAkACQAJ/IAAgBCgClAFFQQF0EG5FBEAgACAAKAIMNgIQIAAgACgCCCIARUEUbEGACGo2AgBBAEF/IAAbDAELIAAgBC0AnQE2AgQgACgCPCIDKAIAIQkgBCgCiAEhBgJAAkACQAJAAkACQAJAAkACQAJAIAQtAJwBBEAgAygCBCEFAn8gAygCfARAIAZBABA3DAELIAYtAAALIQIgAygCCCIGQQFIDQEDQAJAIAUgB0EMbGovAQAiAUECcUUNACAJIAdBFGxqKAIEIAJHDQAgAUEgcUVBACAAKAIEIgMbDQAgAEEBIAFBBHZBf3NBAXEgAxsiAzYCBAwHCyAHQQFqIgcgBkcNAAsMAQsCQAJAAkACQCAAIAYgAygCCCAJIAMoAgQgA0GkAWoiAiADQagBaiIFEJkBIgdBf0wEQCACKAIAIQEDQCAGLQAAQe4ARw0CIAYtAAFB7wBHDQIgBi0AAkEtRw0CIAAgACgCBEU2AgQgACAGQQNqIgYgAygCCCAJIAMoAgQgAiAFEJkBIgdBf0wNAAsLIAMoAgQgB0EMbGoiAUEIaiABQQRqIAAoAgQiBRsoAgAhCiADLQCeAUUNAyABLwEAIQIgBUUNASACQYACcQ0CDAMLIAEgAigCACICQQQgAkEESBsiAk4NAwNAIAMgAUECdGoiBUGoAWogBSgCqAFBf3M2AgAgAUEBaiIBIAJHDQALDAMLIAJBgAFxRQ0BC0EBIQUgCgJ/IAMoAnwEQCAGIAhBNGoQNxogCCgCNCAGayEFCyAFQQFqCyAFIApIGyEKCwJAIApBAU4EQCAJIAdBFGxqKAIAIAEtAAJqIgwtAAAhBSAGIQkgDCECA0AgAiEBAkACQCAFQf8BcUUNAANAIAktAAAiA0UgA0E9RnIgBUH/AXEgA0dyRQRAIAlBAWohCSABLQABIQUgAUEBaiICIQEgBQ0BDAILCyAFQf8BcUEtRgRAIAEtAAEiCw0CCyABIQILIAktAAAhAyACIQEMAwsgAUEBaiECIAMhBSADIAtGDQALDAELQZ0OQdEJQaEHQasOEAAACyABIAxrIApIIAkgBmtBAExyIANB/wFxIgJBPUdBACACG3INAiADQf8BcUE9RgRAIABBATYCCCAAIAlBAWo2AgwLIAdBf0oNAQsgBC0AngFFDQQgACgCPCIGKAIYKAIAIQECfyAGKAJ8BEAgASAIQTRqEDchBSAIKAI0IAFrIQogACgCPAwBCyABLQAAIQVBASEKIAYLIgEoAnAiCUEBSARAQQAhAgwDC0EAIQdBACECIAEoAiAiA0UEQCABKAIkIQILA0AgAyAFRgRAIAEgB0EDdGooAiQhAgsgB0EBaiIHIAlGDQMgASAHQQN0aigCICEDDAAACwALIAAoAgQhAwwCC0GpD0HRCUHoDUGxDxAAAAsgBi0AngFFDQcgBkEBOgCcASAGIAJBAnZBAXE6AJ0BIApBBU4NCCAGQYABaiAGKAIYKAIAIgEgChAYIApqQQA6AAAgBiABIApqNgKIASAEKAKIASECIAAoAjwiASgCBCEFIAEoAgAhBgJ/IAEoAnwEQCACQQAQNwwBCyACLQAACyECIAEoAggiCUEBSA0BQQAhBwNAAkAgBSAHQQxsai8BACIBQQJxRQ0AIAYgB0EUbGooAgQgAkcNACABQSBxRUEAIAAoAgQiAxsNACAAQQEgAUEEdkF/c0EBcSADGyIDNgIEDAILIAdBAWoiByAJRw0ACwwBCyADRQ0CIAQoAgQgB0EMbGotAABBIHENAQsgBCgCGCgCAEHXCRAdRQRAIAAoAjxBADYClAEgABDJAQwFCwJAIAQoAqQBIgEEQCAEKAIEIQIgBCgCACEDIAggBCgCiAE2AiQgCCAEQYABaiIFNgIgIAAgASAEQagBaiADIAIgBUHaCSAIQSBqENoBDAELAkAgBC0AnAFFDQAgBC0AngENACAIIAQoAogBNgIUIAggBEGAAWo2AhAgAEH3CSAIQRBqECIaDAELIAggBCgCiAE2AgQgCCAEQYABajYCACAAQZQKIAgQIhoLIABBqAg2AgBBfgwECyAEIAc2ApgBIAQgBC0AnAE6AJ8BIAQgBC0AnQFFOgCgAQwBCyAEQQA6AKABIAQgBzYCmAEgBCAELQCcASIKOgCfASAEKAIEIAdBDGxqLwEAIg1BDHENAQsgACgCCARAIABBsQpBABAiGiAAQagINgIAQX4MAgsgACAEKAIAIAdBFGxqIgA2AgAgACgCCAwBCyAEKAIAIhQgB0EUbGoiBigCDCIJQQBMBEAgAEG8CDYCAEF9DAELAkAgBCgCFCIFRQRAQQAhAwwBCyAEKAIQIQxBACEDIAUhAQNAIAkgDCABIANrQQF2IANqIgJBBHRqKAIAIgtGBEAgAiEDDAILIAEgAiALIAlIIgsbIgEgAkEBaiADIAsbIgNLDQALCwJAIAMgBUcEQCAEKAIQIhUgA0EEdGooAgAgCUYNAQsgAEG8CDYCAEF9DAELIAAoAjwiASgCHCEFIAEoAhghCSAAKAIIIQIgCCABLQCEAToAOCAIIAEoAoABNgI0IAEtAKABIQwgAS0AnwEhCyABLQCdASEOIAEtAJwBIQ8gASgCmAEhECABKAIMIREgASgClAEhEiABKAKIASETAkACQAJAIA1BBHEiDQRAIAINASAAQQFBAiAVIANBBHRqKAIIQQFxGxBuGiAAKAIIBEAgACAGNgIADAMLIAQoAogBIQIgACgCPCIBIAU2AhwgASAJNgIYIAEgCCgCNDYCgAEgASAILQA4OgCEASABIAw6AKABIAEgCzoAnwEgASAOOgCdASABIA86AJwBIAEgEjYClAEgASATNgKIASABIBBBfyABKAIMIBFGGzYCmAEgAEHQCkH2CiACG0EAECIaIABBqAg2AgBBfgwECyACIApFcg0AIAQoAogBIQECf0EBIAQoAnxFDQAaIAEgCEE8ahA3GiAIKAI8IAFrCyABai0AAEUNACAAQQEQbhoLIAAgBjYCACAAKAIIRQ0BCyAAIAAoAgwgAiANckEARyIBIAQoAhAgA0EEdGoiAigCDCACKAIEEQcAQQBKDQAgAEEANgIIIAEEQCAAQagINgIAQX4MAgsgACgCPCIBIAU2AhwgASAJNgIYIAEgCCgCNDYCgAEgASAILQA4OgCEASABIAw6AKABIAEgCzoAnwEgASAOOgCdASABIA86AJwBIAEgEjYClAEgASATNgKIASABIBBBfyABKAIMIBFGGzYCmAEgACAGNgIACyAUIAdBFGxqKAIICyEHIAhBQGskACAHDwtBuw9B0QlBrA1Bzw8QAAALQfQOQdEJQYsMQZkPEAAAC9YFAQR/IwBB0AJrIgQkACAARSAAIAEQYCIFQX9KckUEQCAAKAIEIQULAkACQCACRQRAQdSTAigCAA0BCwJAAkACQAJAAkACQCADBEAgAAR/IAAoAiwiBkHArwEgBhsFQcCvAQshBgJAAkACQCABBEAgBQ0BQQAhBSAAKAIEQQFHDQILIAQgBjYCMCAEQdAAakGAAkG9rwEgBEEwahBoGgwCCyAFQX9KDQAgACgCBCEFCyAEIAU2AkQgBCAGNgJAIARB0ABqQYACQcqvASAEQUBrEGgaC0HQmgItAAAiBUUNA0HQnAIoAgBBC04NAyADQdCaAhAdDQEgBEHQAGpB0JgCEB0NAQwFC0HQmgItAABFDQFB0JwCKAIAQQtODQELQcSYAigCACEFAkAgAQRAIAEoAjwNAQtBJEElIAUbIQZB0a8BQd6vASAFGyEFQdScAigCACIHQQFGBEAgBEHQmgI2AhQgBCAFNgIQQdCYAkHfrwEgBEEQaiAGEQUADAELIAdBAUgNACAEIAc2AiggBEHQmgI2AiQgBCAFNgIgQdCYAkHkrwEgBEEgaiAGEQUAC0HQmgJBADoAAEHUnAJBADYCACADDQILQdCaAkEAOgAADAMLIAUNAQtB0JwCQdCcAigCAEEBajYCAAtB1JwCQdScAigCAEEBajYCAEHQmgIgAxCtAUHPnAJBADoAAEHQmAIgBEHQAGoQrQFBxJgCIAI2AgBBz5oCQQA6AABB0JwCKAIAQQtGBEBB0JwCAn8gAQRAQQwgASgCPA0BGgtBAEH0rwFBABA4QdCcAigCAEEBags2AgALIAQgBEHMAGo2AgAgA0GdsAEgBBBnQQFHDQAgBCgCTEGRzgBJDQBBkJUCKAIADQILIAFFIAJBf0pyDQAgASABKAI8QQFyNgI8CyAEQdACaiQADwsgAEEAQX9BABDKASAEQdAAakGvsAFBABApQQEQAgALuQEBBH8gACgCACEEAkACfwJAAkAgACgCBCIFRQ0AIAQgBUF/aiIGQQxsaiIHKAIEIAFHDQAgBygCCCACRw0BIAQgBkEMbGoiACAAKgIAuyADoLY4AgAPCyAEDQBBAEEMQYACEBcMAQsgBUGBAUggBWlBAUtyDQEgBEEMIAVBAXQQFwshBCAAIAQ2AgALIAQgACgCBCIFQQxsaiIEIAI2AgggBCABNgIEIAQgA7Y4AgAgACAFQQFqNgIEC44DAgh/BXwgAgRAIAFBf2ohCiABtyACt6MiDUQAAAAAAADwPyANRAAAAAAAAPA/ZBsiESAEoiEOIAAoAgQiByEGA0ACfyAOIA0gCLdEAAAAAAAA4D+gokQAAAAAAADgv6AiD6BELUMc6+I2Gj+gnCIEmUQAAAAAAADgQWMEQCAEqgwBC0GAgICAeAsiC0EBaiEMAn8gDyAOoUQtQxzr4jYav6CbIgSZRAAAAAAAAOBBYwRAIASqDAELQYCAgIB4CyEFRAAAAAAAAAAAIQQgBiEJIAUgDEcEfwNAIAW3IA+hIBGjIAMRCQAiEEQAAAAAAAAAAGIEQCAAQQAgBSAKIAUgAUgbIAVBAEgbIAggEBDLASAEIBCgIQQLIAUgC0YhByAFQQFqIQUgB0UNAAsgACgCBCIHBSAJCyAGRwRAIAAoAgAhCQNAIAkgBkEMbGoiBSAFKgIAuyAEo7Y4AgAgBkEBaiIGIAdHDQALIAchBgsgCEEBaiIIIAJHDQALCyAAIAEgAkQAAAAAAAAAABDLAQvHAgEDfwJAIAAoAgANACAAKAIEDQAgAkEATARAIAEvARIhAgsgACACNgIIIANBAEwEQCABLwEUIQMLIAAgAzYCDCAAQQBBCCACIANsIgMQFyIFNgIAAkACQCABKAIEBEAgASgCACgCAC4BFEF/Sg0BCyABKAIMIgJFDQAgAigCACABLwEQIgRMDQBB8IkCKAIAIgEgAigCECAEQQN0aiICLQABQQF0ai8BACEEIAEgAi0AAkEBdGovAQAhBiABIAItAANBAXRqLwEAIQEgAEH//wE7ARYgACABOwEUIAAgBjsBEiAAIAQ7ARAMAQsgAEIANwMQCwJAIANFDQAgBSAAKQMQNwMAQQEhAiADQQFGDQADQCAAKAIAIAJBA3RqIAApAxA3AwAgAkEBaiICIANHDQALCw8LQdCHAUG0gQFBhgNB7IcBEAAAC04AIAAoApwBBEAgAEGQAWoQ3wELIAAoAhAQFiAAKAIUEBYgACgCMBAWIAAoAjQQFiAAKAJIEBYgACgCTBAWIAAoAoABEBYgACgCiAEQFguPGgMQfwV9A3wjAEHQAGsiBSQAIAAoAgQiCygCACERIAUgC0HMABAYIgJBADYCNCACQgA3AwAgAgJ/IAArA3AiGSALLwEMuKIiF5lEAAAAAAAA4EFjBEAgF6oMAQtBgICAgHgLIgQ7AQwgAgJ/IAArA3giGCALLwEOuKIiF5lEAAAAAAAA4EFjBEAgF6oMAQtBgICAgHgLIgM7AQ4gAgJ/IBkgCy8BDCIKIAsvAQhqt6KbIheZRAAAAAAAAOBBYwRAIBeqDAELQYCAgIB4CyAEayIGOwEIIAICfyAYIAsvAQ4iCSALLwEKareimyIXmUQAAAAAAADgQWMEQCAXqgwBC0GAgICAeAsgA2siBzsBCiAAKAIYIAsvAQggCmpGBEAgAiAALwE4IARrIgY7AQgLIAAoAhwgCy8BCiAJakYEQCACIAAvATwgA2siBzsBCgsCQAJAAkACQCABBEAgBiEFDAELQQAhBQJAIAZB//8DcUUNAAJ/IARB//8DcbhEAAAAAAAA4D+gIAArA2AiGKIiF5lEAAAAAAAA4EFjBEAgF6oMAQtBgICAgHgLIApIBEAgAiAGQX9qIgY7AQggAiAEQQFqIgQ7AQwgBkH//wNxRQ0BCyALLwEIIAsvAQxqAn8gGCAEQf//A3EgBkH//wNxardEAAAAAAAA4L+goiIXmUQAAAAAAADgQWMEQCAXqgwBC0GAgICAeAtKBEAgBiEFDAELIAIgBkF/aiIFOwEICyAHQf//A3FFDQECfyADQf//A3G4RAAAAAAAAOA/oCAAKwNoIhiiIheZRAAAAAAAAOBBYwRAIBeqDAELQYCAgIB4CyAJSARAIAIgB0F/aiIHOwEKIAIgA0EBaiIDOwEOIAdB//8DcUUNAgsgCy8BCiALLwEOagJ/IBggA0H//wNxIAdB//8DcWq3RAAAAAAAAOC/oKIiF5lEAAAAAAAA4EFjBEAgF6oMAQtBgICAgHgLSgRAQQEhBwwBCyACIAdBf2oiBzsBCgsgBUH//wNxRQ0AIAdB//8DcQ0BCyACQYGABDYCCCACQQAQXxogAkEAOwEUIAIoAgRBADoAACACQQE6ABIMAQsgEUUEQCAAKAIAIAsQLxoLQQAhBiACQQAQXxoCQAJAAkACQAJAAkACQAJAIAFBf2oOBgYABQQDAgELIAAoAhghAUEAQRAgAi8BCBAXIQpBAEEIIAFBAXQiBxAXIQkgABCSASACLwEIRQRADAcLQQAhAQNAIAEgAi8BDGoiCEEBaiIDIAAoAjhGIQUgACgCGAJ/IAOyIAArA2C2IhOUIhSNIhKLQwAAAE9dBEAgEqgMAQtBgICAgHgLIAUbIQUCfyAIsiATlCIVi0MAAABPXQRAIBWoDAELQYCAgIB4CyIEQQFqIAUgBCAFRhsiAyAMIARraiIFIAdKBEADQCAJQQggB0EBdCIHEBchCSAFIAdKDQALCyADIARKBEAgFCAVkyETA0AgCSAMQQN0aiIFIAE7AQIgBSAEOwEAIASyIRIgBEEBaiIEsiEWIAUCfSAVIBJeQQFzRQRAIBMgFCAWXQ0BGiASIBWTQwAAgD+SDAELQwAAgD8gFCAWXUEBcw0AGiAUIBKTCzgCBCAMQQFqIQwgAyAERw0ACwsgAUEBaiIBIAIvAQgiBkcNAAsMBgsgACgCBCEKQQAhBCACKAIEIQNBAEECIAIvAQgQFyEJIAIvAQgEQCAAKwNgIRgDQCAJIAZBAXRqAn8gGCAGIAIvAQxqt0QAAAAAAADgP6CiIheZRAAAAAAAAOBBYwRAIBeqDAELQYCAgIB4CyAKLwEMazsBACAGQQFqIgYgAi8BCCIERw0ACwsgAi8BCiIFBEADQCAEQf//A3EhCAJ/IAArA2ggDCACLwEOardEAAAAAAAA4D+goiIXmUQAAAAAAADgQWMEQCAXqgwBC0GAgICAeAshAUEAIQQgCARAIAooAgAgASAKLwEOa0ECdGooAgAhBQNAIAMgBSAJIARBAXRqLwEAai0AADoAACADQQFqIQMgBEEBaiIEIAIvAQgiAUcNAAsgASEEIAIvAQohBQsgDEEBaiIMIAVB//8DcUcNAAsLIAkQFgwGCyAAIAJBHkQAAAAAAAAAQBBxDAULIAAgAkEfRAAAAAAAAAhAEHEMBAsgACACQSBEAAAAAAAAAEAQcQwDCyAAIAJBIUQAAAAAAAAAQBBxDAILQQAhB0EAQQIgACgCGBAXIQxBAEEQIAIvAQgQFyEOQQBBBCACLwEIEBchDyAAEJIBIAIvAQwhCAJAIAIvAQgiAUUEQCAAKAI4IQ0gACgCGCEJIAArA2AiF7YhEkEAIQEgCCEDDAELIAAoAjghDSAAKAIYIQkgACsDYCIXtiESIAghAwNAIAMgB2oiBEEBaiIDIA1GIQUgCQJ/IBIgA7KUIhOLQwAAAE9dBEAgE6gMAQtBgICAgHgLIAUbIQUgBSAFAn8gEiAEspQiE4tDAAAAT10EQCATqAwBC0GAgICAeAsiA0ZqIgUgA0cEQANAIAwgA0EBdGogBzsBACADQQFqIgMgBUcNAAsgAi8BDCEIIAIvAQghAQsgCEH//wNxIQMgB0EBaiIHIAFB//8DcUcNAAsLAn8gEiADIAFB//8DcWoiA7KUIhOLQwAAAE9dBEAgE6gMAQtBgICAgHgLIQcCfyASIANBf2qylCISi0MAAABPXQRAIBKoDAELQYCAgIB4CyEGAn8gFyAIQf//A3G4oiIXmUQAAAAAAADgQWMEQCAXqgwBC0GAgICAeAshBQJAIAIvAQpFDQAgCSAHIAMgDUYbIgMgAyAGRmohCQNAIBAgAi8BDmoiBkEBaiIDIAAoAjxGIQggACgCHAJ/IAOyIAArA2i2IhOUIhKLQwAAAE9dBEAgEqgMAQtBgICAgHgLIAgbIQMgAyADAn8gBrIgE5QiEotDAAAAT10EQCASqAwBC0GAgICAeAsiDUZqIQRBACEDAkAgAUH//wNxRQ0AA0AgDiADQQR0aiIBQgA3AgAgAUIANwIIIANBAWoiAyACLwEIIgFHDQALIAFFDQAgD0EAIANBAnQQGxoLIAQgDUcEQANAIAUgCUcEQCAAKAIQIAAoAhggDWxBBHRqIQYgBSEDA0AgDyAMIANBAXRqIgovAQAiCEECdGoiASABKAIAQQFqNgIAIA4gCEEEdGoiASAGIANBBHRqIggqAgAgASoCAJI4AgAgDiAKLwEAQQR0aiIBIAgqAgQgASoCBJI4AgQgDiAKLwEAQQR0aiIBIAgqAgggASoCCJI4AgggDiAKLwEAQQR0aiIBIAgqAgwgASoCDJI4AgwgA0EBaiIDIAlHDQALCyANQQFqIg0gBEcNAAsLQQAhByACLwEIBEADQCAOIAdBBHRqIgMgAyoCACAPIAdBAnRqIgEoAgCylTgCACADIAMqAgQgASgCALKVOAIEIAMgAyoCCCABKAIAspU4AgggAyADKgIMIAEoAgCylTgCDCAHQQFqIgcgAi8BCEcNAAsLIAAgDiACIBAQkQEgEEEBaiIQIAIvAQpGDQEgAi8BCCEBDAAACwALIAAgAhCQASAMEBYgDhAWIA8QFgwBCwJAIAIvAQpFDQADQCANIAIvAQ5qIgNBAWoiBSAAKAI8RiEBIAAoAhwCfyAFsiAAKwNotiITlCIUjSISi0MAAABPXQRAIBKoDAELQYCAgIB4CyABGyEIAn8gA7IgE5QiFYtDAAAAT10EQCAVqAwBC0GAgICAeAshBUEAIQQgBkH//wNxBEADQCAKIARBBHRqIgFCADcCACABQgA3AgggBEEBaiIEIAIvAQhHDQALCyAFQQFqIAggBSAIRhsiAyAFSgRAIBQgFZMhEwNAIAUiAUEBaiIFsiESAn0gFSABsiIWXkEBc0UEQCATIBQgEl0NARogFiAVk0MAAIA/kgwBC0MAAIA/IBQgEl1BAXMNABogFCAWkwshEiAMBEAgACgCECAAKAIYIAFsQQR0aiEIIAArA3AgEruiIAArA3iitiESQQAhBgNAIAogCSAGQQN0aiIELwECQQR0aiIBIAEqAgAgCCAELwEAQQR0aioCACAEKgIEIBKUlJI4AgAgCiAELwECQQR0aiIBIAEqAgQgCCAELwEAQQR0aioCBCAEKgIEIBKUlJI4AgQgCiAELwECQQR0aiIBIAEqAgggCCAELwEAQQR0aioCCCAEKgIEIBKUlJI4AgggCiAELwECQQR0aiIBIAEqAgwgCCAELwEAQQR0aioCDCAEKgIEIBKUlJI4AgwgBkEBaiIGIAxHDQALCyADIAVHDQALCyAAIAogAiANEJEBIA1BAWoiDSACLwEKRg0BIAIvAQghBgwAAAsACyAAIAIQkAEgChAWIAkQFgsgCxAmIAsQQyALIAJBzAAQGCEBIBFFBEAgACgCACABQZSXAhA2IAEQJgsgAkHQAGokAAvGAwEIfyAAKAIAIQlBAEEBIAAvAQoiBiAALwEIIgVsEBchCCACQX1xQQFGBEACQAJAAkAgAkEBRwRAIAVFDQIgBSEEIAghAwwBCyAFBEAgCCEDA0AgBiICBEADQCADIAkgAkF/aiIEQQJ0aigCACAHai0AADoAACADQQFqIQMgAkEBSiEKIAQhAiAKDQALCyAHQQFqIgcgBUcNAAsLIAAvAQ4hAyABKAIALwEUIQIgACAALwEMOwEOIAAgAiAGayADazsBDCABKAIwIgNFDQIgAygCJCEDIAEoAjghBCABIAEoAjQ2AjggASACIARrIANrNgI0DAILA0AgBCIHQX9qIQRBACECIAYEQANAIAMgCSACQQJ0aigCACAEai0AADoAACADQQFqIQMgAkEBaiICIAZHDQALCyAHQQJODQALCyAALwEMIQMgASgCAC8BEiECIAAgAC8BDjsBDCAAIAIgBWsgA2s7AQ4gASgCMCIDRQ0AIAMoAiAhAyABKAI0IQQgASABKAI4NgI0IAEgAiAEayADazYCOAsgABAmIAAgBTsBCiAAIAY7AQggACAIQQAQQhoPC0GfhAFBtIEBQcsCQb6EARAAAAt6AQN/IAAEQANAIAEoAgwiAgRAIAIgACgCDCAAKAIIEQEACyABKAIEIgNBAU4EQEEAIQIDQCABKAIAIAJBAnRqKAIAKAIYIgQEQCAEIAAoAgwgACgCCBEBACABKAIEIQMLIAJBAWoiAiADSA0ACwsgACgCBCIADQALCwtTAQR/IABFBEBBAA8LIAAhAgNAIAIoAgQhBAJAIAEgAigCCEcEQCACIQMMAQsgBCEFIAMEQCADIAQ2AgQgACEFCyACEBYgBSEACyAEIgINAAsgAAsUACAAIAFBf0EAEJQBIAAgATYCAAutAwEFfwJAIAFBAEgNACAAKAIAIAJMDQAgASACTARAIAIgASACIAFKGyEGA0ACQCAAKAIIIgIgAUHkAGwiB2oiAygCRCIERQ0AIAQoAgAiBUEBSA0AAkAgBUEBRw0AIAMoAghBf0oNACAEKAIIIgIoAjxBf0wEQCACIAMoAgQvARA2AjwLIAIoAkBBf0wEQCACIAMoAgQtABI2AkALQQEhBSACKAIMDQAgAigCEA0AIAMoAgQoAhwQgAEhAiAEKAIIIAI2AgwgBCgCACEFCyAEQQAgBUF/ahDUASAAKAIIIQILIAIgB2oiBSgCCEEBTgRAAkBBoJQCKAIAIgNBqJQCKAIAIgJIBEBBpJQCKAIAIQQMAQsDQEGklAICfyACBEBBqJQCIAJBAXQiAjYCAEGklAIoAgBBBCACEBcMAQtBqJQCQRA2AgBBAEEEQRAQFwsiBDYCAEGglAIoAgAiA0GolAIoAgAiAk4NAAsLQaCUAiADQQFqNgIAIAQgA0ECdGogBTYCAAsgASAGRyECIAFBAWohASACDQALCw8LQdPXAEGwzwBBtAhB79cAEAAACzQBAX9BAEEMQQEQFyIBQQA2AgAgASAAQQAgAEEAShsiADYCBCABQQBB5AAgABAXNgIIIAELwgkDCn8DfQF8IwBB4AhrIgIkAAJAAkACfwJAIAAEQCAAQQAgAEHg0gAQHSIFGyEDIAENAyAFRQ0BIANB4tIAEFkMAgsgAQ0CC0EAIQBBhOgBKAIACyEBQQEhCiABBEAgACEDDAELIAJB3JwCKAIAEFA2AgQgAiAANgIAIABB5dIAIAIQKUEAIQAMAQsgA0HJzAAgAxshBEHwlAIoAgAEQEE8IAQQmAELIAEQTyIAIAEQZgJAIABBxwBGBEBBACEAIAFBAUEAQRwQogEiA0UEQCAEQejSAEEAECkgAxA8DAILAkAgAygCDCIADQAgAygCBARAIAMoAgAoAgAoAhgNAQtBACEAIARB/9IAQQAQKSADEDwMAgsCfyADKAIkBEAgBEGt0wBBABA7IAMoAgwhAAsgAEULBH8gAygCACgCACgCGAUgAAsQeyEAIAMQPAwBC0EAQYACECwiBSgCECELAkAgAkHgAGogARC/AQRAIAJB4ABqQQFyIQZBACEDA0AgAiACQcgAajYCOCACIAJBzABqNgI0IAIgAkHQAGo2AjACQAJAIAJB4ABqQdzWACACQTBqEGdBA0YEQCACKgJQIgxDAAAAAF1BAXNFBEAgAkEANgJQQwAAAAAhDAsgAioCTCINQwAAAABdQQFzRQRAIAJBADYCTEMAAAAAIQ0LIAIqAkgiDkMAAAAAXUEBc0UEQCACQQA2AkhDAAAAACEOCyACAn8gDbtEAAAAAAAA4D+gIg9EAAAAAAAA8EFjIA9EAAAAAAAAAABmcQRAIA+rDAELQQALNgJYIAICfyAMu0QAAAAAAADgP6AiD0QAAAAAAADwQWMgD0QAAAAAAAAAAGZxBEAgD6sMAQtBAAsiADYCXCAOu0QAAAAAAADgP6AiD0QAAAAAAADwQWMgD0QAAAAAAAAAAGZxBEAgAiAPqzYCVAwCCyACQQA2AlQMAQsgAi0AYEEjRw0BAkACQCAGQeXWABCqAUF9ag4EAAMDAQMLIAItAGQiAARAIAAQNUUNAwsgAiACQdQAajYCGCACIAJB2ABqNgIUIAIgAkHcAGo2AhAgBkH81gAgAkEQahBnGiACIAIoAlxBEWwiADYCXCACIAIoAlhBEWw2AlggAiACKAJUQRFsNgJUDAELIAItAGciAARAIAAQNUUNAgsgAiACQdQAajYCKCACIAJB2ABqNgIkIAIgAkHcAGo2AiAgBkGG1wAgAkEgahBnGiACKAJcIQALIABBgAJPBEAgAkH/ATYCXEH/ASEACyACKAJYIgdBgAJPBEAgAkH/ATYCWEH/ASEHCyACKAJUIghBgAJPBEAgAkH/ATYCVEH/ASEICyADQYACTgRAIARBkNcAQQAQKQwECyALIANBA3RqIgkgCDoAAyAJIAc6AAIgCSAAOgABIANBAWohAwsCQCACQeAAakEKEDINAANAIAEQT0EBag4MAQAAAAAAAAAAAAABAAALAAsgAkHgAGogARC/AQ0ACyADDQELQQAhACAEQbfXAEEAECkgBRAzDAELIAUgAzYCACAFIQALIAoEQCABED8LQfCUAigCAEUNAEE+QYDoASgCABAlQdiTAkHYkwIoAgBBAWo2AgALIAJB4AhqJAAgAAvyBAEDfyMAQSBrIgMkAEHkkwJBfzYCAEHgkwJBADYCAEHokwJBADYCAAJAQdyUAigCACIFDQBB4JQCKAIADQBBABCPAUHclAIoAgAhBQsCQCAFRQ0AIAEtAABBI0cEQCACRQ0BIABB0M8AQQAQIiEEDAELIAMgAUEBaiIGNgIcAkAgASwAASIEQVBqQQlNBEBB4JMCIAYgA0EcakEKECQiATYCAEHkkwIgATYCAAwBCyAEQS1HDQAgASwAAkFQakEJSw0AQeCTAiAFKAIEIAYgA0EcakEKECRqIgE2AgBB5JMCIAE2AgALAkAgAygCHCIBLQAAQS1HDQBBAEHkkwIoAgBBf0wgASwAASIEGw0AIAMgAUEBaiIFNgIcIARBUGpBCU0EQEHkkwIgBSADQRxqQQoQJDYCAAwBCwJAIARBLUcNACABLAACQVBqQQlLDQBB5JMCQdyUAigCACgCBCAFIANBHGpBChAkajYCAAwBC0HkkwJB3JQCKAIAKAIEQX9qNgIACyADKAIcLQAABEBB3JQCKAIAIAYQ/gEiAQRAQeiTAiAGNgIAQeCTAkHclAIoAgAgARBgIgA2AgBB5JMCIAA2AgBBASEEDAILIAJBAEgEQEGffyEEDAILIAJFBEBBACEEDAILIAMgBjYCECAAQffPACADQRBqECIhBAwBCwJAQeCTAigCACIBQQBIDQBB5JMCKAIAIgVB3JQCKAIAKAIEIgROIAEgBE5yDQBBASEEIAVBf0oNAQtBACEEIAJFDQBB3JQCKAIAKAIEIQEgAyAGNgIAIAMgATYCBCAAQY7QACADECIhBAsgA0EgaiQAIAQLkgQBBH8jAEHwAGsiBSQAIAIoAhAhBiACKAIMIQcgBSADNgJgIABBx9UAIAVB4ABqECECQCACKAIAIgNB/wFGBEBB2NUAQQVBASAAECMaIAIoAgQgAigCCCAAEJcBQScgABAlDAELIANBYGpB3gBNBEAgBSADNgJEIAUgAzYCQCAAQd7VACAFQUBrECEMAQsgBSADNgJQIABB7NUAIAVB0ABqECELAkAgASgCBCAETARAQfPVAEEHQQEgABAjGgwBCyAFIAQ2AjAgAEH71QAgBUEwahAhCyACKAIUBEBBh9YAQQtBASAAECMaC0EKIAAQJSAGBEBBACEEA0AgBSAENgIgIABBk9YAIAVBIGoQISAGQRAgBkEQSRshA0EAIQIDQCAHIAIiAWotAAAhAgJAIAFBAXIiCCADTwRAIAUgAjYCECAAQZ7WACAFQRBqECEMAQsgBSAHIAhqLQAANgIEIAUgAjYCACAAQabWACAFECELIAFBAmoiAiADSQ0ACyABQQ5JBEADQEGw1gBBBUEBIAAQIxogAkEOSSEBIAJBAmohAiABDQALC0EgIAAQJSADQQEgA0EBSxshAUEAIQIDQCAHLQAAIghBLiAIQWBqQf8BcUHfAEkbQf8BcSAAECUgB0EBaiEHIAJBAWoiAiABRw0AC0EKIAAQJSADIARqIQQgBiADayIGDQALCyAFQfAAaiQAC9QDAQh/IwBBQGoiAyQAIAEoAgAiBEF/akEEbSEGIARBfk4EQCAGQQFqIQlBACEEIAZBACAGQQBKGyEKA0AgAiAAEFIaAkAgBCIGIAEoAgBODQAgASgCECAGQQN0aiIELQABIQUgBC0AAiEHIAMgBC0AAzYCPCADIAc2AjggAyAFNgI0IAMgBjYCMCAAQZDVACADQTBqECEgBiAJaiIEIAEoAgBODQBBi9UAQQRBASAAECMaIAEoAhAgBEEDdGoiBS0AASEHIAUtAAIhCCADIAUtAAM2AiwgAyAINgIoIAMgBzYCJCADIAQ2AiAgAEGQ1QAgA0EgahAhIAQgCWoiBCABKAIATg0AQYvVAEEEQQEgABAjGiABKAIQIARBA3RqIgUtAAEhByAFLQACIQggAyAFLQADNgIcIAMgCDYCGCADIAc2AhQgAyAENgIQIABBkNUAIANBEGoQISAEIAlqIgQgASgCAE4NAEGL1QBBBEEBIAAQIxogASgCECAEQQN0aiIFLQABIQcgBS0AAiEIIAMgBS0AAzYCDCADIAg2AgggAyAHNgIEIAMgBDYCACAAQZDVACADECELQQogABAlIAZBAWohBCAGIApHDQALCyADQUBrJAAL5xsBEH8jAEGgAmsiCSQAIAAoAjwhFCAJIAlBnAJqNgIYIAkgCUEcaiIONgIQIAkgDjYCFCAJIAc2AgwCQCAARQ0AIAAoAjwoAowBIgpFDQAgCi0AAEUNACAOIQ8gCQJ/IAoQHCIMQYECTgRAQYACIQcDQCAHQQF0IgcgDEkNAAsgCSAHEBoiDzYCECAPRQRAIAlBADYCGEEADAILIAkgDzYCFCAJIAcgD2o2AhgLIA8gCiAMEBgaIAkoAhghDSAJKAIUIAxqCyIHNgIUIA0gB2tBAUwEQCAHRQ0BIAcgCSgCECILayIKQQJqIQwgDSALayEHA0AgB0EBdCIHIAxJDQALAkACQCALIA5GBEAgCSAHEBoiCDYCECAIRQ0BIAggDiAKEBgaDAILIAkgCyAHEB4iCDYCECAIDQELIAlCADcCFAwCCyAJIAcgCGo2AhggCSAIIApqIgc2AhQLIAdBusAAOwAAIAkgCSgCFEECajYCFAsgACAJQRBqIAYgCSgCDBCTAUEAIQcCQCAJKAIYIgwgCSgCFCIIa0EATARAIAhFDQEgCCAJKAIQIgtrIgpBAWohBiAMIAtrIQcDQCAHQQF0IgcgBkkNAAsCQAJAIAsgDkYEQCAJIAcQGiIINgIQIAhFDQEgCCAOIAoQGBoMAgsgCSALIAcQHiIINgIQIAgNAQsgCUIANwIUQQAhBwwCCyAJIAcgCGo2AhggCSAIIApqIgg2AhQLIAhBCjoAACAJIAkoAhRBAWoiBzYCFAsCQCAAKAI8KAKMASILRQ0AIAstAABFDQACQCAJKAIYIg0gB2sgCxAcIgpIBEAgB0UNASAHIAkoAhAiCGshDCAHIApqIAhrIQYgDSAIayEHA0AgB0EBdCIHIAZJDQALAkACQCAIIA5GBEAgCSAHEBoiCDYCECAIRQ0BIAggDiAMEBgaDAILIAkgCCAHEB4iCDYCECAIDQELIAlCADcCFEEAIQdBACENDAILIAkgByAIajYCGCAJIAggDGoiBzYCFAsgByALIAoQGBogCSAJKAIUIApqIgc2AhQgCSgCGCENCyANIAdrQQFMBEAgB0UNASAHIAkoAhAiCmshDCAHIAprQQJqIQYgDSAKayEHA0AgB0EBdCIHIAZJDQALAkACQCAKIA5GBEAgCSAHEBoiCDYCECAIRQ0BIAggDiAMEBgaDAILIAkgCiAHEB4iCDYCECAIDQELIAlCADcCFEEAIQcMAgsgCSAHIAhqNgIYIAkgCCAMaiIHNgIUCyAHQbrAADsAACAJIAkoAhRBAmoiBzYCFAsCQCAJKAIYIgwgB2tBEUwEQCAHRQ0BIAcgCSgCECILayEKIAcgC2tBEmohBiAMIAtrIQcDQCAHQQF0IgcgBkkNAAsCQAJAIAsgDkYEQCAJIAcQGiIINgIQIAhFDQEgCCAOIAoQGBoMAgsgCSALIAcQHiIINgIQIAgNAQsgCUIANwIUQQAhBwwCCyAJIAcgCGo2AhggCSAIIApqIgc2AhQLIAdBoRAvAAA7ABAgB0GZECkAADcACCAHQZEQKQAANwAAIAkgCSgCFEESaiIHNgIUCwJAIAFBAU4EQEEFQQYgAUF/aiIVQQFGIgYbIRNBpBBBqhAgBhshFiABQQQgFUEDSRshFyAHIgwiCiILIg0hCANAIAIgEkECdGooAgAhEQJAIAkCfwJAAkACQCASRQRAIAkoAhgiDyAIa0EASg0DIA1FDQUgDSAJKAIQIgprIQwgCCAKa0EBaiEGIA8gCmshBwNAIAdBAXQiByAGSQ0ACyAKIA5GBEAgCSAHEBoiCDYCECAIRQ0CIAggDiAMEBgaDAMLIAkgCiAHEB4iCDYCECAIDQIMAQsgCSgCGCIPIAhrIQYgEiAVRgRAIAYgE0gEQCANRQ0GIA0gCSgCECIKayEMIAggE2ogCmshBiAPIAprIQcDQCAHQQF0IgcgBkkNAAsCQCAKIA5GBEAgCSAHEBoiCDYCECAIRQ0EIAggDiAMEBgaDAELIAkgCiAHEB4iCDYCECAIRQ0DCyAJIAcgCGo2AhggCSAIIAxqIgg2AhQLIAggFiATEBgaIAkoAhQgE2oMBAsgBkEBTARAIA1FDQUgDSAJKAIQIgprIQwgCCAKa0ECaiEGIA8gCmshBwNAIAdBAXQiByAGSQ0ACwJAIAogDkYEQCAJIAcQGiIINgIQIAhFDQMgCCAOIAwQGBoMAQsgCSAKIAcQHiIINgIQIAhFDQILIAkgByAIajYCGCAJIAggDGoiCDYCFAsgCEGswAA7AAAgCSgCFEECagwDCyAJQgA3AhRBACEHQQAhDEEAIQpBACELQQAhDUEAIQgMAwsgCSAHIAhqNgIYIAkgCCAMaiIINgIUCyAIQSA6AAAgCSgCFEEBagsiBzYCFCAHIgwiCiILIg0hCAsCQCAJKAIYIgYgCGtBA0EBIBQoAnwiDxsiEEgEQCANRQ0BIA0gCSgCECILayEKIAggEGogC2shDCAGIAtrIQcDQCAHQQF0IgcgDEkNAAsCQAJAIAsgDkYEQCAJIAcQGiIINgIQIAhFDQEgCCAOIAoQGBoMAgsgCSALIAcQHiIINgIQIAgNAQsgCUIANwIUQQAhB0EAIQxBACEKQQAhC0EAIQ1BACEIQQAhBgwCCyAJIAcgCGo2AhggCSAIIApqIgg2AhQLIAhB+A9B/A8gDxsgEBAYGiAJIAkoAhQgEGoiBzYCFCAJKAIYIQYgByIMIgoiCyINIQgLIBFBH3UhDwJAIAYgCGsgBRAcIhBIBEAgDUUNASANIAkoAhAiC2shCiAIIBBqIAtrIQwgBiALayEHA0AgB0EBdCIHIAxJDQALAkACQCALIA5GBEAgCSAHEBoiCDYCECAIRQ0BIAggDiAKEBgaDAILIAkgCyAHEB4iCDYCECAIDQELIAlCADcCFEEAIQdBACEMQQAhCkEAIQtBACENQQAhCEEAIQYMAgsgCSAHIAhqNgIYIAkgCCAKaiIINgIUCyAIIAUgEBAYGiAJIAkoAhQgEGoiBzYCFCAJKAIYIQYgByIMIgoiCyINIQgLIA8gEXMhEAJ/IAYgCGsgD0EDcSIPSARAIAggDUUNARogDSAJKAIQIgtrIQogCCAPaiALayEMIAYgC2shBwNAIAdBAXQiByAMSQ0ACwJAAkAgCyAORgRAIAkgBxAaIgg2AhAgCEUNASAIIA4gChAYGgwCCyAJIAsgBxAeIgg2AhAgCA0BCyAJQgA3AhRBACEHQQAhDEEAIQpBACELQQAhDUEAIQZBAAwCCyAJIAcgCGo2AhggCSAIIApqIgg2AhQLIAhBmglBpwsgEUEASBsgDxAYGiAJIAkoAhQgD2oiBzYCFCAJKAIYIQYgByIMIgoiCyINCyEPAkAgBiAPayADIBBBFGxqKAIAIAQgEEEMbGotAAJqIhAQHCIRSARAIA1FBEAgDSEIDAILIA0gCSgCECILayEKIA8gEWogC2shDCAGIAtrIQcDQCAHQQF0IgcgDEkNAAsCQAJAIAsgDkYEQCAJIAcQGiIINgIQIAhFDQEgCCAOIAoQGBoMAgsgCSALIAcQHiIINgIQIAgNAQsgCUIANwIUQQAhB0EAIQxBACEKQQAhC0EAIQhBACEPQQAhBgwCCyAJIAcgCGo2AhggCSAIIApqIg82AhQLIA8gECAREBgaIAkgCSgCFCARaiIHNgIUIAkoAhghBiAHIgwiCiILIgghDwsCQCAGIA9rQQNBASAUKAJ8Ig0bIhBIBEAgCEUEQEEAIQ0MAgsgCCAJKAIQIgtrIQogDyAQaiALayEMIAYgC2shBwNAIAdBAXQiByAMSQ0ACwJAAkAgCyAORgRAIAkgBxAaIgg2AhAgCEUNASAIIA4gChAYGgwCCyAJIAsgBxAeIgg2AhAgCA0BCyAJQgA3AhRBACEHQQAhDEEAIQpBACELQQAhDUEAIQgMAgsgCSAHIAhqNgIYIAkgCCAKaiIPNgIUCyAPQf4PQfwPIA0bIBAQGBogCSAJKAIUIBBqIgc2AhQgByIMIgoiCyINIQgLIBJBAWoiEiAXRw0ACyABQQVIDQEgCSgCGCICIAtrQQtMBEAgCkUNAiAKIAkoAhAiBGshAyALIARrQQxqIQEgAiAEayEHA0AgB0EBdCIHIAFJDQALAkACQCAEIA5GBEAgCSAHEBoiCDYCECAIRQ0BIAggDiADEBgaDAILIAkgBCAHEB4iCDYCECAIDQELIAlCADcCFEEAIQdBACEMDAMLIAkgByAIajYCGCAJIAMgCGoiCzYCFAsgC0G5ECgAADYACCALQbEQKQAANwAAIAkgCSgCFEEMaiIHNgIUCyAHIQwLAkAgCQJ/IAkoAhgiAiAMa0ECTARAIAdFDQIgByAJKAIQIgRrIQMgDCAEa0EDaiEBIAIgBGshBwNAIAdBAXQiByABSQ0ACwJAAkAgBCAORgRAIAkgBxAaIgg2AhAgCEUNASAIIA4gAxAYGgwCCyAJIAQgBxAeIgg2AhAgCA0BCyAJQQA2AhhBAAwCCyAJIAcgCGo2AhggCSADIAhqIgw2AhQLIAxBwBAtAAA6AAIgDEG+EC8AADsAACAJKAIUQQNqCzYCFAsCf0GCECAJKAIUIgFFDQAaIAFBADoAACAJKAIQCyEHAkAgACgCPCgCkAEiAQRAIAAgByABEQEADAELIAdBgOgBKAIAEFIaCyAOIAkoAhAiAEcEQCAAEBYLIAlBoAJqJAAL3gECA38CfEEAQQEgASACbCIGQQRqEBciBSADOgADIAUgAjoAASAFIAE6AAACQCAGQYACTgRAIAVB/wE6AAJEAAAAAADgb0AgBrejIQcDQCAAIARBGGxqIgIoAgAgAigCBCABbGogBWoCfyAHIAS3oiIImUQAAAAAAADgQWMEQCAIqgwBC0GAgICAeAs6AAQgBEEBaiIEIAZHDQALDAELIAUgBjoAAiAGRQ0AA0AgACAEQRhsaiICKAIAIAIoAgQgAWxqIAVqIAQ6AAQgBEEBaiIEIAZHDQALCyAAEBYgBQuUEAIgfxN8IwBB0AhrIgYkACADLQADIQUgAy0AAiEHIAZB8IkCKAIAIgggAy0AAUEBdGovAQA7AQggBiAIIAdBAXRqLwEAOwEKIAYgCCAFQQF0ai8BADsBDCAEKAIcIgcEQCAGQQhqIAcRBAALIAEEQCAGLgEMIRIgBi8BCiELIAYuAQghDEEAIQVBACEHQQAhCANAIAYgCSASQRB0QRB1aiIKQf//ASAKQf//AUgbIgpBACAKQQBKGzsBBCAGIAUgC0EQdEEQdWoiCkH//wEgCkH//wFIGyIKQQAgCkEAShs7AQIgBiAHIAxBEHRBEHVqIgpB//8BIApB//8BSBsiCkEAIApBAEobOwEAIAAgCGogBCAGQQAQVSIKOgAAIAYuAQwiEiAEKAIMIApB/wFxQQZsaiIKLgEEayAJaiEJIAYuAQoiCyAKLgECayAFaiEFIAYuAQgiDCAKLgEAayAHaiEHIAhBAWoiCCABRw0ACwsgACABQQFBFxA5AkACQCACIAFODQAgAC0AACIIIAAgAWpBf2otAABGDQBBASEFIAFBAUcEQCAIIQdBASEJA0AgBSAHQf8BcSAAIAlqLQAAIgdHaiEFIAlBAWoiCSABRw0ACwsgBSACTA0AIAZBATsBUiAGIAg6AFBBASELAn8CQCABQQFGDQBBASEJA0ACQCAIQf8BcSAAIAlqLQAAIghGBEAgC0ECdCAGaiIHQc4AaiAHLwFOQQFqOwEADAELIAZB0ABqIAtBAnRqIgdBATsBAiAHIAg6AAAgC0EBaiELCyAJQQFqIgkgAUcNAAsgCw0AQQAMAQsgBCgCDCEXQX8hCCAGLgEMIRggBi4BCiEZIAYuAQghGiACQRAgAkEQSBsiI0EDSCESQQAhDANAIBcgBkHQAGogDEECdGotAAAiBEEGbGoiBy4BAiITIBlrIgIgAmwgBy4BACIUIBprIgIgAmxqIAcuAQQiFSAYayICIAJsaiICIAggAiAISSICGyEIQQEgECACGyEQIAQgFiACGyEWQYCAfiARIAIbIREgI0ECSCAMQQFqIgwgC05yRQRAIBggFWsiG7chMiAZIBNrIhy3ITMgGiAUayIdtyErIAwhBwNAAkAgFyAGQdAAaiAHQQJ0ai0AACICQQZsaiIFLgECIBNrIg0gDWwgBS4BACAUayIPIA9saiAFLgEEIBVrIg4gDmxqIgVFDQAgKyAPtyIloiANIBxst6AgDiAbbLegIAW4oyImRAAAAAAAAAAAYyAmRAAAAAAAAPA/ZHINAAJ/ICYgJaIiJZlEAAAAAAAA4EFjBEAgJaoMAQtBgICAgHgLIBRqIgVB//8BIAVB//8BSBsiBUEAIAVBAEobIBprIgUgBWwCfyAmIA23oiIlmUQAAAAAAADgQWMEQCAlqgwBC0GAgICAeAsgE2oiBUH//wEgBUH//wFIGyIFQQAgBUEAShsgGWsiBSAFbGohCSAJAn8gJiAOt6IiJZlEAAAAAAAA4EFjBEAgJaoMAQtBgICAgHgLIBVqIgVB//8BIAVB//8BSBsiBUEAIAVBAEobIBhrIgUgBWxqIgUgCE8NAEGAgH4CfyAmRAAAAAAAAOBAoiIlmUQAAAAAAADgQWMEQCAlqgwBC0GAgICAeAsiHmshEUECIRAgAiEfIAQhFiAFIQgLIBIgB0EBaiIHIAtOckUEQCANIB1sIA8gHGxrtyEsIA8gG2wgDiAdbGu3IS0gDiAcbCANIBtsa7chLiAOtyE0IA23ITUgD7chNiAHIQkDQAJAIBcgBkHQAGogCUECdGotAAAiCkEGbGoiBS4BAiATayIgtyIvIAUuAQQgFWsiISANbCAOICBsa7ciKKIgBS4BACAUayIFtyIwIAUgDmwgDyAhbGu3IimioSI3IDSiICG3IjEgKaIgLyAPICBsIAUgDWxrtyIqoqEiJyA2oiAwICqiIDEgKKKhIiYgNaKgoCIlmUQAAAAAAAAgP2UNACA3IDKiICcgK6IgJiAzoqCgRAAAAAAAAPA/ICWjIiWiIidEAAAAAAAAAABjICdEAAAAAAAA8D9kcg0AICwgKqIgLiAooiAtICmioKAgJaIiJkQAAAAAAAAAAGMgJkQAAAAAAADwP2RyICcgJqBEAAAAAAAA8D9kcg0AIAgCfyAqICqiICggKKIgKSApoqCgICwgMaIgLiAwoiAtIC+ioKAgJaIiJSAloqJEAAAAAAAA4D+gIiVEAAAAAAAA8EFjICVEAAAAAAAAAABmcQRAICWrDAELQQALIgVNDQACfyAmRAAAAAAAAOBAoiIlmUQAAAAAAADgQWMEQCAlqgwBC0GAgICAeAshIkGAgAIgIgJ/ICdEAAAAAAAA4ECiIiWZRAAAAAAAAOBBYwRAICWqDAELQYCAgIB4CyIeamshEUEDIRAgCiEkIAIhHyAEIRYgBSEICyAJQQFqIgkgC0gNAAsLIAcgC0cNAAsLIAsgDEcNAAsgBiAiOwEaIAYgJDoAGCAGIB47ARYgBiAfOgAUIAYgETsBEiAGIBY6ABBBACIJIBBFDQAaQQAhBUEAIQgDfwJAIAUgCCARQf//A3FqIgggAWxBgIACbSIHRgRAIAUhBwwBCyAAIAVqIAZBEGogCUECdGotAAAgByAFaxAbGgsgECAJQQFqIglGBH8gBwUgBkEQaiAJQQJ0ai8BAiERIAchBQwBCwsLIAFHDQELIANBAToAACAGQdAIaiQADwtB2McAQbAiQbgJQenHABAAAAusGQEVfyMAQbAIayIFJAAgASgCACEEIAEoAhAhAgJAIAEoAgRB/wFKBEAgAiEQDAELQQBBCEGAAhAXIhAgAiAEQQN0EBghBiACEBYgAUGAAjYCBCABIAY2AhALQQAhAgNAIBAgAkEDdGpBADYCBCACQQFqIgJBgAJHDQALAkAgASgCACIGQQFIBEBBFSEJDAELA0AgECADQQN0aiICLQABIg0gAi0AAkcNASANIAItAANHDQEgA0EBaiIDIAZHDQALQRUhCQsgBUEANgKICEEAQQZBgAIQFyECIAVBADYCqAggBSAJNgKkCCAFQoCAgICAIDcDmAggBSACNgKUCCAFQX82ApAIAkAgASgCAEEBSA0AQQAhAgNAIAEoAhAgAkEDdGoiBi0AAyENIAYtAAIhCCAFQfCJAigCACIDIAYtAAFBAXRqLwEAOwEAIAUgAyAIQQF0ai8BADsBAiAFIAMgDUEBdGovAQA7AQQgCQRAIAUgCREEAAsCQCAFKAKYCCIJIAUoApwIRwRAIAUoApQIIQMMAQsgBSAJQQF0IgY2ApwIIAUgBSgClAhBBiAGEBciAzYClAggBSgCmAghCQsgAyAJQQZsaiIGIAUoAgA2AQAgBiAFLwEEOwEEIAUgBSgCmAhBAWo2ApgIIAUoAogIIgYEQCAGEBYgBSgCqAgQFiAFQQA2AqgIIAVBADYCiAgLIAJBAWoiAiABKAIATg0BIAUoAqQIIQkMAAALAAsgBUGICGoQc0EBIRQgACgCBCICQQFOBEADQAJAAkAgACgCACAVQQJ0aigCACIIKAIYIgsNACAAKAIMIgsNAEEAIRQMAQsgCCgCACEWQQBBASAILwEKIAgvAQhsEBchDSABEKABIAsQoAEgFkUEQCAAIAgQLxoLQX8hBwJAAkADQCAFIAc2ApAIIAVBAEGACBAbIQoCQAJAAkACQAJAAkBBxJUCKAIAQX9qDgQAAAEBAgsgCCANIAsgCkGICGogChDsAgwEC0HIlQIoAgAiDC0AASEOIAwtAAAhBkEAQQEgDC0AAiIPIAsoAgBsEBchESALKAIAIgMEQCALKAIQIQdBACECA0AgByACQQN0akEAOgAAIAJBAWoiAiADRw0ACwtBzJMCQQBBBCAKKAKYCBAXIgc2AgAgCigCmAgEQEEAIQIgCigClAghCQNAIAcgAkECdGogCSACQQZsaiIDLgECQbcBbCADLgEAQTdsaiADLgEEQRNsakEIdTYCACACQQFqIgIgCigCmAhHDQALCyAPQX9qIA9xIAZBf2ogBnEgDkF/aiAOcXJyDQEgDC0AACEDQQAhAgNAIAIiBkEBaiECQQEgBnQgA0cNAAsgDC0AAiEPQQAhAgNAIAIiA0EBaiECQQEgA3QgD0cNAAsgCC8BCiICRQ0CIAgvAQghB0EAIQkDQAJAIAdB//8DcSIOBEAgDSAJIA5saiESIAgoAgAgCUECdGooAgAhE0EAIQIDQCACIBNqLQAAIg4gCC4BFEcEQCARIA4gA3RqIQcgCygCECAOQQN0aiIOLQAARQRAIAcgDyAMLQADIA4gCkGICGoQ3AELIAIgEmogByAMLQAAQf////8HaiACIAgvAQxqcSAMLQABQf////8HaiAJIAgvAQ5qcSAGdGogDGotAARqLQAAIgc6AAAgCiAHQQJ0aiIHIAcoAgBBAWo2AgAgCC8BCCEHCyACQQFqIgIgB0H//wNxRw0ACyAILwEKIQIMAQtBACEHCyAJQQFqIgkgAkH//wNxRw0ACwwCCyAIIA0gCyAKQYgIaiAKEO0CDAILIAgvAQoiA0UNAEEAIQkgCC8BCCIHIQIDQAJ/IAJB//8DcSICBEAgDSACIAlsaiESIAgoAgAgCUECdGooAgAhE0EAIQIDQCACIBNqLQAAIgMgCC4BFEcEQCARIAMgD2xqIQcgCygCECADQQN0aiIDLQAARQRAIAcgDyAMLQADIAMgCkGICGoQ3AELIAIgEmogByAJIAgvAQ5qIA5wIAZsIAIgCC8BDGogBnBqIAxqLQAEai0AACIDOgAAIAogA0ECdGoiAyADKAIAQQFqNgIAIAgvAQghBwsgAkEBaiICIAdB//8DcUcNAAsgCC8BCiEDIAcMAQtBAAshAiAJQQFqIgkgA0H//wNxRw0ACwtBzJMCKAIAEBYgERAWCwJAAkACQCAILgEUIgxBAEgEQCAEIQYMAQsgCygCECAMQQN0aiICKAIEIQ8gAi0AAyEGIAItAAIhAyACLQABIQcgAi0AACEOQQAhAgJAIARBAU4EQANAAkAgCiACQQJ0aigCAA0AIAcgASgCECACQQN0aiIJLQABRw0AIAMgCS0AAkcNACAGIAktAANHDQAgBCEGIAIhBAwDCyACQQFqIgIgBEcNAAtBACECA0AgCiACQQJ0aigCAEUEQCAEIQYgAiEEDAMLIAJBAWoiAiAERw0ACyAEQf8BSg0ECyAEIAEoAgRODQIgASgCECAEQQN0aiICIA82AgQgAiAGOgADIAIgAzoAAiACIAc6AAEgAiAOOgAAIARBAWohBgsgCC8BCiIHBEBBACEJIAgvAQgiCyECIA0hAwNAIAJB//8DcQR/IAgoAgAgCUECdGooAgAhAkEAIQcDQCAMIAItAABGBEAgAyAEOgAAIAgvAQghCwsgA0EBaiEDIAJBAWohAiAHQQFqIgcgC0kNAAsgCC8BCiEHIAsFQQALIQIgCUEBaiIJIAdB//8DcUkNAAsLIAggBDsBFAsgCBAmIAgQQ0EAIQIgCCANQQAQQhoDQCAQIAJBA3RqIgQgBCgCBCAKIAJBAnRqKAIAajYCBCACQQFqIgJBgAJHDQALIAguARQiBEEATgRAIBAgBEH//wNxQQN0aiIEIAQoAgQgCC8BCiAILwEIbEEDdmo2AgQLIAgoAhgiBARAIAQQMyAIQQA2AhgLIBZFBEAgACAIQZSXAhA2IAgQJgsgBiEEDAULQfnHAEGwIkH8C0GWyAAQAAALIARBgAJHDQFBACECQX8hB0F/IQMDQCAKIAJBAnRqKAIAIgYgAyAGIANJIgYbIQMgAiAHIAYbIQcgAkEBaiICQYACRw0ACyAKKAKYCCAHTQ0CIAooApAIIgJBAEggAiAHRnINAAtB/MgAQeXIAEHNAUHwyAAQAAALQa7IAEGwIkGFDEGWyAAQAAALQb/IAEHlyABBzAFB8MgAEAAACyAVQQFqIhUgACgCBCICSA0ACwsgASAENgIAAkACQCACBEAgACgCACgCAC4BFEF/Sg0BCyAAKAIMIgRFDQAgBCgCACAALwEQIgZMDQAgBCgCECAGQQN0aiIELQADIQYgBC0AAiEDIAVB8IkCKAIAIgIgBC0AAUEBdGovAQA7AQAgBSACIANBAXRqLwEAOwECIAUgAiAGQQF0ai8BADsBBCAFKAKkCCIEBEAgBSAEEQQACyAAIAVBiAhqIAVBABBVIgQ7ARAgECAEQf//A3FBA3RqIgQgBCgCBEEBajYCBAwBCwJAIAJBAUgNACAAKAIAKAIALgEUIgRBAEgNACAAIAQ7ARAMAQsgAEEAOwEQCyAAKAIMEDMgBSgCiAgQFiAFKAKUCBAWIAUoAqgIEBYgACABEHsiBjYCDCABKAIAIgRBAU4EQCAGKAIQIQNBACECA0AgAyACQQN0akEAOgAAIAJBAWoiAiAERw0ACwsCQCAURQ0AQQAhAiAEQX9qIgNBACADQQBKGyEDA0AgAiADRg0BIBAgAkEDdGooAgQiDQRAIA0gECACQQFqIgJBA3RqKAIETw0BCwsgBigCECEGIARBAU4EQEEAIQIDQCAGIAJBA3RqIAI6AAAgAkEBaiICIARHDQALCyAGIARBCEEWEDlBACECAkAgASgCACIBQQBMDQADQCAFIAYgAkEDdGotAABBAnRqIAI2AgAgAkEBaiICIAFHDQALQQAhAiABQQBMDQADQCAGIAJBA3RqKAIERQRAIAAoAgwgAjYCAAwCCyACQQFqIgIgAUcNAAsLIAAoAgwoAgAgAC8BECIBSgRAIAAgBSABQQJ0aigCADsBEAsgACgCBEEBSA0AQQAhBwNAIAAoAgAgB0ECdGooAgAiASgCACIERQRAIAAgARAvGgsgAS8BCiABLwEIbCIJBEAgASgCBCECA0AgAiAFIAItAABBAnRqKAIAOgAAIAJBAWohAiAJQX9qIgkNAAsLIAEuARQiAkEATgRAIAEgBSACQf//A3FBAnRqKAIAOwEUCyAERQRAIAAgAUGUlwIQNiABECYLIAdBAWoiByAAKAIESA0ACwsgBUGwCGokAAusBAEIfwN/IANBA28hCUHEkwIoAgAiBygCGCADSARAIAcgAzYCGAsgBygCBCIEIAJMBEAgBygCACEGA0AgByAEQQF0IgU2AgQgByAGQQggBRAXIgY2AgAgBygCBCIEIAJMDQALCyABQQFMBH9BfyEEIAEEQCAAKAIAIQQLIAcoAgAgAkEDdGoiAEF/NgIEIAAgBDYCACAKQQJqBSAAIAFBBCAJQQJ0QczHAGooAgAQOSABQQF2IgUhCAJ/AkACQANAIAgiBEEBTgRAIAlBAXQiCCAHKAIMIgYgACAEQQJ0aigCAEEGbGpqLwEAIAggBiAAIARBf2oiCEECdGooAgBBBmxqai8BAEYNAQwCCwsgBygCDCEGAkAgBSABQX9qIgRODQADQCAJQQF0IgsgBiAAIAVBAnRqIggoAgBBBmxqai8BACAGIAhBfGooAgBBBmxqIAtqLwEARw0BIAVBAWoiBSAERw0ACyAEIQULIAVFDQEgBSEECyAJQQF0IgggBiAAIARBAnRqIgUoAgBBBmxqai4BACAGIAVBfGooAgBBBmxqIAhqLgEAIgVrQQF1IAVqDAELQQAhBCAGIAAoAgBBBmxqIAlBAXRqLgEACyEGIAJBA3QiBSAHKAIAaiAGNgIAIAAgBCACQQFqIgIgA0EBaiIDEN4BIQggBygCACAFaiAIQQFqIgU2AgQgAiAIaiECIAUgCmohCiABIARrIQEgACAEQQJ0aiEADAELCwsXACAAKAIAEBYgACgCDBAWIAAoAiAQFgv/CgMLfwF9AXwjAEEgayIFJAAgASgCHCIDQYACECwhDCADQX5qQf8BSQRAAkAgAyAAKAIEIgRMDQAgASgCIA0AIAUgBDYCAEEBQZfHACAFEBkgACgCBCEECyAEIAMgAyAEShsiB0EDSCAEIANMciAEQYkCSnJFBEAgByABKAIoQQBHayEHCyAFQQhqIAAgASgCLEEARxCdASAHQQFOBEADQAJAIAhBACAIQQFxIAhBCklyG0UEQCAFKAIIKAIEIgRFBEBBACEDDAILQQAhAyAFKAIQIQYDQCAGIANBAnRqKAIADQIgA0EBaiIDIARHDQALIAQhAwwBCwJAIAEoAixFBEAgBSgCCCgCBCIGRQRAQQAhAwwCC0EAIQMgBSgCECEEA0AgBCADQQJ0aigCAA0CIANBAWoiAyAGRw0ACyAGIQMMAgsgBUEIaiAIQX9qt0QAAAAAAAAIQKNEAAAAAAAA8D+gRAAAAAAAAADAohC7AkSamZmZmZmpP6AQnAEhAwwBCyADIAZGBEAgBiEDDAELIANBAWoiBCAGRg0AIAUoAhAhCQNAIAQgAyAJIARBAnRqKAIAIAkgA0ECdGooAgBLGyEDIARBAWoiBCAGRw0ACwsgBUEIaiADIAEoAixBAEcgCEF/akE/SXEQmgEgCEEBaiIIIAdHDQALCwJAIAJBACAHQQNKG0UEQCAFKAIcIQYMAQsgBSgCCCIBKAIAIQtBACEDQQBBBCABKAIEIgkQFyEIQQBBECAFKAIcIgYQFyEHIAYEQCAHQQAgBkEEdBAbGiAFKAIYIQEDQCAIIAEgA0ECdGooAgBBAnRqIAM2AgAgA0EBaiIDIAZHDQALCyAJBEBBACEEIAUoAgwhAwNAIAcgCCADIARBAnRqKAIAIgpBAnRqKAIAQQR0aiIBIAsgBEEEdGoiAigCCLgiD0QAAAAAAAAIQKIgDyAEIApGGyIPIAIuAQC3oiABKgIAu6C2OAIAIAEgDyACLgECt6IgASoCBLugtjgCBCACLgEEIQIgASAPIAEqAgy7oLY4AgwgASAPIAK3oiABKgIIu6C2OAIIIARBAWoiBCAJRw0ACwsgBgRAQQAhAyAFKAIYIQoDQCAHIANBBHRqIgEqAgwiDiALIAogA0ECdGooAgBBBHRqIgkoAghBBWyzYEEBc0UEQCAJAn8gASoCACAOlSIOi0MAAABPXQRAIA6oDAELQYCAgIB4CzsBACAJAn8gASoCBCABKgIMlSIOi0MAAABPXQRAIA6oDAELQYCAgIB4CzsBAiAJAn8gASoCCCABKgIMlSIOi0MAAABPXQRAIA6oDAELQYCAgIB4CzsBBAsgA0EBaiIDIAZHDQALCyAIEBYgBxAWCwJAIAZFBEAgBSgCGCEIDAELIAUoAhghCEEAIQcDQCAAKAIAIAggB0ECdGooAgBBBHRqIgEuAQQhCyABLgECIQNB9IkCKAIAIgogAS4BACICQQd1QQF0ai8BACEEQfCJAigCACEJIAwoAhAhDQNAIAQiAUH//gFNBEAgAiAJIAFBgAFqIgRBBnZB/v//H3FqLwEATg0BCwsgCiADQQd1QQF0ai8BACEEA0AgBCICQf/+AU0EQCADIAkgAkGAAWoiBEEGdkH+//8fcWovAQBODQELCyAKIAtBB3VBAXRqLwEAIQQDQCAEIgNB//4BTQRAIAsgCSADQYABaiIEQQZ2Qf7//x9xai8BAE4NAQsLIA0gB0EDdGogA0ERdEGAgIB4cSACQQl0QYCA/AdxIAFBAXRBgP4DcXJyrTcCACAHQQFqIgcgBkcNAAsLIAwgBjYCACAFKAIMEBYgBSgCEBAWIAUoAhQQFiAIEBYgBUEgaiQAIAwPC0HoIkEAEC0ACxkAQX8gACgCCCIAIAEoAggiAUcgACABSxsLDQAgAC4BBCABLgEEawsNACAALgECIAEuAQJrCw0AIAAuAQAgAS4BAGsL8AwCEX8EfCMAQSBrIgUkAEEAQQwgASgCHCIDEBchDiADQYACECwhESADQX5qQf8BSQRAIBEoAhAhEgJAIAMgACgCBCICSA0AIAEoAiANACAFIAI2AgAgBUHII0HOIyACQQFGGzYCBEEBQZgjIAUQGSAAKAIEIQILIAJBiQJKIAMgAk5yIAMgAiADIAJIGyIHQQNIckUEQCAHIAEoAihBAEdrIQcLQQAhASAOQQA2AgggDiACNgIEIA5BADYCAEEBIQ8gAkEBTgRAIAAoAgAhAwNAIAEgAyAEQQR0aigCCGohASAEQQFqIgQgAkcNAAsgDiABNgIICwJAIAdBAkgNAANAQQAhBEEAIQxBACECA0AgDiAEQQxsaiIBKAIEQQJOBEAgASAMIAEoAggiAyACSyIBGyEMIAMgAiABGyECCyAEQQFqIgQgD0cNAAsgDEUNASAFIAAoAgAgDCgCAEEEdGoiCCgBADYCECAFIAgvAQQ7ARQgBSAILwEEOwEcIAUgCCgBADYCGAJAIAwoAgQiCkEBTARAIAUvARwhAiAFLwEUIQMgBS8BGiEQIAUvARIhCSAFLwEYIQsgBS8BECENDAELQQEhASAFLwEUIQMgBS8BHCECIAUvARIhCSAFLwEaIRAgBS8BECENIAUvARghCyAIIQQDQCADIAQuARQiBiADQRB0QRB1IAZKGyEDIAIgBiACQRB0QRB1IAZIGyECIAkgBC4BEiIGIAlBEHRBEHUgBkobIQkgECAGIBBBEHRBEHUgBkgbIRAgDSAELgEQIgYgDUEQdEEQdSAGShshDSALIAYgC0EQdEEQdSAGSBshCyAEQRBqIQQgAUEBaiIBIApHDQALIAUgDTsBECAFIAs7ARggBSAQOwEaIAUgCTsBEiAFIAI7ARwgBSADOwEUCyAIIApBEEEQQRFBEiAJQRB0QRB1IBBBEHRBEHVrt0RiEFg5tMjiP6IiFSADQRB0QRB1IAJBEHRBEHVrt0TJdr6fGi+9P6IiFGYbIgEgDUEQdEEQdSALQRB0QRB1a7dEiUFg5dAi0z+iIhMgFGYbIAEgEyAVZhsQOUEBIQQgDCgCBCEJAkAgCCgCCCICIAwoAggiDUEBdiIGTwRAIAIhAwwBCyAJQQNIBEAgAiEDDAELIAlBf2ohCkEBIQEDQCABQQFqIQQgCCABQQR0aigCCCIDIAJqIgIgBk8NASAEIgEgCkgNAAsLIAwoAgAhCCAOIA9BDGxqIgogCSAEIAMgAmtBAXQgDWogAkEBdCANa0kgBEEBS3EiAWsiBGs2AgQgCiAEIAhqNgIAIAogDSACIANBACABG2siAWs2AgggDCABNgIIIAwgBDYCBCAPQQFqIg8gB0cNAAsgByEPC0EAIQsDQEQAAAAAAAAAACEVAkAgDiALQQxsaiICKAIEIgRFBEBEAAAAAAAAAAAhFkQAAAAAAAAAACEUDAELIAAoAgAgAigCAEEEdGohA0QAAAAAAAAAACEWRAAAAAAAAAAAIRRBACEBA0AgFSADIAFBBHRqIgcuAQS3IAcoAgi4IhOioCEVIBYgBy4BArcgE6KgIRYgFCAHLgEAtyAToqAhFCABQQFqIgEgBEcNAAsLAn8gFCACKAIIuCIUoyITmUQAAAAAAADgQWMEQCATqgwBC0GAgICAeAshBAJ/IBUgFKMiE5lEAAAAAAAA4EFjBEAgE6oMAQtBgICAgHgLIQkgBEEQdCEBAn8gFiAUoyITmUQAAAAAAADgQWMEQCATqgwBC0GAgICAeAshECABQRB1IQNB9IkCKAIAIgggAUEXdUEBdGovAQAhAUHwiQIoAgAhCgNAIAEiAkH//gFNBEAgAyAKIAJBgAFqIgFBBnZB/v//H3FqLwEATg0BCwsgEEEQdCIBQRB1IQMgCCABQRd1QQF0ai8BACEBA0AgASIEQf/+AU0EQCADIAogBEGAAWoiAUEGdkH+//8fcWovAQBODQELCyAJQRB0IgFBEHUhByAIIAFBF3VBAXRqLwEAIQEDQCABIgNB//4BTQRAIAcgCiADQYABaiIBQQZ2Qf7//x9xai8BAE4NAQsLIBIgC0EDdGogA0ERdEGAgIB4cSAEQQl0QYCA/AdxIAJBAXRBgP4DcXJyrTcCACALQQFqIgsgD0cNAAsgDhAWIBEgDzYCACAFQSBqJAAgEQ8LQegiQQAQLQALzQgBEX8jAEGgEGsiBiQAQQBBEEH9HxAXIQUgAEKAgICA0P8DNwIEIAAgBTYCAANAIAUgA0EEdGpBADYCCCADQQFqIgNB/R9HDQALIAZBoAhqQQBBgAgQGxogASgCACEDAkAgASgCBEEBSARADAELA0ACQAJ/IAMgDkECdGooAgAiBygCGCIKBEAgBygCACEPIAZBIGpBAEGACBAbGiAGQSBqDAELIAEoAgwiCkUNASAHKAIAIQ8gBkGgCGoLIQVBACEMIAcuARQiA0EATgRAIAUgA0H//wNxQQJ0aigCACEMCyAPRQRAIAEgBxAvGgsgBy8BCiIDBEAgA0EBIANBAUsbIRAgBy8BCCINQQEgDUEBSxshESAHKAIAIRJBACELA0AgDQRAIBIgC0ECdGooAgAhA0EAIQQDQCAFIAMtAABBAnRqIhMgEygCAEEBajYCACADQQFqIQMgBEEBaiIEIBFHDQALCyALQQFqIgsgEEcNAAsLAkAgBygCGEUNACAKKAIAIgRFDQBBACEDA0ACQCAFIANBAnRqKAIAIg1FDQAgAyAHLgEURg0AIAooAhAgA0EDdGoiBC0AAyEQIAQtAAIhESAGQfCJAigCACILIAQtAAFBAXRqLwEAOwEYIAYgCyARQQF0ai8BADsBGiAGIAsgEEEBdGovAQAiBDsBDCAGIAQ7ARwgBiAGKAIYNgIIIAAgBkEIaiANEEkaIAooAgAhBAsgA0EBaiIDIARHDQALCwJAIAcuARQiA0EASA0AIAUgA0H//wNxQQJ0aiIFKAIAIgMgDEYNACAFIAw2AgAgCCAMayADaiEICyAHLQASQQJGBEAgBy8BCiAHLwEIbCAJaiEJCyAPDQAgBxAmCyABKAIAIQMgDkEBaiIOIAEoAgRIDQALCyABKAIMIQQCQAJAIAMoAgAuARRBf0wEQCAERQRAIAggCWohCAwDCyAEKAIAIAEvARAiBUwEQCAIIAlqIQgMAgsgBkGgCGogBUECdGoiBSAFKAIAIAlqNgIADAELIAggCWohCCAERQ0BCyAEKAIARQ0AQQAhAwNAIAZBoAhqIANBAnRqKAIAIgkEQCAEKAIQIANBA3RqIgUtAAMhBCAFLQACIQogBkHwiQIoAgAiByAFLQABQQF0ai8BADsBECAGIAcgCkEBdGovAQA7ARIgBiAHIARBAXRqLwEAIgU7AQQgBiAFOwEUIAYgBigCEDYCACAAIAYgCRBJGiABKAIMIQQLIANBAWoiAyAEKAIARw0ACwsgACgCBCIFBEBBACEDIAUhAQNAAkAgACgCACIEIANBBHRqIgcoAggEQCADQQFqIQMMAQsgBCABQQR0aiIEKAIIBEAgByAEKQMANwMAIAcgBCkDCDcDCCABQQFqIQEgA0EBaiEDIAAoAgQhBQwBCyABQQFqIQELIAMgBUcNAAsLIABBADYCCCACIAg2AgAgBkGgEGokAAuGAQEFfyAAKAIEIgQEQCAEIQIDQAJAIAAoAgAiAyABQQR0aiIFKAIIBEAgAUEBaiEBDAELIAMgAkEEdGoiAygCCARAIAUgAykDADcDACAFIAMpAwg3AwggAkEBaiECIAFBAWohASAAKAIEIQQMAQsgAkEBaiECCyABIARHDQALCyAAQQA2AggLvAQCCn8DfAJAAkACQAJAIABBpJMCKAIARgRAIABBAUcNBEH4iQIrAwAgAWENBEHwiQIoAgAiA0GwGkYNAQwCC0HwiQIoAgAhAyAARQRAIANBsBpHBEAgAxAWQfSJAigCABAWC0H0iQJBsB42AgBB8IkCQbAaNgIADAMLIANBsBpHDQELQfCJAkEAQQJBgAIQFzYCAEH0iQJBAEECQYACEBc2AgBB8IkCKAIAIQMLRAAAAAAAAPA/IAGjIQ1B9IkCKAIAIQgDQCADIARBAXQiBWoiBgJ/IAS3IgxEAAAAAADgb0CjIAEQpgFEAAAAAMD/30CiRAAAAAAAAOA/oCIOmUQAAAAAAADgQWMEQCAOqgwBC0GAgICAeAs7AQAgBSAIaiIJAn8gDEQAAAAAAABwP6IgDRCmAUQAAAAAwP/fQKJEAAAAAAAA4D+gIgyZRAAAAAAAAOBBYwRAIAyqDAELQYCAgIB4CzsBAAJAIARFDQAgBEF/akEBdCEHAkAgBi8BACICQf7/AUsNACACIAMgB2ovAQAiCksNAANAAkAgAkEBaiEFIAJB//8DcSILQf3/AUsNACAFIQIgCyAKSQ0BCwsgBiAFOwEACyAERQ0AIAkvAQAiAkH+/wFLDQAgAiAHIAhqLwEAIgZLDQADQAJAIAJBAWohBSACQf//A3EiB0H9/wFLDQAgBSECIAcgBkkNAQsLIAkgBTsBAAsgBEEBaiIEQYACRw0ACwtB+IkCIAE5AwBBpJMCIAA2AgALC/sBAQV/QfSJAigCACIEIAAuAQAiA0EHdUEBdGovAQAhAUHwiQIoAgAhBQNAIAEiAkH//gFNBEAgAyAFIAJBgAFqIgFBBnZB/v//H3FqLwEATg0BCwsgACACOwEAIAQgAC4BAiIDQQd1QQF0ai8BACEBQfCJAigCACEFA0AgASICQf/+AU0EQCADIAUgAkGAAWoiAUEGdkH+//8fcWovAQBODQELCyAAIAI7AQIgBCAALgEEIgNBB3VBAXRqLwEAIQFB8IkCKAIAIQQDQCABIgJB//4BTQRAIAMgBCACQYABaiIBQQZ2Qf7//x9xai8BAE4NAQsLIAAgAjsBBAsxACAALQADIAAtAAJBCHQgAC0AAUEQdHJyIAEtAAMgAS0AAkEIdCABLQABQRB0cnJrCzQBAX9Bf0GUkwIoAgAiAiAALwEAQQJ0aigCACIAIAIgAS8BAEECdGooAgAiAUcgACABShsLNAEBf0F/QZSTAigCACICIAAoAgBBAnRqKAIAIgAgAiABKAIAQQJ0aigCACIBRyAAIAFKGwu7AgEDfyMAQTBrIgQkACAEQQA2AigCQEEAIAEgAygCCCADKAIAIAMoAgQgBEEoaiAEQRBqEJkBIgVBAE4EQCAAIAMoAgAgBUEUbGooAgg2AhBBASEGDAELAkAgAy0ADEUNAAJAAkAgAS0AACIFBEAgBRA1RQ0BCyAEIAE2AiwMAQsgACABIARBLGpBABAkNgIQIAEtAAAhBQsgBUH/AXFFDQAgBCgCLC0AAA0AQQEhBgwBCyACRQ0AQbIOQbwOIAQoAigiBRshAgJAIAUNACAEIAMoAhAiBTYCKCAFQQFIDQBBACEBA0AgBEEQaiABQQJ0aiABNgIAIAFBAWoiASAFRw0ACwsgAygCBCEBIAMoAgAhAyAEIAI2AgAgACAFIARBEGogAyABQacLQcQOIAQQ2gELIARBMGokACAGC8V7AR9/IwBBQGoiEyQAAkAgACgCBEEBTgRAQeCSAkEBQYADECwiAzYCACADKAIQIgNB/wE6AAMgA0H//wM7AAFB5JICIAAoAgwiAzYCACADRQRAQeSSAkGAAkGAAhAsIgM2AgAgAygCECEDA0AgAyAGOgACIAMgBjoAAyADIAY6AAEgA0EIaiEDIAZBAWoiBkGAAkcNAAsLQeiSAhCeAQJAIAAoAgQiDEEATARAQeiSAhBWDAELQQAhBkF/IQMDQEEBIQQgACgCACAGQQJ0aigCACIIKAIYIgcEQCAHEJ8BIAAoAgQhDCAFIQQLIAYgAyAILgEUQX9KGyADIANBAEgbIQMgBCEFIAZBAWoiBiAMSA0ACyAFBEBB5JICKAIAEJ8BC0HokgIQViADQQBIDQBB4JICKAIAKAIQIAAoAgAgA0ECdGooAgAiBCgCGCIDBH8gAwUgACgCDAsoAhAgBC4BFEEDdGopAgA3AgALQQAhBCAAEEpB9JICIAAvARIiBzYCAEH4kgIgAC8BFCIFNgIAQQEhAyAAKAIAIQYCQCAAKAIEQQFIDQAgBigCACAHIAUQpAEgACgCACEGIAAoAgRBAkgNAANAIAYgA0ECdGooAgBB9JICKAIAQfiSAigCABCkASAAKAIAIQYgA0EBaiIDIAAoAgRIDQALCwJAIAYoAgAuARRBf0oNACAAKAIMRQ0AQeSSAigCACIFKAIAIAAvARAiA0wNACAFKAIQIANBA3RqKAIEIQQLQfySAiAENgIAQfiSAigCAEH0kgIoAgBsIQogAkUhIAJAAkACfwJAAkACQAJAAkBB4JICKAIAKAIAQf//A08EQEGAkwJBAEEEIAoQFzYCAEGEkwJBAEEEIAoQFzYCAEGIkwJBAEEEIAoQFyIZNgIAQfiSAigCAEH0kgIoAgBsIgIEQEGAkwIoAgBBACACQQJ0IgIQGxpBhJMCKAIAQQAgAhAbGgtBjJMCQQA2AgACQCAAKAIEQQFOBEAgCkECdCEWIAFB/v8DcUEARyEbQQAhGUEAIQMDQCAOIR0gACgCACADQQJ0aigCACEOQQBBLEEBEBciFUEBNgIgIBVBADYCFEEBIBogDigCGBshGgJAIA4tABJBA0cEQCAaRQ0BQYyTAigCAEEBSA0BIB0tABJBAkkNAQsCfyAZRQRAQQBBBCAKEBchGQsgGQtBhJMCKAIAIBYQGBoLAkAgHwRAQYSTAigCACECQYSTAkGIkwIoAgA2AgBBiJMCIAI2AgAMAQtBhJMCKAIAIAAgDiAgEHYLQQAhH0GMkwIoAgAhIQNAIBVBAToADCAVAn8gIUEBTgRAAn8CQCAdBEAgHS0AEkEBSw0BCyAOLwEOIgQgDi8BCmoiAkH4kgIoAgAiDyACIA9IGyEHIA4vAQwiAyAOLwEIaiICQfSSAigCACILIAIgC0gbIQwgAyALIAsgA0obIRQgBCAPIA8gBEobDAELQfiSAigCACIPIQdB9JICKAIAIgshDEEAIRRBAAshAiALQQJ0IQZBhJMCKAIAIRdBgJMCKAIAIRwCQCACIA9ODQAgDyACQQFqIgMgDyADShshAwNAIBwgAiALbEECdCIEaiAEIBdqIAYQPQ0BIAJBAWoiAiAPRw0ACyADIQILIAcgAiAHIAJIGyIFQX9qIQQCfwNAQQAhAyAHIgkgAkwEQCAFIQkgBCEHQQAMAgsgHCAJQX9qIgcgC2xBAnQiCGogCCAXaiAGED1FDQALQQELIR4gCyEEIAIgCUgEQCAMQX9qIRFBACEFIAshBiACIQgDQCAXIAggC2xBAnQiA2ohEiADIBxqIRACQCAUIgQgBk4NAANAIBAgBEECdCIDaigCACADIBJqKAIARw0BIARBAWoiBCAGRw0ACyAGIQQLIAUgESAFIBFIGyEGIAwhAwNAAkAgA0F/aiIDIAVMBEAgBiEDDAELIBAgA0ECdCINaigCACANIBJqKAIARg0BCwsgBCEGIAMhBSAIQQFqIgggCUcNAAsLIB5FBEAgDi8BDCIDIQQgDi8BDiIHIQILIBUgAjsBAiAVIAQ7AQAgFSADIARrQQFqIgk7AQQgByACa0EBagwBCyAOLwEKIQUgDi8BCCEDQfSSAigCACELIA4vAQwhCCAVIA4vAQ4iB0H4kgIoAgAiDyAPIAdKGyICOwECIBUgCCALIAsgCEobIgQ7AQAgFSADIAhqIgMgCyADIAtIGyAEayIJOwEEIAUgB2oiAyAPIAMgD0gbIAJrCyIIOwEGAkAgDi0AEiIDQf4BcUECRw0AICEgACgCBEF/ak4NACALIA9sIQIgACgCACAhQQJ0aigCBCEJQYiTAigCACEMAkAgA0EDRgRAIAwgGSACQQJ0EBgaDAELIAxBhJMCKAIAIAJBAnQQGCEGIA4tABJBAkcNACAOLwEOIgMgDi8BCmoiAiAPIAIgD0gbIAMgDyAPIANKGyIIayIHQQFIDQAgDi8BDCIDIA4vAQhqIgIgCyACIAtIGyADIAsgCyADShsiBWsiBEECdCECQQAhAwNAIARBAU4EQCAGIAMgCGogC2wgBWpBAnRqQQAgAhAbGgsgA0EBaiIDIAdHDQALCyAMIAAgCSAgEHYgDi8BDiIFIA4vAQpqIgJB+JICKAIAIg8gAiAPSBshCCAOLwEMIgQgDi8BCGoiAkH0kgIoAgAiCyACIAtIGyEDIAUgDyAPIAVKGyEGIAQgCyALIARKGyEhAn8CQCAVLwEEIgRFDQAgFS8BBiIMRQ0AIBUvAQIhByAVLwEADAELIBUgDzsBBiAVIAs7AQRBACEHIBVBADYCACAPIQwgCyEEQQALIQUgByAMQf//A3FqIgwgCCAIIAxIGyAHIAYgBiAHShsiAmshCCAFIARB//8DcWoiFCADIAMgFEgbIhcgBSAhICEgBUobIgRrIQlBACEeAkAgBiAHTg0AQYiTAigCACERQYSTAigCACESA0AgCUEBTgRAIBEgAiALbEECdCIDaiEQIAMgEmohDSAEIQMDQAJAIA0gA0ECdCIGaigCAEUNACAGIBBqKAIADQBBASEeDAQLIANBAWoiAyAXSA0ACwsgCEF/aiEIIAJBAWoiAiAHSA0ACyAHIQILAkAgAiAIaiIGIAxMDQAgDCACayEHQYiTAigCACEcQYSTAigCACERA0AgCUEBTgRAIBwgBkF/aiALbEECdCIDaiESIAMgEWohECAEIQMDQAJAIBAgA0ECdCINaigCAEUNACANIBJqKAIADQBBASEeDAQLIANBAWoiAyAXSA0ACwsgCEF/aiIIIAJqIgYgDEoNAAsgByEIIAwhBgsCQCAhIAVODQBBiJMCKAIAIRJBhJMCKAIAIRADQCACIAZIBEAgEiAEQQJ0IgNqIQ0gAyAQaiEMIAIhAwNAAkAgDCADIAtsQQJ0IgdqKAIARQ0AIAcgDWooAgANAEEBIR4MBAsgA0EBaiIDIAZHDQALCyAJQX9qIQkgBEEBaiIEIAVIDQALIAUhBAsCQCAEIAlqIgwgFEoEQCAUIARrIQUgBEECdCIDQYiTAigCAGpBfGohEkGEkwIoAgAgA2pBfGohEANAIAIgBkgEQCASIAlBAnQiA2ohDSADIBBqIQwgAiEDA0ACQCAMIAMgC2xBAnQiB2ooAgBFDQAgByANaigCAA0AQQEhBwwFCyADQQFqIgMgBkcNAAsLIAlBf2oiCSAEaiAUSg0ACyAUIQwgBSEJC0EBIQcgHg0AQQAhByACIAZODQBBiJMCKAIAIRFBhJMCKAIAIRIgAiEFA0ACQCAEIAxODQAgESAFIAtsQQJ0IgNqIRAgAyASaiENIAQhAwNAAkAgDSADQQJ0IhRqKAIARQ0AIBAgFGooAgANAEEBIQcMAgsgA0EBaiIDIAxHDQALCyAFQQFqIgUgBkcNAAsLIBUgCDsBBiAVIAk7AQQgFSACOwECIBUgBDsBAEEBIR8gB0UNACAVQQI6AAwLIA8CfwJAIAhB//8DcSIGRQ0AIAlB//8DcSINRQ0AIAJB//8DcQwBCyAVQoCAgICQgMAANwIAQQAhAkEBIQhBASEJQQAhBEEBIQ1BASEGQQALIgNMDQ4gDSAEQf//A3EiBGogC0ogCyAETHIgAyAGaiAPSnINDkGMkwIoAgAiBEEASiEUIAhB//8DcSEDIAJB//8DcSEIQfySAigCACECQQBBAUHgkgIoAgAoAgAiERAXIRwgEUEBSCIQRQRAIBxBACAREBsaCyAJQf//A3EhCyACIARyIQ8gAyAIaiEJQYCTAigCACESQfSSAigCACEXQYSTAigCACECA0AgFS8BAEECdCIEIBIgCCAXbEECdCIDamohBiACIANqIARqIQdBACEDA0BBAiEMAkAgHCAHIANBAnQiBWooAgAiBGoiDSAFIAZqKAIAIARGBH8gDS0AAA0BQQEFQQILOgAACyADQQFqIgMgC0cNAAsgCEEBaiIIIAlJDQALAn8gHC0AAEUEQEEBIQ1BAAwBCyAcQQI6AABBACENQQILIQYgE0EANgIgIBNCADcCGAJAIBANAEEBIQMgE0EYaiAGQQJ0aiIEIAQoAgBBAWo2AgAgEUEBRg0AA0AgE0EYaiADIBxqLQAAQQJ0aiIEIAQoAgBBAWo2AgAgA0EBaiIDIBFHDQALCyAPIA0gEygCICIEQYACSHFFckUEQCAcQQI6AAAgEyAEQQFqIgQ2AiBBAiEGCyAPRSAUIBtxciATKAIcIgUgBGpBgAJKciEHIAdFIAYgBUEBSHJyRQRAIBxBAjoAACATIARBAWoiBDYCIEECIQYLIAdFBEBBACEDAkAgEA0AA0AgBkH/AXFBAUYEQCADIBxqQQI6AAALIANBAWoiAyARRg0BIAMgHGotAAAhBgwAAAsACyATIAQgBWoiBDYCIAsCQCAHQQFzIARB/wFKcg0AIBwtAAANACAcQQI6AAAgEyAEQQFqIgQ2AiALIBUgBDYCGCAVIBw2AhQgBEGBAk8EQCAaRQ0GQYyTAigCACIhQQFIDQYgHS0AEiIDQf4BcUECRw0GIB0oAkAiAi0ADCADRg0GIAIgAzoADCASIBkgFhAYGgwBCwsgDiAVNgJAIBUvAQIiBCAVLwEGaiIDQfiSAigCACIJIAMgCUgbIAQgCSAJIARKGyIHayEGIBUvAQAiAyAXIBcgA0obIQggFS8BBCADaiEFAkAgFS0ADEECRgRAIAZBAUgNASAFIBcgBSAXSBsgCGsiBUECdCEEQQAhAwNAIAVBAU4EQCASIAMgB2ogF2wgCGpBAnRqQQAgBBAbGgsgA0EBaiIDIAZHDQALDAELIAZBAUgNACASIAcgF2wgCGpBAnQiA2ohBCACIANqIQMgBSAXIAUgF0gbIAhrQQJ0IQdBACENA0AgBCADIAcQGCEFIAMgF0ECdCIEaiEDIAQgBWohBCANQQFqIg0gBkcNAAsLAkACQAJAIA4tABJBfmoOAgABAgsgDi8BDiIEIA4vAQpqIgMgCSADIAlIGyAEIAkgCSAEShsiBmsiCEEBSA0BIA4vAQwiBCAOLwEIaiIDIBcgAyAXSBsgBCAXIBcgBEobIgdrIgVBAnQhBEEAIQMDQCAFQQFOBEAgAiADIAZqIBdsIAdqQQJ0akEAIAQQGxoLIANBAWoiAyAIRw0ACwwBC0GEkwIgGTYCACACIRkLQYyTAkGMkwIoAgBBAWoiAzYCACADIAAoAgRIDQALQYiTAigCABAWIBlFDQELIBkQFgtBACEDQeCSAigCACgCACIRQX9qIQhBAEEEIBEQFyESQQBBBCAREBchEEEAQQQgERAXIQ4gEUEBSgRAA0AgECADQQJ0aiADQQFqIgM2AgAgAyAIRw0ACwsgACgCBCILQQFOBEAgACgCACEHQQAhBUEkQSAgEUGBAkobIQQDQEECIQYgByAFQQJ0aigCACgCQCIJQoGAgIAQNwIgQQEhAyAJKAIYIgJBA08EQANAIANBA2whAyAGQQF0IgYgAkkNAAsgCSADNgIkCyAJIAQgCWooAgA2AhwgBUEBaiIFIAtHDQALCwJ/IBFBAk4EQCASQQRqQQAgEUECdEF8ahAbGiAAKAIEIQsLIAtBAU4LBEBBACECQeCSAigCACEMIAAoAgAhCQNAIAwoAgAiBkECTgRAIAkgAkECdGooAgAoAkAiAygCFCEHIAMoAhwhBUEBIQMDQCADIAdqLQAAQQJGBEAgEiADQQJ0aiIEIAQoAgAgBWo2AgALIANBAWoiAyAGRw0ACyAAKAIEIQsLIAJBAWoiAiALSA0ACwsgCARAIBFBAnQhDyAIIQdBASEEA0AgByECIAQEQEGUkwIgEjYCACAQIAJBBEENEDlBlJMCQQA2AgALIA4gECACQX9qIgdBAnRqKAIAIg1BAnRqIAc2AgACQCAAKAIEIgNBAUgEQEEAIQQMAQtBACEFQX9BACACQYACShshGUHgkgIoAgAhFCAAKAIAIQxBACEEA0ACQCAMIAVBAnRqKAIAKAJAIh0oAiBBAUgNACAdKAIUIgsgDWotAABBAkcNACAUKAIAIglBAk4EQCAdKAIcIQZBASEDA0AgAyALai0AAEECRgRAIBIgA0ECdGoiBCAEKAIAIAZrNgIACyADQQFqIgMgCUcNAAsgACgCBCEDCyAdIBk2AiQgHUEANgIgQQEhBAsgBUEBaiIFIANIDQALCwJAIAJBgQJHDQBBASEEIBFBAU4EQCASQQAgDxAbGiAAKAIEIQMLIANBAUgNAEEAIQtB4JICKAIAIQwgACgCACEJA0AgCSALQQJ0aigCACgCQCICIAIoAiAiBjYCHCAMKAIAIgVBAk4EQCACKAIUIQRBASEDA0AgAyAEai0AAEECRgRAIBIgA0ECdGoiAiACKAIAIAZqNgIACyADQQFqIgMgBUcNAAsgACgCBCEDC0EBIQQgC0EBaiILIANIDQALCyAHDQALCyAIQYACIBFBggJIGyEEAkBB/JICKAIAIgJFDQAgDiACQQJ0aiIDKAIAIgJBgAJJDQAgDiAQKAL8B0ECdGogAjYCACADQf8BNgIAC0GQkwIgBEGAAhAsIgU2AgAgEUECTgRAQeCSAigCACEHQQEhAwNAQYACIQYgDiADQQJ0aiIEKAIAIgJB/wFNBEAgBSgCECACQQN0aiAHKAIQIANBA3RqKQIANwIAIAQoAgAhBgsgBygCECADQQN0aiAGNgIEIANBAWoiAyARRw0ACwtB/JICKAIAIgIEQCAAIA4gAkECdGooAgA7ARALIBIQFiAQEBYgDhAWQfiSAigCACEDQfSSAigCACECIBNBtJcCKAIANgI4IBNBrJcCKQIANwMwIBNBpJcCKQIANwMoIBNBnJcCKQIANwMgIBNBlJcCKQIANwMYIAFB//8DcSIXQQNPBEAgEyATKAIYQQRyNgIYCyAAQZCTAigCADYCDCACIANsIhwEQEGAkwIoAgBBACAcQQJ0IgIQGxpBhJMCKAIAQQAgAhAbGgtBjJMCQQA2AgACQCAAKAIEQQFIDQBBACEfQQAhAwNAIAAoAgAgA0ECdGooAgAiCigCACEdIAooAkAhGgJAIAotABJBA0cNACAfRQRAQQBBBCAcEBchHwsgCkUNACAKLwEOIgMgCi8BCmoiAkH4kgIoAgAiBCACIARIGyADIAQgBCADShsiAmsiCEEBSA0AIB8gAkH0kgIoAgAiCWwgCi8BDCIFIAkgCSAFShsiBGpBAnQiAmohBkGEkwIoAgAgAmohAyAKLwEIIAVqIgIgCSACIAlIGyAEa0ECdCEHQQAhBANAIAYgAyAHEBghBSADIAlBAnQiAmohAyACIAVqIQYgBEEBaiIEIAhHDQALC0GEkwIoAgAgACAKQQAQdiAKLQASIQ8gCi8BDiEgIAovAQwhHiAKLwEKIREgCi8BCCESIAoQJiAKIBovAQA7AQwgCiAaLwECOwEOIAogGi8BBDsBCCAKIBovAQY7AQogCiAaLQAMOgASQYyTAigCAEEBTgRAIApBADoAEwsgGigCFCEDIAooAhgQMyAKQQA2AhggCkGQkwIoAgAgAxBeIgRFBEAgCkEAQYACECwiAjYCGCAKIAIgAxBeIQQLIApBAEEBIAovAQogCi8BCGwQF0EAEEIaAkACQCAXQQJJDQBBjJMCKAIAQQFIDQAgCi4BFCILQQBIDQAgCi8BCCIHIAovAQwiA2oiAkH0kgIoAgAiCCACIAhIGyADIAggCCADShsiDmshFiAKLwEOIgMgCi8BCmoiAkH4kgIoAgAiBSACIAVIGyADIAUgBSADShsiEGsiG0EBSCIFRQRAQQAhDEGEkwIoAgAgDkECdGohAgNAIBZBAU4EQCAKKAIEIAcgDGxqIQMgAiAMIBBqIAhsQQJ0aiEGQQAhDQNAIAMgBCAGKAIAai0AADoAACADQQFqIQMgBkEEaiEGIA1BAWoiDSAWRw0ACwsgDEEBaiIMIBtHDQALCyAAIAogE0EYahA2IBMgEygCGEEIcjYCGAJAIAUNACAWIBtsIRlBACECQQAhFCAKKAIEIgchBSAHIQNBACEVA0AgFkEBTgRAQQAhIUH0kgIoAgAgECAVamxBAnQiBiAOQQJ0IghBgJMCKAIAamohDUGEkwIoAgAgCGogBmohBgNAIAUhCCACIQkgAwJ/AkACQCAGKAIAIgwgDSgCAEYNACALIAQgDGotAABGDQBBACECIAlBAUcEQAwCCyAXQQNJBEAMAgsgA0F/ai0AACALRgRADAILIBRFBEBBAEEBIBkQFyEUCyAUIAcgCigCBGtqIAcgCCAHaxAYGiAUIAggCigCBGtqIAsgAyAIaxAbGiAGKAIAIQwgAyEHDAELQQEhAiADIQUCQAJAIAkOAgIAAQsgBCAMai0AACADQX9qLQAARgRAIAghBQwCC0ECIQIgCCALIAMgCGsQGyEFIAsMAgsgCCEFIAsgCSICQQFKDQEaCyAEIAxqLQAACzoAACANQQRqIQ0gBkEEaiEGIANBAWohAyAhQQFqIiEgFkcNAAsLIBVBAWoiFSAbRw0ACyAURQ0AIBQgByAKKAIEa2ogByADIAdrEBgaIAAgCiATQRhqEDYgCiAUQQAQQhoLIAAgCiATQRhqEDYgChAmIBMgEygCGEF3cTYCGAwBCyAKLwEOIgMgCi8BCmoiAkH4kgIoAgAiBSACIAVIGyADIAUgBSADShsiCWsiCEEBSA0AIAovAQgiByAKLwEMIgNqIgJB9JICKAIAIgwgAiAMSBsgAyAMIAwgA0obIgJrIQtBACEFQYSTAigCACACQQJ0aiECA0AgC0EBTgRAIAooAgQgBSAHbGohAyACIAUgCWogDGxBAnRqIQZBACENA0AgAyAEIAYoAgBqLQAAOgAAIANBAWohAyAGQQRqIQYgDUEBaiINIAtHDQALCyAFQQFqIgUgCEcNAAsLAkAgCigCAEUNACAXQQFNQQAgHRtFBEAgACAKIBNBGGoQNiAKECYMAQsgChBDCyAEEBYgGgRAIBooAhQQFiAaEBYLIApBADYCQAJAAkACQCAKLQASDgQAAAECBwsgCi8BDiIDIAovAQpqIgJB+JICKAIAIgQgAiAESBsgAyAEIAQgA0obIgJrIgdBAUgNAUEAIQYgAkH0kgIoAgAiCWwgCi8BDCIIIAkgCSAIShsiBWpBAnQiAkGAkwIoAgBqIQRBhJMCKAIAIAJqIQMgCi8BCCAIaiICIAkgAiAJSBsgBWtBAnQhBQNAIAQgAyAFEBghBCADIAlBAnQiAmohAyACIARqIQQgBkEBaiIGIAdHDQALDAELIAovAQ4iAyAKLwEKaiICQfiSAigCACIEIAIgBEgbIAMgBCAEIANKGyIGayIIQQFIDQBBgJMCKAIAIQcgCi8BDCIDIAovAQhqIgJB9JICKAIAIgkgAiAJSBsgAyAJIAkgA0obIgVrIgRBAnQhAkEAIQMDQCAEQQFOBEAgByADIAZqIAlsIAVqQQJ0akEAIAIQGxoLIANBAWoiAyAIRw0ACwsCQAJAAkAgD0F+ag4CAAECCyARICBqIgJB+JICKAIAIgMgAiADSBsgICADIAMgIEobIgZrIghBAUgNAUGEkwIoAgAhByASIB5qIgJB9JICKAIAIgkgAiAJSBsgHiAJIAkgHkobIgVrIgRBAnQhAkEAIQMDQCAEQQFOBEAgByADIAZqIAlsIAVqQQJ0akEAIAIQGxoLIANBAWoiAyAIRw0ACwwBCyARICBqIgJB+JICKAIAIgMgAiADSBsgICADIAMgIEobIgJrIgdBAUgNAEEAIQYgAkH0kgIoAgAiCGwgHiAIIAggHkobIgVqQQJ0IgJBhJMCKAIAaiEEIAIgH2ohAyASIB5qIgIgCCACIAhIGyAFa0ECdCEFA0AgBCADIAUQGCEEIAMgCEECdCICaiEDIAIgBGohBCAGQQFqIgYgB0cNAAsLQYyTAkGMkwIoAgBBAWoiAzYCACADIAAoAgRIDQALIB9FDQAgHxAWC0GAkwIhBkGEkwIMBgtBmJMCQQBBAiAKEBc2AgBBnJMCQQBBAiAKEBc2AgBBoJMCQQBBAiAKEBciGTYCAEH4kgIoAgBB9JICKAIAbCICBEBBmJMCKAIAQQAgAkEBdCICEBsaQZyTAigCAEEAIAIQGxoLQYyTAkEANgIAAkAgACgCBEEBTgRAIApBAXQhFyABQf7/A3FBAEchHEEAIRlBACEDA0AgECEdIAAoAgAgA0ECdGooAgAhEEEAQSxBARAXIhhBATYCICAYQQA2AhRBASAaIBAoAhgbIRoCQCAQLQASQQNHBEAgGkUNAUGMkwIoAgBBAUgNASAdLQASQQJJDQELAn8gGUUEQEEAQQIgChAXIRkLIBkLQZyTAigCACAXEBgaCwJAIB8EQEGckwIoAgAhAkGckwJBoJMCKAIANgIAQaCTAiACNgIADAELQZyTAigCACAAIBAgIBB1C0EAIR9BjJMCKAIAIR4DQCAYQQE6AAwgGAJ/IB5BAU4EQAJ/AkAgHQRAIB0tABJBAUsNAQsgEC8BDiIEIBAvAQpqIgJB+JICKAIAIg8gAiAPSBshByAQLwEMIgMgEC8BCGoiAkH0kgIoAgAiCyACIAtIGyEMIAMgCyALIANKGyEUIAQgDyAPIARKGwwBC0H4kgIoAgAiDyEHQfSSAigCACILIQxBACEUQQALIQIgC0EBdCEGQZyTAigCACEhQZiTAigCACEWAkAgAiAPTg0AIA8gAkEBaiIDIA8gA0obIQMDQCAWIAIgC2xBAXQiBGogBCAhaiAGED0NASACQQFqIgIgD0cNAAsgAyECCyAHIAIgByACSBsiBUF/aiEEA0ACQEEAIQMgByIJIAJMBEAgBSEJIAQhB0EAIQ4MAQtBASEOIBYgCUF/aiIHIAtsQQF0IghqIAggIWogBhA9RQ0BCwsgCyEEIAIgCUgEQCAMQX9qIRtBACEFIAshBiACIQgDQCAhIAggC2xBAXQiA2ohESADIBZqIRICQCAUIgQgBk4NAANAIBIgBEEBdCIDai8BACADIBFqLwEARw0BIARBAWoiBCAGRw0ACyAGIQQLIAUgGyAFIBtIGyEGIAwhAwNAAkAgA0F/aiIDIAVMBEAgBiEDDAELIBIgA0EBdCINai8BACANIBFqLwEARg0BCwsgBCEGIAMhBSAIQQFqIgggCUcNAAsLIA5FBEAgEC8BDCIDIQQgEC8BDiIHIQILIBggAjsBAiAYIAQ7AQAgGCADIARrQQFqIgk7AQQgByACa0EBagwBCyAQLwEKIQUgEC8BCCEDQfSSAigCACELIBAvAQwhCCAYIBAvAQ4iB0H4kgIoAgAiDyAPIAdKGyICOwECIBggCCALIAsgCEobIgQ7AQAgGCADIAhqIgMgCyADIAtIGyAEayIJOwEEIAUgB2oiAyAPIAMgD0gbIAJrCyIIOwEGAkAgEC0AEiIDQf4BcUECRw0AIB4gACgCBEF/ak4NACALIA9sIQIgACgCACAeQQJ0aigCBCEJQaCTAigCACEMAkAgA0EDRgRAIAwgGSACQQF0EBgaDAELIAxBnJMCKAIAIAJBAXQQGCEGIBAtABJBAkcNACAQLwEOIgMgEC8BCmoiAiAPIAIgD0gbIAMgDyAPIANKGyIIayIHQQFIDQAgEC8BDCIDIBAvAQhqIgIgCyACIAtIGyADIAsgCyADShsiBWsiBEEBdCECQQAhAwNAIARBAU4EQCAGIAMgCGogC2wgBWpBAXRqQQAgAhAbGgsgA0EBaiIDIAdHDQALCyAMIAAgCSAgEHUgEC8BDiIFIBAvAQpqIgJB+JICKAIAIg8gAiAPSBshCCAQLwEMIgQgEC8BCGoiAkH0kgIoAgAiCyACIAtIGyEDIAUgDyAPIAVKGyEGIAQgCyALIARKGyEWAn8CQCAYLwEEIgRFDQAgGC8BBiIMRQ0AIBgvAQAhByAYLwECDAELIBggDzsBBiAYIAs7AQQgGEEANgIAIA8hDCALIQRBACEHQQALIQUgBSAMQf//A3FqIgwgCCAIIAxIGyAFIAYgBiAFShsiAmshCCAHIARB//8DcWoiFCADIAMgFEgbIhsgByAWIBYgB0obIgRrIQlBACEVAkAgBiAFTg0AQaCTAigCACESQZyTAigCACEOA0AgCUEBTgRAIBIgAiALbEEBdCIDaiENIAMgDmohBiAEIQMDQAJAIAYgA0EBdGovAQBFDQAgDSADQQF0ai8BAA0AQQEhFQwECyADQQFqIgMgG0gNAAsLIAhBf2ohCCACQQFqIgIgBUgNAAsgBSECCwJAIAIgCGoiBiAMTA0AIAwgAmshBUGgkwIoAgAhEUGckwIoAgAhEgNAIAlBAU4EQCARIAZBf2ogC2xBAXQiA2ohDiADIBJqIQ0gBCEDA0ACQCANIANBAXRqLwEARQ0AIA4gA0EBdGovAQANAEEBIRUMBAsgA0EBaiIDIBtIDQALCyAIQX9qIgggAmoiBiAMSg0ACyAFIQggDCEGCwJAIBYgB04NAEGgkwIoAgAhEkGckwIoAgAhDgNAIAIgBkgEQCASIARBAXQiA2ohDSADIA5qIQwgAiEDA0ACQCAMIAMgC2wiBUEBdGovAQBFDQAgDSAFQQF0ai8BAA0AQQEhFQwECyADQQFqIgMgBkcNAAsLIAlBf2ohCSAEQQFqIgQgB0gNAAsgByEECwJAIAQgCWoiDCAUSgRAIBQgBGshBSAEQQF0IgNBoJMCKAIAakF+aiERQZyTAigCACADakF+aiESA0AgAiAGSARAIBEgCUEBdCIDaiEOIAMgEmohDCACIQMDQCAMIAMgC2wiB0EBdGovAQAEQEEBIQ0gDiAHQQF0ai8BAEUNBQsgA0EBaiIDIAZHDQALCyAJQX9qIgkgBGogFEoNAAsgFCEMIAUhCQtBASENIBUNAEEAIQ0gAiAGTg0AQaCTAigCACERQZyTAigCACESIAIhBQNAIA0hBwJ/IAQgDEgEQCARIAUgC2xBAXQiA2ohDiADIBJqIRQgBCEDA0AgFCADQQF0ai8BAARAQQEgDiADQQF0ai8BAEUNAxoLIANBAWoiAyAMRw0ACwsgBwshDSAFQQFqIgUgBkcNAAsLIBggCDsBBiAYIAk7AQQgGCACOwECIBggBDsBAEEBIR8gDUUNACAYQQI6AAwLIA8CfwJAIAhB//8DcSIGRQ0AIAlB//8DcSINRQ0AIAJB//8DcQwBCyAYQoCAgICQgMAANwIAQQAhAkEBIQhBASEJQQAhBEEBIQ1BASEGQQALIgNMDQ0gDSAEQf//A3EiBGogC0ogCyAETHIgAyAGaiAPSnINDUGMkwIoAgAiBEEASiEUIAhB//8DcSEDIAJB//8DcSEIQfySAigCACECQQBBAUHgkgIoAgAoAgAiERAXIRsgEUEBSCIORQRAIBtBACAREBsaCyAJQf//A3EhCyACIARyIQ8gAyAIaiEJQZiTAigCACESQfSSAigCACEWQZyTAigCACECA0AgGC8BAEEBdCIEIBIgCCAWbEEBdCIDamohBiACIANqIARqIQdBACEDA0BBAiEMAkAgGyAHIANBAXQiBWovAQAiBGoiDSAFIAZqLwEAIARGBH8gDS0AAA0BQQEFQQILOgAACyADQQFqIgMgC0cNAAsgCEEBaiIIIAlJDQALAn8gGy0AAEUEQEEBIQ1BAAwBCyAbQQI6AABBACENQQILIQYgE0EANgIgIBNCADcCGAJAIA4NAEEBIQMgE0EYaiAGQQJ0aiIEIAQoAgBBAWo2AgAgEUEBRg0AA0AgE0EYaiADIBtqLQAAQQJ0aiIEIAQoAgBBAWo2AgAgA0EBaiIDIBFHDQALCyAPIA0gEygCICIEQYACSHFFckUEQCAbQQI6AAAgEyAEQQFqIgQ2AiBBAiEGCyAPRSAUIBxxciATKAIcIgUgBGpBgAJKciEHIAdFIAYgBUEBSHJyRQRAIBtBAjoAACATIARBAWoiBDYCIEECIQYLIAdFBEBBACEDAkAgDg0AA0AgBkH/AXFBAUYEQCADIBtqQQI6AAALIANBAWoiAyARRg0BIAMgG2otAAAhBgwAAAsACyATIAQgBWoiBDYCIAsCQCAHQQFzIARB/wFKcg0AIBstAAANACAbQQI6AAAgEyAEQQFqIgQ2AiALIBggBDYCGCAYIBs2AhQgBEGBAk8EQCAaRQ0HQYyTAigCACIeQQFIDQcgHS0AEiIDQf4BcUECRw0HIB0oAkAiAi0ADCADRg0HIAIgAzoADCASIBkgFxAYGgwBCwsgECAYNgJAIBgvAQIiBCAYLwEGaiIDQfiSAigCACIJIAMgCUgbIAQgCSAJIARKGyIHayEGIBgvAQAiAyAWIBYgA0obIQggGC8BBCADaiEFAkAgGC0ADEECRgRAIAZBAUgNASAFIBYgBSAWSBsgCGsiBUEBdCEEQQAhAwNAIAVBAU4EQCASIAMgB2ogFmwgCGpBAXRqQQAgBBAbGgsgA0EBaiIDIAZHDQALDAELIAZBAUgNACASIAcgFmwgCGpBAXQiA2ohBCACIANqIQMgBSAWIAUgFkgbIAhrQQF0IQdBACENA0AgBCADIAcQGCEFIAMgFkEBdCIEaiEDIAQgBWohBCANQQFqIg0gBkcNAAsLAkACQAJAIBAtABJBfmoOAgABAgsgEC8BDiIEIBAvAQpqIgMgCSADIAlIGyAEIAkgCSAEShsiBmsiCEEBSA0BIBAvAQwiBCAQLwEIaiIDIBYgAyAWSBsgBCAWIBYgBEobIgdrIgVBAXQhBEEAIQMDQCAFQQFOBEAgAiADIAZqIBZsIAdqQQF0akEAIAQQGxoLIANBAWoiAyAIRw0ACwwBC0GckwIgGTYCACACIRkLQYyTAkGMkwIoAgBBAWoiAzYCACADIAAoAgRIDQALQaCTAigCABAWIBlFDQELIBkQFgtBACEDQeCSAigCACgCACIRQX9qIQhBAEEEIBEQFyESQQBBAiAREBchEEEAQQIgERAXIQ4gEUEBSg0DDAQLIBMgBDYCAEHwFyATEC0AC0HNGUHgF0GrB0H5GRAAAAsgEyAENgIQQfAXIBNBEGoQLQALA0AgECADQQF0aiADQQFqIgM7AQAgAyAIRw0ACwsgACgCBCIDQQFOBEAgACgCACEHQQAhC0EkQSAgEUGBAkobIQUDQEECIQQgByALQQJ0aigCACgCQCIJQoGAgIAQNwIgQQEhBiAJKAIYIgJBA08EQANAIAZBA2whBiAEQQF0Qfz/A3EiBCACSQ0ACyAJIAY2AiQLIAkgBSAJaigCADYCHCALQQFqIgsgA0cNAAsLAn8gEUECTgRAIBJBBGpBACARQQJ0QXxqEBsaIAAoAgQhAwsgA0EBTgsEQEEAIQtB4JICKAIAIQkgACgCACEGA0AgCSgCACIHQQJOBEAgBiALQQJ0aigCACgCQCICKAIUIQUgAigCHCEEQQEhAwNAIAMgBWotAABBAkYEQCASIANBAnRqIgIgAigCACAEajYCAAsgA0EBaiIDIAdHDQALIAAoAgQhAwsgC0EBaiILIANIDQALCyAIBEAgEUECdCEPIAghB0EBIQQDQCAHIQIgBARAQZSTAiASNgIAIBAgAkECQQ4QOUGUkwJBADYCACAAKAIEIQMLIA4gECACQX9qIgdBAXRqLwEAIg1BAXRqIAc7AQACQCADQQFIBEBBACEEDAELQQAhBUF/QQAgAkGAAkobIRlB4JICKAIAIRQgACgCACEMQQAhBANAAkAgDCAFQQJ0aigCACgCQCIdKAIgQQFIDQAgHSgCFCILIA1qLQAAQQJHDQAgFCgCACIJQQJOBEAgHSgCHCEGQQEhAwNAIAMgC2otAABBAkYEQCASIANBAnRqIgQgBCgCACAGazYCAAsgA0EBaiIDIAlHDQALIAAoAgQhAwsgHSAZNgIkIB1BADYCIEEBIQQLIAVBAWoiBSADSA0ACwsCQCACQYECRw0AQQEhBCARQQFOBEAgEkEAIA8QGxogACgCBCEDCyADQQFIDQBBACELQeCSAigCACEMIAAoAgAhCQNAIAkgC0ECdGooAgAoAkAiAiACKAIgIgY2AhwgDCgCACIFQQJOBEAgAigCFCEEQQEhAwNAIAMgBGotAABBAkYEQCASIANBAnRqIgIgAigCACAGajYCAAsgA0EBaiIDIAVHDQALIAAoAgQhAwtBASEEIAtBAWoiCyADSA0ACwsgBw0ACwsgCEGAAiARQYICSBshBAJAQfySAigCACICRQ0AIA4gAkEBdGoiAy8BACICQYACSQ0AIA4gEC8B/gNBAXRqIAI7AQAgA0H/ATsBAAtBkJMCIARBgAIQLCIFNgIAIBFBAk4EQEHgkgIoAgAhB0EBIQMDQEGAAiEGIA4gA0EBdGoiBC8BACICQf8BTQRAIAUoAhAgAkEDdGogBygCECADQQN0aikCADcCACAELwEAIQYLIAcoAhAgA0EDdGogBjYCBCADQQFqIgMgEUcNAAsLQfySAigCACICBEAgACAOIAJBAXRqLwEAOwEQCyASEBYgEBAWIA4QFkH4kgIoAgAhA0H0kgIoAgAhAiATQbSXAigCADYCOCATQayXAikCADcDMCATQaSXAikCADcDKCATQZyXAikCADcDICATQZSXAikCADcDGCABQf//A3EiF0EDTwRAIBMgEygCGEEEcjYCGAsgAEGQkwIoAgA2AgwgAiADbCIcBEBBmJMCKAIAQQAgHEEBdCICEBsaQZyTAigCAEEAIAIQGxoLQYyTAkEANgIAAkAgACgCBEEBSA0AQQAhH0EAIQMDQCAAKAIAIANBAnRqKAIAIgooAgAhHSAKKAJAIRoCQCAKLQASQQNHDQAgH0UEQEEAQQIgHBAXIR8LIApFDQAgCi8BDiIDIAovAQpqIgJB+JICKAIAIgQgAiAESBsgAyAEIAQgA0obIgJrIghBAUgNACAfIAJB9JICKAIAIglsIAovAQwiBSAJIAkgBUobIgRqQQF0IgJqIQZBnJMCKAIAIAJqIQMgCi8BCCAFaiICIAkgAiAJSBsgBGtBAXQhB0EAIQQDQCAGIAMgBxAYIQUgAyAJQQF0IgJqIQMgAiAFaiEGIARBAWoiBCAIRw0ACwtBnJMCKAIAIAAgCkEAEHUgCi0AEiEPIAovAQ4hICAKLwEMIR4gCi8BCiERIAovAQghEiAKECYgCiAaLwEAOwEMIAogGi8BAjsBDiAKIBovAQQ7AQggCiAaLwEGOwEKIAogGi0ADDoAEkGMkwIoAgBBAU4EQCAKQQA6ABMLIBooAhQhAyAKKAIYEDMgCkEANgIYIApBkJMCKAIAIAMQXiIERQRAIApBAEGAAhAsIgI2AhggCiACIAMQXiEECyAKQQBBASAKLwEKIAovAQhsEBdBABBCGgJAAkAgF0ECSQ0AQYyTAigCAEEBSA0AIAouARQiC0EASA0AIAovAQgiByAKLwEMIgNqIgJB9JICKAIAIgggAiAISBsgAyAIIAggA0obIg5rIRYgCi8BDiIDIAovAQpqIgJB+JICKAIAIgUgAiAFSBsgAyAFIAUgA0obIhBrIhtBAUgiBUUEQEEAIQxBnJMCKAIAIA5BAXRqIQIDQCAWQQFOBEAgCigCBCAHIAxsaiEDIAIgDCAQaiAIbEEBdGohBkEAIQ0DQCADIAQgBi8BAGotAAA6AAAgA0EBaiEDIAZBAmohBiANQQFqIg0gFkcNAAsLIAxBAWoiDCAbRw0ACwsgACAKIBNBGGoQNiATIBMoAhhBCHI2AhgCQCAFDQAgFiAbbCEZQQAhAkEAIRQgCigCBCIHIQUgByEDQQAhFQNAIBZBAU4EQEEAISFB9JICKAIAIBAgFWpsQQF0IgYgDkEBdCIIQZiTAigCAGpqIQ1BnJMCKAIAIAhqIAZqIQYDQCAFIQggAiEJIAMCfwJAAkAgBi8BACIMIA0vAQBGDQAgCyAEIAxqLQAARg0AQQAhAiAJQQFHBEAMAgsgF0EDSQRADAILIANBf2otAAAgC0YEQAwCCyAURQRAQQBBASAZEBchFAsgFCAHIAooAgRraiAHIAggB2sQGBogFCAIIAooAgRraiALIAMgCGsQGxogBi8BACEMIAMhBwwBC0EBIQIgAyEFAkACQCAJDgICAAELIAQgDGotAAAgA0F/ai0AAEYEQCAIIQUMAgtBAiECIAggCyADIAhrEBshBSALDAILIAghBSALIAkiAkEBSg0BGgsgBCAMQf//A3FqLQAACzoAACANQQJqIQ0gBkECaiEGIANBAWohAyAhQQFqIiEgFkcNAAsLIBVBAWoiFSAbRw0ACyAURQ0AIBQgByAKKAIEa2ogByADIAdrEBgaIAAgCiATQRhqEDYgCiAUQQAQQhoLIAAgCiATQRhqEDYgChAmIBMgEygCGEF3cTYCGAwBCyAKLwEOIgMgCi8BCmoiAkH4kgIoAgAiBSACIAVIGyADIAUgBSADShsiCWsiCEEBSA0AIAovAQgiByAKLwEMIgNqIgJB9JICKAIAIgwgAiAMSBsgAyAMIAwgA0obIgJrIQtBACEFQZyTAigCACACQQF0aiECA0AgC0EBTgRAIAooAgQgBSAHbGohAyACIAUgCWogDGxBAXRqIQZBACENA0AgAyAEIAYvAQBqLQAAOgAAIANBAWohAyAGQQJqIQYgDUEBaiINIAtHDQALCyAFQQFqIgUgCEcNAAsLAkAgCigCAEUNACAXQQFNQQAgHRtFBEAgACAKIBNBGGoQNiAKECYMAQsgChBDCyAEEBYgGgRAIBooAhQQFiAaEBYLIApBADYCQAJAAkACQCAKLQASDgQAAAECBgsgCi8BDiIDIAovAQpqIgJB+JICKAIAIgQgAiAESBsgAyAEIAQgA0obIgJrIgdBAUgNAUEAIQYgAkH0kgIoAgAiCWwgCi8BDCIIIAkgCSAIShsiBWpBAXQiAkGYkwIoAgBqIQRBnJMCKAIAIAJqIQMgCi8BCCAIaiICIAkgAiAJSBsgBWtBAXQhBQNAIAQgAyAFEBghBCADIAlBAXQiAmohAyACIARqIQQgBkEBaiIGIAdHDQALDAELIAovAQ4iAyAKLwEKaiICQfiSAigCACIEIAIgBEgbIAMgBCAEIANKGyIGayIIQQFIDQBBmJMCKAIAIQcgCi8BDCIDIAovAQhqIgJB9JICKAIAIgkgAiAJSBsgAyAJIAkgA0obIgVrIgRBAXQhAkEAIQMDQCAEQQFOBEAgByADIAZqIAlsIAVqQQF0akEAIAIQGxoLIANBAWoiAyAIRw0ACwsCQAJAAkAgD0F+ag4CAAECCyARICBqIgJB+JICKAIAIgMgAiADSBsgICADIAMgIEobIgZrIghBAUgNAUGckwIoAgAhByASIB5qIgJB9JICKAIAIgkgAiAJSBsgHiAJIAkgHkobIgVrIgRBAXQhAkEAIQMDQCAEQQFOBEAgByADIAZqIAlsIAVqQQF0akEAIAIQGxoLIANBAWoiAyAIRw0ACwwBCyARICBqIgJB+JICKAIAIgMgAiADSBsgICADIAMgIEobIgJrIgdBAUgNAEEAIQYgAkH0kgIoAgAiCGwgHiAIIAggHkobIgVqQQF0IgJBnJMCKAIAaiEEIAIgH2ohAyASIB5qIgIgCCACIAhIGyAFa0EBdCEFA0AgBCADIAUQGCEEIAMgCEEBdCICaiEDIAIgBGohBCAGQQFqIgYgB0cNAAsLQYyTAkGMkwIoAgBBAWoiAzYCACADIAAoAgRIDQALIB9FDQAgHxAWC0GYkwIhBkGckwILIQMgBigCABAWIAMoAgAQFkH8kgIoAgBFBEAgACAAKAIAKAIALQAUOwEQCyABQYCABHEgACgCBCIGQQFMcg0BQQEhAwNAAkAgACgCACIFIANBAnQiAmooAgAiBy8BCEEBRwRAIAMhBAwBCyAHLwEKQQFHBEAgAyEEDAELIAcuARRBAEgEQCADIQQMAQsgBygCHARAIAMhBAwBCyAHKAIgBEAgAyEEDAELIActABIiAUEDSwRAIAMhBAwBCyABQQJGBEAgAyEEDAELIAcvARBFBEAgAyEEDAELIAUgA0F/aiIEQQJ0IgFqKAIALwEQRQRAIAMhBAwBCyAAIAcQLxogBygCACgCAC0AACAHLgEURwRAIAMhBAwBCyAAKAIAIAFqKAIAIgEtABJBAUsEQCADIQQMAQsgASABLwEQIAcvARBqOwEQIAcQSyAAKAIAIAJqIgEgAUEEaiAAKAIEIANBf3NqQQJ0EMIBIAAgACgCBEF/ajYCBAsgBEEBaiIDIAAoAgQiBkgNAAsMAQtBzRlB4BdBqwdBkRoQAAALIAZBAU4EQCAAKAIAIQBBACEDA0ACQCAAIANBAnRqKAIAIgEtABJBAUcNACABLwEQDQAgAS4BFEF/Sg0AIAFBADoAEgsgA0EBaiIDIAZHDQALC0HkkgIoAgAQM0HgkgIoAgAQMwsgE0FAayQADwtBmxhB1RdBmgFBtxkQAAALoQwBDH8jAEGABmsiByQAIAAoAgwhCAJ/AkAgAigCGCILDQAgASgCDCILDQBBACELQQAMAQtBASEOIAsoAgALIQUgAhCEAiEGIAdBgAJqQQBBgAIQGxoCQCAGQQFIDQAgAi8BCiINRQ0AIAIvAQgiCiEBA0AgAUH//wNxBH8gAigCACAMQQJ0aigCACEBQQAhCQNAIAEtAAAgB0GAAmpqIg8tAAAhECAPQQE6AAAgAUEBaiEBIAYgEGpBf2ohBiAJQQFqIgkgCkcNAAsgCgVBAAshASAMQQFqIgwgDUYNASAGQQBKDQALCyACLgEUIgFBAE4EQCAHQYACaiABQf//A3FqQQA6AAALAkAgBUGAAkYNACAFIQEDQCAHQYACaiABai0AAEUEQCABQQFqIgFBgAJHDQEMAgsLIAMoAmBB5xZBABA7C0EAIQwgB0EAQYACEBsiB0GABGpBAEGAAhAbGgJAIAAoAgwgCxDxAQRAIAVFDQFBACEBA0AgB0GAAmogAWotAAAEQCAHQYAEaiABaiALKAIQIAFBA3RqKAIEOgAACyABQQFqIgEgBUcNAAsMAQtBACEBQQBBgAIQLCEIIAUEQANAIAdBgAJqIAFqLQAABEAgB0GABGogAWogCCgCACIGOgAAIAgoAhAgBkEDdGogCygCECABQQN0aikCADcCACAIIAgoAgBBAWo2AgALIAFBAWoiASAFRw0ACwsgCCEMC0EAIQFBASEGA0AgB0GAAmogAWotAAAEQCAHIAdBgARqIAFqLQAAIgVqQQE6AAAgASAFRiAGQQBHcSEGCyABQQFqIgFBgAJHDQALAkACQCACLgEUIgpBAE4EQAJAAkACQAJAAkAgBgRAIAcgCiIFai0AAEUNAQsgCCgCACIBQQFIDQFBfyEFA0AgBSABQX9qIgkgByAJai0AABshBSABQQFKIQ0gCSEBIA0NAAsLIAVBf0oNAQsgCCgCACEBDAELIAUgCCgCACIBTg0AIAUhAQwBCyAIKAIQIAFBA3RqIQUCQCAORQ0AIAsoAgAgCkwNACAFIAsoAhAgCkEDdGopAgA3AgALIAVBAjoAACABQf8BSg0CIAIuARQhCgsgB0GABGogCmogAToAACAGQQAgASAKRhshBgsgCCgCAEGBAk4NARCEASIFIAIoAhwQgAE2AhwgAi4BFCIBQQBOBEAgBSAHQYAEaiABQf//A3FqLQAAOwEUCyAFIAIvARA7ARAgBSACLQASOgASIAUgAi8BDDsBDCAFIAIvAQ47AQ4gBSACLQATIgE6ABMgBSACLwEIOwEIIAIvAQohCCAFIAw2AhggBSAIOwEKAkACQCAERSAGRXINACACKAI0RQ0AIAIoAjANACAFIAIoAiw2AixBAEEBIAIoAiwQFyEBIAVBBjYCOCAFIAE2AjQgASACKAI0IAIoAiwQGBoMAQsgBSABEF8aIAUvAQohCSAGRQRAIAlB//8DcUUNASAFLwEIIQRBACEKA0AgBCEBQQAhBCABBEAgCkECdCIEIAIoAgBqKAIAIQEgBSgCACAEaigCACEGQQAhCQNAIAYgAS0AACAHQYAEamotAAA6AAAgBkEBaiEGIAFBAWohASAJQQFqIgkgBS8BCCIESQ0ACyAFLwEKIQkLIApBAWoiCiAJQf//A3FJDQALDAELIAlB//8DcUUNAEEAIQEDQCABQQJ0IgQgBSgCAGooAgAgAigCACAEaigCACAFLwEIEBgaIAFBAWoiASAFLwEKSQ0ACwsCQCACKAIgRQ0AIAUQRiIENgIgIAIoAiAiASgCCEEBSA0AQQAhBgNAIAQgBkECdCIIIAEoAgBqKAIAIAEoAgQgCGooAgAQYSAGQQFqIgYgASgCCEgNAAsLAkAgAigCJCIBRQ0AIAMoAkwNAANAAkAgASgCAEH/AUYEQCADKAJQDQELIAAgBSABELEBEHwLIAEoAiAiAQ0ACwsgAygCVCIGBEADQCAGKAIgIQEgACAFIAYQfCADIAE2AlQgASIGDQALCyAAIAUQqwEaIAdBgAZqJAAgBQ8LQYkXQYkVQdECQbUXEAAAC0HBF0GJFUHYAkG1FxAAAAvgAgEHfyAAKAIMBEACQCABKAIMIgNFDQAgAygCACIEQQFIDQAgAygCECEFQQAhAwNAIAUgA0EDdGoiBkEAOgAAIAZBgAI2AgQgA0EBaiIDIARHDQALCyABKAIEIgVBAU4EQCABKAIAIQZBACEEA0ACQCAGIARBAnRqKAIAKAIYIgNFDQAgAygCACIHQQFIDQAgAygCECEIQQAhAwNAIAggA0EDdGoiCUEAOgAAIAlBgAI2AgQgA0EBaiIDIAdHDQALCyAEQQFqIgQgBUcNAAsLIAAoAhhBf0wEQCAAIAEoAhg2AhgLAkAgAg0AIAEoAhwiA0UNACAAKAIcIgJFBEAgABBGIgI2AhwgASgCHCEDCyADKAIIQQFIDQBBACEAA0AgAiAAQQJ0IgEgAygCAGooAgAgAygCBCABaigCABBhIABBAWoiACADKAIISA0ACwsPC0HNFkGJFUHSAUHaFhAAAAuABQEKfyABRQRAQQEPCyAAKAIIIQpBASEIIAAoAgAhAgJAAkAgASgCAEEBTgRAIAAoAhAhByABKAIQIQkDQAJAAkAgCSAGQQN0IgRqIgUtAAAiA0EBcQRAIAUoAgQiA0GAAkkEQCACIQQgAyECDAILAkACQCACQQFOBEAgBS0AASELQQAhAwNAAkAgByADQQN0aiIELQABIAtHDQAgBC0AAiAFLQACRw0AIAQtAAMgBS0AA0cNACACIQQgAyECDAYLIANBAWoiAyACRw0AC0EAIQMgAkH/AUoNAQsgByACQQN0aiAFKQIANwIAIAJBf0YNASACQQFqIQQMAwsDQCAHIANBA3RqIgQtAABBAkYEQCAEIAUpAgA3AgAgAiEEIAMhAgwECyADQQFqIgMgAkcNAAsLQYSKAigCAEEBRgRAAkBB3JICLQAARQRAQQFB1RVBABAZQdySAkEBOgAADAELQQFBphZBABAZC0GEigJBAjYCAAsgBgRAQQAhAwNAAkAgCSADQQN0aiIBLQAAQQFxRQ0AIAEoAgQgACgCAEkNACABQYACNgIECyADQQFqIgMgBkcNAAsLQQAPCyADQQJxRSAIRSACIAZHcnINASAEIAdqIAUpAgA3AgAgBkEBaiECDAELIAJBAEggAiAETnINAyAHIAJBA3RqIgMtAAEgBS0AAUcNBCADLQACIAUtAAJHDQQgAy0AAyAFLQADRw0EIAUgAjYCBCADQQE6AAAgCEEAIAIgBkYbIQggBCECCyAGQQFqIgYgASgCAEgNAAsLIAAgCjYCCCAAIAI2AgBBAQ8LQeoUQYkVQZwBQZEVEAAAC0GsFUGJFUGdAUGRFRAAAAuQAwEMfyMAQTBrIgYkAAJAIAEoAhgiBEUEQCAAKAIMIgRFDQELIAQoAhAhCiABLgEUIghBAEggBCgCACILIAhMckUEQCAKIAhBA3RqIgQgBC0AAEECcjoAAAsgC0EBSA0AQQAhBANAIAQgCiAFQQN0ai0AAEEBcUUgBSAIR3FqIQQgBUEBaiIFIAtHDQALIARFDQACQCABKAIARQRAIAAgARAvQQJHDQELQQAhAwsCfyACBEAgBiACIAEQ0QIgBigCGCIAIAYoAiBqIQwgBigCHCIHIAYoAiRqDAELIAEvAQghDEEAIQAgAS8BCgshDQJAIAcgDUYNACABKAIAIQ4DQCAAIAxHBEAgDiAHQQJ0aigCACAAaiEFIAAhAgNAAkAgCyAFLQAAIglMIAggCUZyDQAgCiAJQQN0aiIJLQAAIg9BAXENACAJIA9BAXI6AAAgBEF/aiIERQ0ECyAFQQFqIQUgAkEBaiICIAxHDQALCyAHQQFqIgcgDUcNAAsLIANBAUgNACABECYLIAZBMGokAAtCAQN/IAAoAgAiAUEBTgRAIAAoAhAhAkEAIQADQCACIABBA3RqIgNBADoAACADQYACNgIEIABBAWoiACABRw0ACwsLgAwBEn8jAEGQCGsiECQAQQEhBQJAIAAoAgQiB0EBSA0AIAAoAgAhCkEAIQUDQCAKIAFBAnRqKAIAKAIYDQEgAUEBaiIBIAdHDQALIAAoAgxFDQAgABBKQQBBAiAALwEUIAAvARJsIgcQFyEMAkACQCAAKAIAKAIAIgMuARRBf0oNACAAKAIMIgFFDQAgASgCACAALwEQIgRKDQELQYACIQQLIAcEQEEAIQEDQCAMIAFBAXRqIAQ7AQAgAUEBaiIBIAdHDQALC0EBIQUCQAJAIAAoAgQiBkEBSA0AQQEhCgNAAn9BAEEAQQEgAC8BFCAALwESbCIBEBciDUUNABogACADEC8aIAMQQyAMIQcgAy0AEkEDRgRAQQBBAEECIAEQFyIHRQ0BGiAHIAwgAUEBdBAYGgsgAC8BEiEEIAAvARQiAiADLwEOIgFrIAMvAQoiBSABIAVqIAJLGyIIQQFOBEAgBCADLwEMIgJrIAMvAQgiBSACIAVqIARLGyEFIAMuARQhCSADKAIAIQtBACEGA0AgBUEBTgRAIAcgBiABQf//A3FqIARsQQF0aiACQf//A3FBAXRqIQIgCyAGQQJ0aigCACEBQQAhBANAIAkgAS0AACIPRwRAIAIgDzsBAAsgAUEBaiEBIAJBAmohAiAEQQFqIgQgBUgNAAsgAC8BEiEECyAGQQFqIgYgCEgEQCADLwEMIQIgAy8BDiEBDAELCyAALwEUIQILQQAhBSAQQQBBhAgQGyEGAkACQCACIARsIgkEQCAHIQEDQCAGIAEvAQBBAnRqQQE2AgAgAUECaiEBIAVBAWoiBSAJRw0AC0EAIQFBfyECAkAgBigCgAhFDQADQAJAIAIgASAGIAFBAnRqKAIAGyECIAFB/gFLDQAgAUEBaiEBIAJBAEgNAQsLIAJBAEgNAiACIAAoAgwiASgCAEgNACABKAIQQQhBgAIQFyEBIAAoAgwiBSABNgIQIAFFDQIgBSACQQFqNgIAC0EAIQUgByEBQQAhCCANIQQDQCAEIAIgAS8BACIGIAZBgAJGIgYbOgAAQQEgBSAGGyEFIARBAWohBCABQQJqIQEgCEEBaiIIIAlHDQALDAILQX8hAgwBCyANEBZBAAwBCyADIAI7ARQCQAJAAkAgAy0AEkF+ag4CAAECCyAALwEUIgEgAy8BDiIHayADLwEKIgQgBCAHaiABSxshCSADLwEMIQEgAC8BEiEGIAMvAQghCAJAAkAgAkEQdEEQdUF/Sg0AIAAoAgAoAgAuARRBf0oNACAAKAIMIgRFDQAgBCgCACAALwEQIgRKDQELQYACIQQLIAlBAUgNASAGIAFrIAggASAIaiAGSxshC0EAIQgDQCALQQFOBEAgDCAHIAhqIAZB//8DcWxBAXRqIAFB//8DcUEBdGohAUEAIQIDQCABIAQ7AQAgAUECaiEBIAJBAWoiAiALSA0ACwsgCEEBaiIIIAlODQIgAy8BDCEBIAMvAQ4hByAALwESIQYMAAALAAsgBxAWCyADQQA2AgwgAyAALwESOwEIIAAvARQhByADIAU6ABIgAyAHOwEKIAMgDUEAEEIaIAoLIQUgDkEBaiIOIAAoAgQiBkgEQCAAKAIAIA5BAnRqKAIAIQMgBSEKDAELCyAFDQBBACEFDAELIAZBAUgNACAAKAIAIgcgBkF/aiIEQQJ0aiENQQAhAQNAAn8gASAERgRAIA0oAgAhA0EAIQIgAUEBagwBC0EAIQIgByABQQJ0aigCACEDAkAgByABQQFqIghBAnRqKAIAIgAuARQiCUEASA0AIAAvAQoiC0UNACADLgEUIQ4gAC8BCCEKIAMoAgAhDyAAKAIAIRFBACEAA0AgCgRAIBEgAEECdCICaigCACIBIApqIRIgAiAPaigCACECA0ACQCABLQAAIAlHDQAgAi0AACAORg0AQQIhAgwECyACQQFqIQIgAUEBaiIBIBJJDQALC0EAIQIgAEEBaiIAIAtHDQALCyAICyEBIAMgAjoAEiABIAZHDQALCyAMEBYLIBBBkAhqJAAgBQvCBAEIfyMAQSBrIgUkAAJAAkAgACgCPCIEKAIIQe8ATgRAIAQoAgQhBwwBC0G0ChAaIgdFDQEgBCgCBBAWIAQgBzYCBAsgBEHvADYCCCAEQdCTATYCAEHAkAJBwJACKAIAQQFqIgI2AgAgBEF/NgKYASAEIAI2AgwDQCAHIAZBDGxqIgJCADcCACACQQA2AggCQCAGQRRsQdCTAWoiAygCCEF/TARAIAUgBjYCACAAQeUIIAUQIhogAiACLwEAQcz/A3E7AQAMAQtBACEBIAMoAgAiCARAIAgtAABBAEchAQsgAiABOwEAIAIgAygCBCIIQQFOBH8gCEGAgMQAQYACIAQoAnwbSEEBdAVBAAsgAXJBEHIiATsBACACIAMvARBBA3RBIHEgAXIiATsBACACIAEgAy8BEEECdEEEcXIiATsBACACIAEgAy8BEEECdEEIcXIiATsBACACIAEgAy8BEEECdEHAAHFyIgE7AQAgAkEAOgACAkAgAygCDEEATARAIAIgAUHz/wNxIgE7AQAgAygCDEEBSA0BCyABQQhxDQAgAiABQQRyIgE7AQALAkAgAUEBcUUNACADKAIAQZoJQQMQRQ0AIAIgAUHP/wNxQSByOwEAIAJBAzoAAiADKAIAQQNqQZoJQQMQRQ0BIAUgBjYCECAAQZ4JIAVBEGoQIhoMAQsgAy0AEEEIcUUNACACIAFBz/8DcUEgcjsBAAsgBkEBaiIGQe8ARw0ACyAAQdCTASAHQe8AEJsBCyAFQSBqJAAL6xcBCX8jAEHAAmsiBCQAAkAgACAAKAIYEQAAQccARw0AIAAgACgCGBEAAEHJAEcNACAAIAAoAhgRAABBxgBHDQAgACAAKAIYEQAAGiAAIAAoAhgRAAAaIAAgACgCGBEAABoQvQEhBxCEASEFIAQgBzYCECAEQQBBAkGAIBAXIgY2AhQgBEEAQQFBgCAQFyIJNgIYQQBBAkGAIBAXIQggBCADNgI0IAQgCDYCHCAEIAU2AjAgBEIANwM4AkACQCAIRSAGRSAHRXIgBUUgCUVycnINACAHIAI2AiwgByAAIAAoAhgRAAAgACAAKAIYEQAAQQh0cjsBEiAHIAAgACgCGBEAACAAIAAoAhgRAABBCHRyOwEUIAAgACgCGBEAACECIAcgACAAKAIYEQAAOwEQIAAgACgCGBEAABoCQCACQYABcQRAQQIgAkEHcXQiAiACECwiCARAIAgoAhAhAwNAIAMgACAAKAIYEQAAOgABIAMgACAAKAIYEQAAOgACIAAgACgCGBEAACEGIANBADoAACADIAY6AAMgA0EIaiEDIAJBf2oiAg0ACyAHIAg2AgwgCEEBNgIMDAILIAdBADYCDAwCCyAHQYACOwEQCyAAIAAoAiARAAANAANAAkACQAJAAkACQCAAIAAoAhgRAAAiAkFfag4bAQICAgICAgICAgIAAgICAgICAgICAgICAgIGAgsgBUHYkgIoAgA2AhxB2JICQQA2AgAgByAFEKsBRQ0FIAUgACAAKAIYEQAAIAAgACgCGBEAAEEIdHI7AQwgBSAAIAAoAhgRAAAgACAAKAIYEQAAQQh0cjsBDiAFIAAgACgCGBEAACAAIAAoAhgRAABBCHRyOwEIIAUgACAAKAIYEQAAIAAgACgCGBEAAEEIdHIiAjsBCiAFLwEIIgNFBEAgBSAEKAIQLwESIgM7AQgLIAJFBEAgBSAEKAIQLwEUIgI7AQoLAn8gA0H//wNxBEAgASACQf//A3ENARoLIAQgBCgCPEEBajYCPCAEKAI0IgJB1JICKAIAIAIbIgIEQCAEKAIQIAQoAjBBAUHNEyACEQYACyAFEHogBS8BCCEDQQALIQgCQCAFLwEMIANB//8DcWpB//8DTQRAIAUvAQogBS8BDmpBgIAESQ0BCyAEIAQoAjxBAWo2AjwgBCgCNCICQdSSAigCACACGyICBEAgBCgCECAEKAIwQQFB8BMgAhEGAAsgBRB6QQAhCAsCQAJAIAAgACgCGBEAACIJQYABcQRAQQIgCUEHcXQiAiACECwiBkUNASAGKAIQIQMDQCADIAAgACgCGBEAADoAASADIAAgACgCGBEAADoAAiAAIAAoAhgRAAAhCyADQQA6AAAgAyALOgADIANBCGohAyACQX9qIgINAAsgBSAGNgIYIAZBATYCDAsgBSAJQQZ2QQFxOgATIAhBAXEEQAJAIAAoAhAEQCAAIAAoAggiBkEBaiIDNgIIIAAoAgwhAgNAIAMgAkkEQCAAIAMgACgCBCADai0AACIJakEBaiIDNgIIIAkNAQsLIAMgAksEQCAAIAI2AgggAiEDCyAFQQA2AjAgBSADIAZrIgI2AiwgCEEEcQRAIAAoAgQhAiAFQQA2AjggBSACIAZqNgI0DAILQQBBASACEBchAiAFQQY2AjggBSACNgI0IAJFDQQgAiAAKAIEIAZqIAUoAiwQGBoMAQtBAEEBQYAIEBciBkUNAyAGIAAgACgCGBEAADoAAEGACCEJQQEhAyAAIAAoAhgRAAAiAgRAA0AgAyACQf8BcSILaiIMQQJqIAlLBEAgBkEBIAlBAXQiCRAXIgZFDQYLIAMgBmoiAyACOgAAIANBAWogCyAAIAAoAhwRAwAaIAxBAWohAyAAIAAoAhgRAAAiAg0ACwsgAyAGakEAOgAAIAVBBjYCOCAFIAY2AjQgBUEANgIwIAUgA0EBajYCLAsgCEECcUUNBSAFKAI0IQIgBSgCLCEDIARBBzYCYCAEQQg2AlwgBEEJNgJYIARBATYCUCAEIAM2AkwgBEEANgJIIAQgAjYCRCAEQRBqIAUgBEFAaxB4RQ0CDAULIAhBAnEEQCAEQRBqIAUgABB4DQUMAgsgACAAKAIYEQAAIgNFDQQDQCAEQUBrIANB/wFxIAAgACgCHBEDABogACAAKAIYEQAAIgMNAAsMBAsgBUEANgIYCyAHIAcoAgRBf2oQigJBACEFDAYLAkACQAJAAkACQCAAIAAoAhgRAAAiAkGHfmoOBwAEBAQEAgMBCwJAAkACQCAAIAAoAhgRAAAiAg4FAgEBAQABCyAFIAAgACgCGBEAACICQQJ2QQdxOgASIAUgACAAKAIYEQAAIAAgACgCGBEAAEEIdHI7ARAgBSAAIAAoAhgRAABBfyACQQFxGzsBFAwBCyAEIAQoAjxBAWo2AjwgBCgCNCIDQdSSAigCACADGyIDBEAgBCgCECAEKAIwQQFBnhQgAxEGAAsgBEFAayACIAAgACgCHBEDABoLIAAgACgCGBEAACIDRQ0GA0AgBCAEKAI8QQFqNgI8IAQoAjQiAkHUkgIoAgAgAhsiAgRAIAQoAhAgBCgCMEEBQZ4UIAIRBgALIARBQGsgA0H/AXEgACAAKAIcEQMAGiAAIAAoAhgRAAAiAw0ACwwGCyACQc4BRw0CQdiSAigCACEDQQAhAiAAIAAoAhgRAAAiBgRAA0AgA0EBIAIgBkH/AXEiBmoiCEEBahAXIgNFBEBB2JICQQA2AgAMCAsgAiADaiAGIAAgACgCHBEDABogAyAIakEAOgAAIAghAiAAIAAoAhgRAAAiBg0ACwtB2JICIAM2AgAMBQsgBSgCICEGQQAhAkEAIQMgACAAKAIYEQAAIglFDQQDQCADQQEgAiAJQf8BcSIJaiIIQQFqEBciA0UNBSACIANqIAkgACAAKAIcEQMAGiADIAhqQQA6AAAgCCECIAAgACgCGBEAACIJDQALIAZFBEAgBRBGIgY2AiAgBkUNBwsgBiADIAIQfQ0EDAYLIAQoAhAhCCAEQUBrIAAgACgCGBEAACICIAAgACgCHBEDABoCQCACQQtHDQAgBEFAa0G0FEELED0EQCAEQUBrQcAUQQsQPQ0BCwJAIAAgACgCGBEAACIDQQNGBEAgACAAKAIYEQAAGiAIIAAgACgCGBEAACAAIAAoAhgRAABBCHRyNgIYIAAgACgCGBEAACIDRQ0GIAQgBCgCPEEBajYCPCAEKAI0IgJB1JICKAIAIAIbIgJFDQEgBCgCECAEKAIwQQFBzBQgAhEGAAwBCyAEIAQoAjxBAWo2AjwgBCgCNCICQdSSAigCACACGyICBEAgBCgCECAEKAIwQQFBzBQgAhEGAAsgA0UNBQsDQCAEQUBrIANB/wFxIAAgACgCHBEDABogACAAKAIYEQAAIgMNAAsMBAsgBEEQaiAAQf8BIARBQGsgAhChAQwDCyAEQRBqIAAgAkEAQQAQoQEMAgsgCkUEQCAAKAIIIQMgBCACNgIAIAQgA0F/ajYCBCAEQUBrQYITIAQQPiAEIAQoAjxBAWo2AjwgBCgCNCICQdSSAigCACACGyICBEAgBCgCECAEKAIwQQEgBEFAayACEQYAC0EBIQoMAgsgCkETSg0DIApBAWohCgwBCyAEEIQBIgU2AjAgBQ0AQQAhBQwDCyAAIAAoAiARAABFDQALCyAHRSAFRXINACAHIAUoAiA2AhwgBUEANgIgIAcgBSgCJDYCICAFQQA2AiQgBygCICIDRQ0AA0AgA0EANgIcIAMoAiAiAw0ACwsgBRBLQdiSAigCABAWIAQoAhQQFiAEKAIYEBYgBCgCHBAWQdiSAkEANgIAIARBADYCMAJAIAdFDQAgByAEKAI8NgIkIAQoAjwgAUEIcXINACAAIAAoAiARAAANACAEIAQoAjhBAWo2AjggBCgCNCIAQdSSAigCACAAGyIARQ0AIAQoAhAgBCgCMEEAQaoTIAARBgALIAQoAjQiAEHUkgIoAgAgABsiAEUNACAEKAIQIAQoAjBBf0EAIAARBgALIARBwAJqJAAgBwsvAQF/AkAgACgCABBPIgFBf0YEQEEAIQEMAQsgACAAKAIIQQFqNgIICyABQf8BcQs2AQF/IAAgASACKAIAEKoCIgMgAUkEQCAAIANqQQAgASADaxAbGgsgAiACKAIIIANqNgIIIAMLIQEBfyAAKAIAEE8iAUF/RgRAQQEPCyABIAAoAgAQZkEACywBAn8gACgCCCIBIAAoAgxJBH8gACABQQFqNgIIIAAoAgQgAWotAAAFQQALC1QBAX8gACACKAIIIgAgAigCBGogAigCDCIDIABrIAEgACABaiADSxsiABAYIQMgAiACKAIIIABqNgIIIAAgAUkEQCAAIANqQQAgASAAaxAbGgsgAAsNACAAKAIIIAAoAgxGC4ABAQF/IwBBEGsiAyQAAkACQCABLQAAIgQEQCAEEDVFDQELIAMgATYCDAwBCyAAIAEgA0EMahBNOQMQIAEtAAAhBAsCQAJAIARFDQAgAygCDC0AAA0AQQEhBAwBC0EAIQQgAkUNACADIAE2AgAgAEGxDSADECIaCyADQRBqJAAgBAtrAQR/IAAoAgQhAgJAAkAgAQRAIAJBAUgNAiAAKAIAIQRBACEAA0AgBCAAQQJ0aigCACIDKAIcIgUEQCAFIAEQHUUNAwsgAEEBaiIAIAJIDQALDAILIAJFDQEgACgCACgCACEDCyADDwtBAAsqAQF/AkAgAUEASA0AIAAoAgQgAUwNACAAKAIAIAFBAnRqKAIAIQILIAILxAEBBH8gAkEASCAAKAIAIgMgAkxyRQRAIAAoAhAhBSABLQABIQYDQAJAIAUgAkEDdGoiBC0AASAGRw0AIAQtAAIgAS0AAkcNACAELQADIAEtAANHDQAPCyACQQFqIgIgA0gNAAsLAkAgAyAAKAIEIgJIBEAgACgCECECDAELIAAgAkEBdCICNgIEIAAgACgCEEEIIAIQFyICNgIQIAJFBEAPCyAAKAIAIQMLIAAgA0EBajYCACACIANBA3RqIAEpAgA3AgALlwcBBH8jAEEQayIEJAACQAJAIAEQHEEFSw0AIAFBPRAyDQAgAS0AACIDBEADQCAEQQpqIAZqIANB/wFxIgNBIHIgAyADQb9/akEaSRs6AAAgASAGQQFqIgZqLQAAIgMNAAsLIARBCmogBmpBADoAAAJ/IAQtAAoiBkH5AEcEQEHaDSEFIAYhAyAEQQpqDAELIAQtAAsiA0HlAEcEQEHbDSEFIARBC2oMAQsgBC0ADCIDQfMARwRAQdwNIQUgBEEMagwBC0HdDSEFIAQtAA0hAyAEQQ1qCyEHAkACQCAFQdoNa0EBSCADQf8BcSIDQT1HQQAgAxtyRUEAIAcgBEEKamtBAEobDQACfyAGQfQARwRAQd4NIQUgBiEDIARBCmoMAQsgBC0ACyIDQfIARwRAQd8NIQUgBEELagwBCyAELQAMIgNB9QBHBEBB4A0hBSAEQQxqDAELIAQtAA0iA0HlAEcEQEHhDSEFIARBDWoMAQtB4g0hBSAELQAOIQMgBEEOagshByAFQd4Na0EBSCADQf8BcSIDQT1HQQAgAxtyRUEAIAcgBEEKamtBAEobDQAgBC0ACyAGIAZBMUYiAxtB/wFxIgVBPUdBACAFGyAGQTFHIARBC2oiByAEQQpqIAMbIARBCmprQQFIcnINAQtBASEGIABBATYCEAwCCwJAAn8gBkHuAEcEQCAEQQpqIQUgBiEDQeMNDAELIAQtAAsiA0HvAEcEQCAEQQtqIQVB5A0MAQsgBEEMaiEFIAQtAAwhA0HlDQtB4w1rQQFIIANB/wFxIgNBPUdBACADG3JFQQAgBSAEQQpqa0EAShsNAAJ/IAZB5gBHBEAgBEEKaiEFIAYhA0HmDQwBCyAELQALIgNB4QBHBEAgBEELaiEFQecNDAELIAQtAAwiA0HsAEcEQCAEQQxqIQVB6A0MAQsgBC0ADSIDQfMARwRAIARBDWohBUHpDQwBCyAELQAOIgNB5QBHBEAgBEEOaiEFQeoNDAELIARBD2ohBSAELQAPIQNB6w0LQeYNa0EBSCADQf8BcSIDQT1HQQAgAxtyRUEAIAUgBEEKamtBAEobDQAgBC0ACyAGIAZBMUYiAxtB/wFxIgVBPUdBACAFGyAGQTFHIAcgBEEKaiADGyAEQQpqa0EBSHJyDQELIABBADYCEEEBIQYMAQtBACEGIAJFDQAgBCABNgIAIABB7A0gBBAiGgsgBEEQaiQAIAYL7wYBB38gAARAAkBBAEHMAEEBEBciAQR/IAFCADcCACABQgA3AhggAUEANgI8IAFB//8DOwEUIAFBADYCSCABQgA3AkAgAUEGNgIoIAFCADcCICABQgA3AiwgAUIANwIIIAFBADYCECABQgA3AjQCQAJAIAAoAhwiAkUNAEEAQQEgAhAcQQFqIgQQFyIDRQ0AIAEgAyACIAQQGDYCHAwBCyABQQA2AhwgACgCHA0CCwJAIAAoAiBFDQBBAEEQQQEQFyIERQRAIAFBADYCIAwDCyAEQgA3AgAgBEIANwIIIAEgBDYCICAAKAIgIgIoAghBAUgNAEEAIQMDQCADQQJ0IgYgAigCAGooAgAhBUEAQQECfyACKAIEIAZqKAIAIgJBf0wEQCAFEBwhAgsgAgsQFyIGRQ0DIAQgBiAFIAIQGCIEIAIQfQRAIANBAWoiAyAAKAIgIgIoAghODQIgASgCICEEDAELCyAEEBYMAgsgACgCJCIFBEAgAUEkaiEEA0AgBRCxASIGRQ0DAkAgBigCGA0AIAQhAiAGKAIcDQADQCACIgMoAgAiB0EgaiECIAcNAAsgAyAGNgIAIAZBADYCICAGIAE2AhwgBkEANgIYCyAFKAIgIgUNAAsLIAEgACgCGBB7IgI2AhggAkUEQCAAKAIYDQILIAEgAC8BFDsBFCABIAAvARA7ARAgASAALQASOgASIAEgAC8BDDsBDCABIAAvAQ47AQ4gASAALwEIOwEIIAEgAC8BCiICOwEKIAEgAC0AEzoAEyAAKAIABEAgAUEAQQQgAkEBahAXNgIAQQBBASABLwEKIAEvAQhsEBchAyABQQY2AiggASADNgIEIANFDQIgASgCACICRQ0CQQAhBSABLwEKBEAgAS8BCCEEQQAhAgNAIAMgAkECdCIFIAAoAgBqKAIAIARB//8DcRAYIQMgASgCACAFaiADNgIAIAMgAS8BCCIEaiEDIAJBAWoiAiABLwEKIgVJDQALIAEoAgAhAgsgAiAFQQJ0akEANgIACyAAKAI0IgIEQAJAIAAoAjhFBEAgASACNgI0DAELQQBBASAAKAIsEBchAiABQQY2AjggASACNgI0IAIgACgCNCAAKAIsEBgaCyABIAAoAiw2AiwgASAAKAIwNgIwCyABBUEACw8LIAEQSwtBAAu3AQEDfyMAQRBrIgQkAAJAAkACQCABLQAAIgVFDQAgBRA1DQAgA0EBcSIGRSAFQS1Hcg0BCyAEIAE2AgwMAQsgBgRAIAAgASAEQQxqQQBC/////w8QrgE+AhAMAQsgACABIARBDGpBABAkNgIQCwJAAkAgAS0AAEUNACAEKAIMLQAADQBBASEFDAELQQAhBSACRQ0AIAQgATYCACAAQdoMQYsNIANBAXEbIAQQIhoLIARBEGokACAFCzIBAX9BgAIhAQJAIAAoAjQiAEUNACAALQAAIgBBf2pB/wFxQQZLDQBBASAAdCEBCyABCwkAIAEgABEEAAvMCQMFfwF+BHwjAEEwayIEJAACQAJAAkAgAL0iB0IgiKciAkH/////B3EiA0H61L2ABE0EQCACQf//P3FB+8MkRg0BIANB/LKLgARNBEAgB0IAWQRAIAEgAEQAAEBU+yH5v6AiAEQxY2IaYbTQvaAiCDkDACABIAAgCKFEMWNiGmG00L2gOQMIQQEhAgwFCyABIABEAABAVPsh+T+gIgBEMWNiGmG00D2gIgg5AwAgASAAIAihRDFjYhphtNA9oDkDCEF/IQIMBAsgB0IAWQRAIAEgAEQAAEBU+yEJwKAiAEQxY2IaYbTgvaAiCDkDACABIAAgCKFEMWNiGmG04L2gOQMIQQIhAgwECyABIABEAABAVPshCUCgIgBEMWNiGmG04D2gIgg5AwAgASAAIAihRDFjYhphtOA9oDkDCEF+IQIMAwsgA0G7jPGABE0EQCADQbz714AETQRAIANB/LLLgARGDQIgB0IAWQRAIAEgAEQAADB/fNkSwKAiAETKlJOnkQ7pvaAiCDkDACABIAAgCKFEypSTp5EO6b2gOQMIQQMhAgwFCyABIABEAAAwf3zZEkCgIgBEypSTp5EO6T2gIgg5AwAgASAAIAihRMqUk6eRDuk9oDkDCEF9IQIMBAsgA0H7w+SABEYNASAHQgBZBEAgASAARAAAQFT7IRnAoCIARDFjYhphtPC9oCIIOQMAIAEgACAIoUQxY2IaYbTwvaA5AwhBBCECDAQLIAEgAEQAAEBU+yEZQKAiAEQxY2IaYbTwPaAiCDkDACABIAAgCKFEMWNiGmG08D2gOQMIQXwhAgwDCyADQfrD5IkESw0BCyABIAAgAESDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIJRAAAQFT7Ifm/oqAiCCAJRDFjYhphtNA9oiILoSIAOQMAIANBFHYiBSAAvUI0iKdB/w9xa0ERSCEDAn8gCZlEAAAAAAAA4EFjBEAgCaoMAQtBgICAgHgLIQICQCADDQAgASAIIAlEAABgGmG00D2iIgChIgogCURzcAMuihmjO6IgCCAKoSAAoaEiC6EiADkDACAFIAC9QjSIp0H/D3FrQTJIBEAgCiEIDAELIAEgCiAJRAAAAC6KGaM7oiIAoSIIIAlEwUkgJZqDezmiIAogCKEgAKGhIguhIgA5AwALIAEgCCAAoSALoTkDCAwBCyADQYCAwP8HTwRAIAEgACAAoSIAOQMAIAEgADkDCEEAIQIMAQsgB0L/////////B4NCgICAgICAgLDBAIS/IQBBACECQQEhBQNAIARBEGogAkEDdGoCfyAAmUQAAAAAAADgQWMEQCAAqgwBC0GAgICAeAu3Igg5AwAgACAIoUQAAAAAAABwQaIhAEEBIQIgBUEBcSEGQQAhBSAGDQALIAQgADkDIAJAIABEAAAAAAAAAABiBEBBAiECDAELQQEhBQNAIAUiAkF/aiEFIARBEGogAkEDdGorAwBEAAAAAAAAAABhDQALCyAEQRBqIAQgA0EUdkHqd2ogAkEBahCHAiECIAQrAwAhACAHQn9XBEAgASAAmjkDACABIAQrAwiaOQMIQQAgAmshAgwBCyABIAA5AwAgASAEKQMINwMICyAEQTBqJAAgAgufDgIRfwJ8IwBBsARrIgYkACACIAJBfWpBGG0iBEEAIARBAEobIg5BaGxqIQdBpPIBKAIAIgogA0F/aiIIakEATgRAIAMgCmohBCAOIAhrIQIDQCAGQcACaiAFQQN0aiACQQBIBHxEAAAAAAAAAAAFIAJBAnRBsPIBaigCALcLOQMAIAJBAWohAiAFQQFqIgUgBEcNAAsLIAdBaGohC0EAIQQgCkEAIApBAEobIQ0gA0EBSCEFA0ACQCAFBEBEAAAAAAAAAAAhFQwBCyAEIAhqIQlBACECRAAAAAAAAAAAIRUDQCAVIAAgAkEDdGorAwAgBkHAAmogCSACa0EDdGorAwCioCEVIAJBAWoiAiADRw0ACwsgBiAEQQN0aiAVOQMAIAQgDUYhAiAEQQFqIQQgAkUNAAtBLyAHayERQTAgB2shDyAHQWdqIRIgCiEEAkADQCAGIARBA3RqKwMAIRVBACECIAQhBSAEQQFIIgxFBEADQCAGQeADaiACQQJ0agJ/IBUCfyAVRAAAAAAAAHA+oiIVmUQAAAAAAADgQWMEQCAVqgwBC0GAgICAeAu3IhVEAAAAAAAAcMGioCIWmUQAAAAAAADgQWMEQCAWqgwBC0GAgICAeAs2AgAgBiAFQX9qIgVBA3RqKwMAIBWgIRUgAkEBaiICIARHDQALCwJ/IBUgCxBBIhUgFUQAAAAAAADAP6KcRAAAAAAAACDAoqAiFZlEAAAAAAAA4EFjBEAgFaoMAQtBgICAgHgLIQggFSAIt6EhFQJAAkACQAJ/IAtBAUgiE0UEQCAEQQJ0IAZqIgIgAigC3AMiAiACIA91IgIgD3RrIgU2AtwDIAIgCGohCCAFIBF1DAELIAsNASAEQQJ0IAZqKALcA0EXdQsiCUEBSA0CDAELQQIhCSAVRAAAAAAAAOA/ZkEBc0UNAEEAIQkMAQtBACECQQAhBSAMRQRAA0AgBkHgA2ogAkECdGoiFCgCACEMQf///wchEAJ/AkAgBQ0AQYCAgAghECAMDQBBAAwBCyAUIBAgDGs2AgBBAQshBSACQQFqIgIgBEcNAAsLAkAgEw0AAkACQCASDgIAAQILIARBAnQgBmoiAiACKALcA0H///8DcTYC3AMMAQsgBEECdCAGaiICIAIoAtwDQf///wFxNgLcAwsgCEEBaiEIIAlBAkcNAEQAAAAAAADwPyAVoSEVQQIhCSAFRQ0AIBVEAAAAAAAA8D8gCxBBoSEVCyAVRAAAAAAAAAAAYQRAQQAhBQJAIAQiAiAKTA0AA0AgBkHgA2ogAkF/aiICQQJ0aigCACAFciEFIAIgCkoNAAsgBUUNACALIQcDQCAHQWhqIQcgBkHgA2ogBEF/aiIEQQJ0aigCAEUNAAsMAwtBASECA0AgAiIFQQFqIQIgBkHgA2ogCiAFa0ECdGooAgBFDQALIAQgBWohBQNAIAZBwAJqIAMgBGoiCEEDdGogBEEBaiIEIA5qQQJ0QbDyAWooAgC3OQMAQQAhAkQAAAAAAAAAACEVIANBAU4EQANAIBUgACACQQN0aisDACAGQcACaiAIIAJrQQN0aisDAKKgIRUgAkEBaiICIANHDQALCyAGIARBA3RqIBU5AwAgBCAFSA0ACyAFIQQMAQsLAkAgFUEAIAtrEEEiFUQAAAAAAABwQWZBAXNFBEAgBkHgA2ogBEECdGoCfyAVAn8gFUQAAAAAAABwPqIiFZlEAAAAAAAA4EFjBEAgFaoMAQtBgICAgHgLIgK3RAAAAAAAAHDBoqAiFZlEAAAAAAAA4EFjBEAgFaoMAQtBgICAgHgLNgIAIARBAWohBAwBCwJ/IBWZRAAAAAAAAOBBYwRAIBWqDAELQYCAgIB4CyECIAshBwsgBkHgA2ogBEECdGogAjYCAAtEAAAAAAAA8D8gBxBBIRUgBEEATgRAIAQhAgNAIAYgAkEDdGogFSAGQeADaiACQQJ0aigCALeiOQMAIBVEAAAAAAAAcD6iIRVBACEAIAJBAEohAyACQX9qIQIgAw0ACyAEIQUDQCANIAAgDSAASRshA0EAIQJEAAAAAAAAAAAhFQNAIBUgAkEDdEGAiAJqKwMAIAYgAiAFakEDdGorAwCioCEVIAIgA0chByACQQFqIQIgBw0ACyAGQaABaiAEIAVrQQN0aiAVOQMAIAVBf2ohBSAAIARHIQIgAEEBaiEAIAINAAsLRAAAAAAAAAAAIRUgBEEATgRAIAQhAgNAIBUgBkGgAWogAkEDdGorAwCgIRUgAkEASiEAIAJBf2ohAiAADQALCyABIBWaIBUgCRs5AwAgBisDoAEgFaEhFUEBIQIgBEEBTgRAA0AgFSAGQaABaiACQQN0aisDAKAhFSACIARHIQAgAkEBaiECIAANAAsLIAEgFZogFSAJGzkDCCAGQbAEaiQAIAhBB3ELfgEFf0HQCBAcIQECQAJAQcytAigCAEUNAEHQCC0AAEUNAEHQCEE9EDINAEHMrQIoAgAiAigCACIARQ0AA0BB0AggACABEEVFBEAgACABaiIDLQAAQT1GDQMLIAIgBEEBaiIEQQJ0aigCACIADQALC0EADwsgA0EBakEAIAAbC4wBAQN/IwBBEGsiACQAAkAgAEEMaiAAQQhqEBANAEHMrQIgACgCDEECdEEEahAaIgE2AgAgAUUNAAJAIAAoAggQGiIBBEBBzK0CKAIAIgINAQtBzK0CQQA2AgAMAQsgAiAAKAIMQQJ0akEANgIAQcytAigCACABEA9FDQBBzK0CQQA2AgALIABBEGokAAtpAQJ/AkAgAUEASA0AIAAoAgQgAUwNACAAKAIAIAFBAnRqKAIAEEsgACgCBEF/aiICIAFKBEADQCAAKAIAIgMgAUECdGogAyABQQFqIgFBAnRqKAIANgIAIAEgAkgNAAsLIAAgAjYCBAsLkwEBBX8jAEEQayIBJAACQAJAAkAgABAcIgJBBkkNACAAIAJqQXpqIgRBkPIBQQYQPQ0AQeQAIQIDQCAEEI0CIQUgAUGAAzYCACAAIAEQjAIiA0F/Sg0DIAJBf2oiAgRAQdycAigCAEEURg0BCwsgBUGQ8gFBBhAYGgwBC0HcnAJBHDYCAAtBfyEDCyABQRBqJAAgAws4AQF/IwBBEGsiAiQAIAIgAUEEajYCDCACIAEoAgA2AgAgAEHCgQIgAhAEEFohACACQRBqJAAgAAtoAQN/IwBBEGsiASQAQQAgAUEIahASGiABQQhqQQR2IABqIAEoAgxBgYAEbHMhAgNAIAAgA2ogAkEPcSACQQF0QSBxckHBAGo6AAAgAkEFdiECIANBAWoiA0EGRw0ACyABQRBqJAAgAAvGBgEOfyMAQaAIayIJJAAgCUGYCGpCADcDACAJQZAIakIANwMAIAlCADcDiAggCUIANwOACAJAAkACQAJAAkAgAS0AACICRQRAQX8hCkEBIQMMAQsDQCAAIAVqLQAARQ0EIAkgAkH/AXEiA0ECdGogBUEBaiIFNgIAIAlBgAhqIANBA3ZBHHFqIgMgAygCAEEBIAJBH3F0cjYCACABIAVqLQAAIgINAAtBASEDQX8hCiAFQQFLDQELQX8hBkEBIQcMAQtBASEIQQEhAgNAAn8gASACIApqai0AACIGIAEgA2otAAAiB0YEQCACIAhGBEAgBCAIaiEEQQEMAgsgAkEBagwBCyAGIAdLBEAgAyAKayEIIAMhBEEBDAELIAQiCkEBaiEEQQEhCEEBCyICIARqIgMgBUkNAAtBfyEGQQAhBEEBIQNBASEHQQEhAgNAAn8gASACIAZqai0AACIMIAEgA2otAAAiC0YEQCACIAdGBEAgBCAHaiEEQQEMAgsgAkEBagwBCyAMIAtJBEAgAyAGayEHIAMhBEEBDAELIAQiBkEBaiEEQQEhB0EBCyICIARqIgMgBUkNAAsgCCEDCwJ/IAEgASAHIAMgBkEBaiAKQQFqSyICGyIIaiAGIAogAhsiC0EBaiIHED0EQCAFIAsgBSALQX9zaiICIAsgAksbQQFqIghrIQ1BAAwBCyAFIAhrIg0LIQwgBUF/aiEPIAVBP3IhDkEAIQYgACEDA0ACQCAAIANrIAVPDQAgAEEAIA4QaiICBEAgAiIAIANrIAVJDQMMAQsgACAOaiEACwJ/An8gBSAJQYAIaiADIA9qLQAAIgJBA3ZBHHFqKAIAIAJBH3F2QQFxRQ0AGiAFIAkgAkECdGooAgBrIgIEQCANIAIgAiAISRsgAiAGGyACIAwbDAELAkAgASAHIgIgBiACIAZLGyIEai0AACIKBEADQCADIARqLQAAIApB/wFxRw0CIAEgBEEBaiIEai0AACIKDQALCwNAIAIgBk0NBiABIAJBf2oiAmotAAAgAiADai0AAEYNAAsgCCECIAwMAgsgBCALawshAkEACyEGIAIgA2ohAwwAAAsAC0EAIQMLIAlBoAhqJAAgAwuqAQEEfyAAQQNqIQMgAC0AAyICQQBHIQQCQCACRSAALQABQRB0IAAtAABBGHRyIAAtAAJBCHRyIAJyIgIgASgAACIAQRh0IABBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnIiBUZyRQRAA0AgA0EBaiEAIAMtAAEiAUEARyEEIAJBCHQgAXIiAiAFRg0CIAAhAyABDQAMAgALAAsgAyEACyAAQX1qQQAgBBsLlgEBA38gAEECaiEFIAAtAAIiBEEARyEGAkAgBEUgAC0AAUEQdCAALQAAQRh0ciAEQQh0ciIEIAJB/wFxQRB0IAFBGHRyIANB/wFxQQh0ciICRnJFBEADQCAFQQFqIQAgBS0AASIBQQBHIQYgASAEckEIdCIEIAJGDQIgACEFIAENAAwCAAsACyAFIQALIABBfmpBACAGGwt5AQN/IAAtAAEiA0EARyEEAkAgA0UNACAALQAAQQh0IANyIgMgAkH/AXEgAUH/AXFBCHRyIgVGDQAgAEEBaiEBA0AgASIALQABIgJBAEchBCACRQ0BIABBAWohASADQQh0QYD+A3EgAnIiAyAFRw0ACwsgAEEAIAQbCyYBAX8DQCABRQRAQQAPCyAAIAFBf2oiAWoiAi0AAEEvRw0ACyACC/YBAQJ/QYACIQICQAJAAkAgACABc0EDcQ0AQQEhAwJAIAFBA3FFDQADQCAAIAEtAAAiAzoAACADRQ0EIABBAWohACABQQFqIQEgAkF/aiICQQBHIQMgAkUNASABQQNxDQALCyADRQ0BIAEtAABFDQIgAkEESQ0AA0AgASgCACIDQX9zIANB//37d2pxQYCBgoR4cQ0BIAAgAzYCACAAQQRqIQAgAUEEaiEBIAJBfGoiAkEDSw0ACwsgAkUNAANAIAAgAS0AACIDOgAAIANFDQIgAEEBaiEAIAFBAWohASACQX9qIgINAAsLQQAhAgsgAEEAIAIQGxoLyAEBAX8CQAJAIAAgAXNBA3ENACABQQNxBEADQCAAIAEtAAAiAjoAACACRQ0DIABBAWohACABQQFqIgFBA3ENAAsLIAEoAgAiAkF/cyACQf/9+3dqcUGAgYKEeHENAANAIAAgAjYCACABKAIEIQIgAEEEaiEAIAFBBGohASACQf/9+3dqIAJBf3NxQYCBgoR4cUUNAAsLIAAgAS0AACICOgAAIAJFDQADQCAAIAEtAAEiAjoAASAAQQFqIQAgAUEBaiEBIAINAAsLC9kBAQJ/AkAgAUH/AXEiAwRAIABBA3EEQANAIAAtAAAiAkUgAiABQf8BcUZyDQMgAEEBaiIAQQNxDQALCwJAIAAoAgAiAkF/cyACQf/9+3dqcUGAgYKEeHENACADQYGChAhsIQMDQCACIANzIgJBf3MgAkH//ft3anFBgIGChHhxDQEgACgCBCECIABBBGohACACQf/9+3dqIAJBf3NxQYCBgoR4cUUNAAsLA0AgACICLQAAIgMEQCACQQFqIQAgAyABQf8BcUcNAQsLIAIPCyAAEBwgAGoPCyAAC50BAgF/A34jAEGgAWsiAyQAIANBEGpBAEGQARAbGiADQX82AlwgAyABNgI8IANBfzYCGCADIAE2AhQgA0EQakIAEDQgAyADQRBqQQFBARC0ASADKQMIIQQgAykDACEFIAIEQCACIAEgASADKQOIASADKAIUIAMoAhhrrHwiBqdqIAZQGzYCAAsgACAFNwMAIAAgBDcDCCADQaABaiQACwsAIAAgASACEJgCC1MBAn8gASAAKAJUIgEgAUEAIAJBgAJqIgMQaiIEIAFrIAMgBBsiAyACIAMgAkkbIgIQGBogACABIANqIgM2AlQgACADNgIIIAAgASACajYCBCACCzABAX8jAEEQayICIAA2AgwgAiAAIAFBAnQgAUEAR0ECdGtqIgBBBGo2AgggACgCAAvwEgINfwN+IwBBsAJrIgUkACAAKAJMQQBOBH9BAQVBAAsaAkAgAS0AACIDRQ0AAkACQANAAkACQCADQf8BcSIDEDUEQANAIAEiA0EBaiEBIAMtAAEQNQ0ACyAAQgAQNANAAn8gACgCBCIBIAAoAmhJBEAgACABQQFqNgIEIAEtAAAMAQsgABAfCxA1DQALAkAgACgCaEUEQCAAKAIEIQEMAQsgACAAKAIEQX9qIgE2AgQLIAEgACgCCGusIAApA3ggEHx8IRAMAQsCfwJAAkAgA0ElRgRAIAEtAAEiBEEqRg0BIARBJUcNAgsgAEIAEDQgASADQSVGaiEDAn8gACgCBCIBIAAoAmhJBEAgACABQQFqNgIEIAEtAAAMAQsgABAfCyIBIAMtAABHBEAgACgCaARAIAAgACgCBEF/ajYCBAtBACEMIAFBAE4NCQwHCyAQQgF8IRAMAwtBACEIIAFBAmoMAQsCQCAEEERFDQAgAS0AAkEkRw0AIAIgBEFQahCZAiEIIAFBA2oMAQsgAigCACEIIAJBBGohAiABQQFqCyEDQQAhDEEAIQkgAy0AACIBEEQEQANAIAlBCmwgAUH/AXFqQVBqIQkgAy0AASEBIANBAWohAyABEEQNAAsLIAFB7QBHBH8gAwVBACEKIAhBAEchDCADLQABIQFBACEGIANBAWoLIgRBAWohA0EDIQcCQAJAAkACQAJAAkAgAUH/AXFBv39qDjoECQQJBAQECQkJCQMJCQkJCQkECQkJCQQJCQQJCQkJCQQJBAQEBAQABAUJAQkEBAQJCQQCBAkJBAkCCQsgBEECaiADIAQtAAFB6ABGIgEbIQNBfkF/IAEbIQcMBAsgBEECaiADIAQtAAFB7ABGIgEbIQNBA0EBIAEbIQcMAwtBASEHDAILQQIhBwwBC0EAIQcgBCEDC0EBIAcgAy0AACIEQS9xQQNGIgEbIQ0CQCAEQSByIAQgARsiC0HbAEYNAAJAIAtB7gBHBEAgC0HjAEcNASAJQQEgCUEBShshCQwCCyAIIA0gEBCyAQwCCyAAQgAQNANAAn8gACgCBCIBIAAoAmhJBEAgACABQQFqNgIEIAEtAAAMAQsgABAfCxA1DQALAkAgACgCaEUEQCAAKAIEIQEMAQsgACAAKAIEQX9qIgE2AgQLIAEgACgCCGusIAApA3ggEHx8IRALIAAgCawiEhA0AkAgACgCBCIEIAAoAmgiAUkEQCAAIARBAWo2AgQMAQsgABAfQQBIDQQgACgCaCEBCyABBEAgACAAKAIEQX9qNgIEC0EQIQECQAJAAkACQAJAAkACQAJAAkACQAJAAkAgC0Gof2oOIQYLCwILCwsLCwELAgQBAQELBQsLCwsLAwYLCwILBAsLBgALIAtBv39qIgFBBktBASABdEHxAHFFcg0KCyAFIAAgDUEAELQBIAApA3hCACAAKAIEIAAoAghrrH1RDQ4gCEUNCSAFKQMIIRIgBSkDACERIA0OAwUGBwkLIAtB7wFxQeMARgRAIAVBIGpBf0GBAhAbGiAFQQA6ACAgC0HzAEcNCCAFQQA6AEEgBUEAOgAuIAVBADYBKgwICyAFQSBqIAMtAAEiB0HeAEYiAUGBAhAbGiAFQQA6ACAgA0ECaiADQQFqIAEbIQQCfwJAAkAgA0ECQQEgARtqLQAAIgFBLUcEQCABQd0ARg0BIAdB3gBHIQcgBAwDCyAFIAdB3gBHIgc6AE4MAQsgBSAHQd4ARyIHOgB+CyAEQQFqCyEDA0ACQCADLQAAIgFBLUcEQCABRQ0PIAFB3QBHDQEMCgtBLSEBIAMtAAEiDkUgDkHdAEZyDQAgA0EBaiEEAkAgA0F/ai0AACIDIA5PBEAgDiEBDAELA0AgA0EBaiIDIAVBIGpqIAc6AAAgAyAELQAAIgFJDQALCyAEIQMLIAEgBWogBzoAISADQQFqIQMMAAALAAtBCCEBDAILQQohAQwBC0EAIQELIAAgAUEAQn8QtwEhESAAKQN4QgAgACgCBCAAKAIIa6x9UQ0JIAhFIAtB8ABHckUEQCAIIBE+AgAMBQsgCCANIBEQsgEMBAsgCCARIBIQtQI4AgAMAwsgCCARIBIQbTkDAAwCCyAIIBE3AwAgCCASNwMIDAELIAlBAWpBHyALQeMARiILGyEHAkAgDUEBRyINRQRAIAghBiAMBEAgB0ECdBAaIgZFDQULIAVCADcDqAJBACEBAkADQAJ/IAAoAgQiBCAAKAJoSQRAIAAgBEEBajYCBCAELQAADAELIAAQHwsiBCAFai0AIUUNASAFIAQ6ABsgBUEcaiAFQRtqIAVBqAJqEJ0CIgRBfkYNAEEAIQogBEF/Rg0IIAYEQCAGIAFBAnRqIAUoAhw2AgAgAUEBaiEBCyAMRSABIAdHcg0AIAciAUEBdEEBciIOIQcgBiIEIA5BAnQQHiIGDQALIAQhBgwHC0EAIQoCf0EBIAVBqAJqIgRFDQAaIAQoAgBFC0UNBgwBCyAMBEBBACEBIAcQGiIJRQ0EA0AgCSEKA0ACfyAAKAIEIgYgACgCaEkEQCAAIAZBAWo2AgQgBi0AAAwBCyAAEB8LIgYgBWotACFFBEBBACEGDAQLIAEgCmogBjoAACABQQFqIgEgB0cNAAtBACEGIAciAUEBdEEBciIEIQcgCiAEEB4iCQ0ACwwGC0EAIQEgCARAA0ACfyAAKAIEIgYgACgCaEkEQCAAIAZBAWo2AgQgBi0AAAwBCyAAEB8LIgYgBWotACEEQCABIAhqIAY6AAAgAUEBaiEBDAEFQQAhBiAIIQoMAwsAAAsACwNAAn8gACgCBCIBIAAoAmhJBEAgACABQQFqNgIEIAEtAAAMAQsgABAfCyAFai0AIQ0AC0EAIQpBACEGQQAhAQsCQCAAKAJoRQRAIAAoAgQhCQwBCyAAIAAoAgRBf2oiCTYCBAsgACkDeCAJIAAoAghrrHwiEVAgESASUkEAIAsbcg0FAkAgDEUNACANRQRAIAggBjYCAAwBCyAIIAo2AgALIAsNACAGBEAgBiABQQJ0akEANgIACyAKRQRAQQAhCgwBCyABIApqQQA6AAALIAAoAgQgACgCCGusIAApA3ggEHx8IRAgDyAIQQBHaiEPCyADQQFqIQEgAy0AASIDDQEMBAsLQQAhCkEAIQYLIA9BfyAPGyEPCyAMRQ0AIAoQFiAGEBYLIAVBsAJqJAAgDwvAGwMMfwZ+AXwjAEGAxgBrIgckAEEAIAMgBGoiEWshEgJAAn8DQAJAIAJBMEcEQCACQS5HDQQgASgCBCICIAEoAmhPDQEgASACQQFqNgIEIAItAAAMAwsgASgCBCICIAEoAmhJBEBBASEKIAEgAkEBajYCBCACLQAAIQIFQQEhCiABEB8hAgsMAQsLIAEQHwshAkEBIQkgAkEwRw0AA0AgE0J/fCETAn8gASgCBCICIAEoAmhJBEAgASACQQFqNgIEIAItAAAMAQsgARAfCyICQTBGDQALQQEhCgsgB0EANgKABgJAAkACQAJAAkAgAkEuRiILIAJBUGoiDkEJTXIEQANAAkAgC0EBcQRAIAlFBEAgFCETQQEhCQwCCyAKQQBHIQoMBAsgFEIBfCEUIAhB/A9MBEAgFKcgDCACQTBHGyEMIAdBgAZqIAhBAnRqIgsgDQR/IAIgCygCAEEKbGpBUGoFIA4LNgIAQQEhCkEAIA1BAWoiAiACQQlGIgIbIQ0gAiAIaiEIDAELIAJBMEYNACAHIAcoAvBFQQFyNgLwRQsCfyABKAIEIgIgASgCaEkEQCABIAJBAWo2AgQgAi0AAAwBCyABEB8LIgJBLkYiCyACQVBqIg5BCklyDQALCyATIBQgCRshEyAKRSACQV9xQcUAR3JFBEACQCABIAYQswEiFUKAgICAgICAgIB/Ug0AIAZFDQRCACEVIAEoAmhFDQAgASABKAIEQX9qNgIECyATIBV8IRMMBAsgCkEARyEKIAJBAEgNAQsgASgCaEUNACABIAEoAgRBf2o2AgQLIAoNAUHcnAJBHDYCAAtCACEUIAFCABA0QgAhEwwBCyAHKAKABiIBRQRAIAcgBbdEAAAAAAAAAACiEEAgBykDCCETIAcpAwAhFAwBCyATIBRSIBRCCVVyIANBHkxBACABIAN2G3JFBEAgB0EwaiAFEDAgB0EgaiABEFEgB0EQaiAHKQMwIAcpAzggBykDICAHKQMoECAgBykDGCETIAcpAxAhFAwBCyATIARBfm2sVQRAQdycAkHEADYCACAHQeAAaiAFEDAgB0HQAGogBykDYCAHKQNoQn9C////////v///ABAgIAdBQGsgBykDUCAHKQNYQn9C////////v///ABAgIAcpA0ghEyAHKQNAIRQMAQsgEyAEQZ5+aqxTBEBB3JwCQcQANgIAIAdBkAFqIAUQMCAHQYABaiAHKQOQASAHKQOYAUIAQoCAgICAgMAAECAgB0HwAGogBykDgAEgBykDiAFCAEKAgICAgIDAABAgIAcpA3ghEyAHKQNwIRQMAQsgDQRAIA1BCEwEQCAHQYAGaiAIQQJ0aiICKAIAIQEDQCABQQpsIQEgDUEBaiINQQlHDQALIAIgATYCAAsgCEEBaiEICwJAIAxBCEogDCATpyIJSnIgCUERSnINACAJQQlGBEAgB0HAAWogBRAwIAdBsAFqIAcoAoAGEFEgB0GgAWogBykDwAEgBykDyAEgBykDsAEgBykDuAEQICAHKQOoASETIAcpA6ABIRQMAgsgCUEITARAIAdBkAJqIAUQMCAHQYACaiAHKAKABhBRIAdB8AFqIAcpA5ACIAcpA5gCIAcpA4ACIAcpA4gCECAgB0HgAWpBACAJa0ECdEGA8gFqKAIAEDAgB0HQAWogBykD8AEgBykD+AEgBykD4AEgBykD6AEQxAEgBykD2AEhEyAHKQPQASEUDAILIAMgCUF9bGpBG2oiAkEeTEEAIAcoAoAGIgEgAnYbDQAgB0HgAmogBRAwIAdB0AJqIAEQUSAHQcACaiAHKQPgAiAHKQPoAiAHKQPQAiAHKQPYAhAgIAdBsAJqIAlBAnRBuPEBaigCABAwIAdBoAJqIAcpA8ACIAcpA8gCIAcpA7ACIAcpA7gCECAgBykDqAIhEyAHKQOgAiEUDAELQQAhDQJAIAlBCW8iAUUEQEEAIQIMAQsgASABQQlqIAlBf0obIQ8CQCAIRQRAQQAhAkEAIQgMAQtBgJTr3ANBACAPa0ECdEGA8gFqKAIAIhBtIQ5BACEKQQAhAUEAIQIDQCAHQYAGaiABQQJ0aiIGIAYoAgAiDCAQbiILIApqIgY2AgAgAkEBakH/D3EgAiAGRSABIAJGcSIGGyECIAlBd2ogCSAGGyEJIA4gDCALIBBsa2whCiABQQFqIgEgCEcNAAsgCkUNACAHQYAGaiAIQQJ0aiAKNgIAIAhBAWohCAsgCSAPa0EJaiEJCwNAIAdBgAZqIAJBAnRqIQYDQAJAIAlBJEgNACAJQSRGBEAgBigCAEHR6fkESQ0BQSQhCQsCQANAIAhBAWpB/w9xIQYgB0GABmogCEF/akH/D3FBAnRqIQ8DQEEJQQEgCUEtShshCgJAA0AgAiELQQAhAQJAA0ACQCABIAtqQf8PcSICIAhGDQAgB0GABmogAkECdGooAgAiDCABQQJ0QYDyAWooAgAiAkkNACAMIAJLDQIgAUEBaiIBQQRHDQELCyAJQSRHDQBCACETQQAhAUIAIRQDQCAIIAEgC2pB/w9xIgJGBEAgCEEBakH/D3EiCEECdCAHakEANgL8BQsgB0HwBWogEyAUQgBCgICAgOWat47AABAgIAdB4AVqIAdBgAZqIAJBAnRqKAIAEFEgB0HQBWogBykD8AUgBykD+AUgBykD4AUgBykD6AUQLiAHKQPYBSEUIAcpA9AFIRMgAUEBaiIBQQRHDQALIAdBwAVqIAUQMCAHQbAFaiATIBQgBykDwAUgBykDyAUQICAHKQO4BSEUQgAhEyAHKQOwBSEVIA1B8QBqIgYgBGsiBEEAIARBAEobIAMgBCADSCICGyIMQfAATA0CDAULIAogDWohDSALIAgiAkYNAAtBgJTr3AMgCnYhEEF/IAp0QX9zIQ5BACEBIAshAgNAIAdBgAZqIAtBAnRqIgwgDCgCACIMIAp2IAFqIgE2AgAgAkEBakH/D3EgAiABRSACIAtGcSIBGyECIAlBd2ogCSABGyEJIAwgDnEgEGwhASALQQFqQf8PcSILIAhHDQALIAFFDQEgAiAGRwRAIAdBgAZqIAhBAnRqIAE2AgAgBiEIDAMLIA8gDygCAEEBcjYCACAGIQIMAQsLCyAHQYAFakQAAAAAAADwP0HhASAMaxBBEEAgB0GgBWogBykDgAUgBykDiAUgFSAUELYBIAcpA6gFIRcgBykDoAUhGCAHQfAEakQAAAAAAADwP0HxACAMaxBBEEAgB0GQBWogFSAUIAcpA/AEIAcpA/gEEMMBIAdB4ARqIBUgFCAHKQOQBSITIAcpA5gFIhYQiAEgB0HQBGogGCAXIAcpA+AEIAcpA+gEEC4gBykD2AQhFCAHKQPQBCEVCwJAIAtBBGpB/w9xIgEgCEYNAAJAIAdBgAZqIAFBAnRqKAIAIgFB/8m17gFNBEAgAUVBACALQQVqQf8PcSAIRhsNASAHQeADaiAFt0QAAAAAAADQP6IQQCAHQdADaiATIBYgBykD4AMgBykD6AMQLiAHKQPYAyEWIAcpA9ADIRMMAQsgAUGAyrXuAUcEQCAHQcAEaiAFt0QAAAAAAADoP6IQQCAHQbAEaiATIBYgBykDwAQgBykDyAQQLiAHKQO4BCEWIAcpA7AEIRMMAQsgBbchGSAIIAtBBWpB/w9xRgRAIAdBgARqIBlEAAAAAAAA4D+iEEAgB0HwA2ogEyAWIAcpA4AEIAcpA4gEEC4gBykD+AMhFiAHKQPwAyETDAELIAdBoARqIBlEAAAAAAAA6D+iEEAgB0GQBGogEyAWIAcpA6AEIAcpA6gEEC4gBykDmAQhFiAHKQOQBCETCyAMQe8ASg0AIAdBwANqIBMgFkIAQoCAgICAgMD/PxDDASAHKQPAAyAHKQPIA0IAQgAQSA0AIAdBsANqIBMgFkIAQoCAgICAgMD/PxAuIAcpA7gDIRYgBykDsAMhEwsgB0GgA2ogFSAUIBMgFhAuIAdBkANqIAcpA6ADIAcpA6gDIBggFxCIASAHKQOYAyEUIAcpA5ADIRUCQCAGQf////8HcUF+IBFrTA0AIAdBgANqIBUgFEIAQoCAgICAgID/PxAgIBMgFkIAQgAQSCEBIBUgFBBtIRkgBykDiAMgFCAZmUQAAAAAAAAAR2YiAxshFCAHKQOAAyAVIAMbIRUgAiADQQFzIAQgDEdycSABQQBHcUVBACADIA1qIg1B7gBqIBJMGw0AQdycAkHEADYCAAsgB0HwAmogFSAUIA0QtQEgBykD+AIhEyAHKQPwAiEUDAMLIAhB/w9qIQ5BACEKIAghCwNAIAshCAJ/QQAgCq0gB0GABmogDkH/D3EiDEECdGoiATUCAEIdhnwiE0KBlOvcA1QNABogE0KAlOvcA4AiFEKA7JSjfH4gE3whEyAUpwshCiABIBOnIgE2AgAgCCAIIAggDCABGyACIAxGGyAMIAhBf2pB/w9xRxshCyAMQX9qIQ4gAiAMRw0ACyANQWNqIQ0gCkUNAAsgCyACQX9qQf8PcSICRgRAIAdBgAZqIAtB/g9qQf8PcUECdGoiASABKAIAIAdBgAZqIAtBf2pB/w9xIghBAnRqKAIAcjYCAAsgCUEJaiEJIAdBgAZqIAJBAnRqIAo2AgAMAAALAAsgACAUNwMAIAAgEzcDCCAHQYDGAGokAAuiDQIIfwd+IwBBsANrIgYkAAJ/IAEoAgQiByABKAJoSQRAIAEgB0EBajYCBCAHLQAADAELIAEQHwshBwJAAn8DQAJAIAdBMEcEQCAHQS5HDQQgASgCBCIHIAEoAmhPDQEgASAHQQFqNgIEIActAAAMAwsgASgCBCIHIAEoAmhJBEBBASEKIAEgB0EBajYCBCAHLQAAIQcMAgVBASEKIAEQHyEHDAILAAsLIAEQHwshB0EBIQkgB0EwRw0AA0AgEUJ/fCERAn8gASgCBCIHIAEoAmhJBEAgASAHQQFqNgIEIActAAAMAQsgARAfCyIHQTBGDQALQQEhCgtCgICAgICAwP8/IQ8CQANAAkAgB0EgciEMAkACQCAHQVBqIg1BCkkNACAHQS5HQQAgDEGff2pBBUsbDQQgB0EuRw0AIAkNAkEBIQkgECERDAELIAxBqX9qIA0gB0E5ShshBwJAIBBCB1cEQCAHIAhBBHRqIQgMAQsgEEIcVwRAIAZBMGogBxAwIAZBIGogEyAPQgBCgICAgICAwP0/ECAgBkEQaiAGKQMgIhMgBikDKCIPIAYpAzAgBikDOBAgIAYgDiASIAYpAxAgBikDGBAuIAYpAwghEiAGKQMAIQ4MAQsgCyAHRXINACAGQdAAaiATIA9CAEKAgICAgICA/z8QICAGQUBrIA4gEiAGKQNQIAYpA1gQLiAGKQNIIRJBASELIAYpA0AhDgsgEEIBfCEQQQEhCgsgASgCBCIHIAEoAmhJBEAgASAHQQFqNgIEIActAAAhBwwCBSABEB8hBwwCCwALC0EuIQcLAn4CQAJAIApFBEAgASgCaEUEQCAFDQMMAgsgASABKAIEIgJBf2o2AgQgBUUNASABIAJBfmo2AgQgCUUNAiABIAJBfWo2AgQMAgsgEEIHVwRAIBAhDwNAIAhBBHQhCCAPQgF8Ig9CCFINAAsLAkAgB0FfcUHQAEYEQCABIAUQswEiD0KAgICAgICAgIB/Ug0BIAUEQEIAIQ8gASgCaEUNAiABIAEoAgRBf2o2AgQMAgtCACEOIAFCABA0QgAMBAtCACEPIAEoAmhFDQAgASABKAIEQX9qNgIECyAIRQRAIAZB8ABqIAS3RAAAAAAAAAAAohBAIAYpA3AhDiAGKQN4DAMLIBEgECAJG0IChiAPfEJgfCIQQQAgA2usVQRAQdycAkHEADYCACAGQaABaiAEEDAgBkGQAWogBikDoAEgBikDqAFCf0L///////+///8AECAgBkGAAWogBikDkAEgBikDmAFCf0L///////+///8AECAgBikDgAEhDiAGKQOIAQwDCyAQIANBnn5qrFkEQCAIQX9KBEADQCAGQaADaiAOIBJCAEKAgICAgIDA/79/EC4gDiASELwCIQEgBkGQA2ogDiASIA4gBikDoAMgAUEASCIFGyASIAYpA6gDIAUbEC4gEEJ/fCEQIAYpA5gDIRIgBikDkAMhDiAIQQF0IAFBf0pyIghBf0oNAAsLAn4gECADrH1CIHwiD6ciAUEAIAFBAEobIAIgDyACrFMbIgFB8QBOBEAgBkGAA2ogBBAwIAYpA4gDIREgBikDgAMhE0IADAELIAZB4AJqRAAAAAAAAPA/QZABIAFrEEEQQCAGQdACaiAEEDAgBkHwAmogBikD4AIgBikD6AIgBikD0AIiEyAGKQPYAiIRELYBIAYpA/gCIRQgBikD8AILIQ8gBkHAAmogCCAIQQFxRSAOIBJCAEIAEEhBAEcgAUEgSHFxIgFqEFEgBkGwAmogEyARIAYpA8ACIAYpA8gCECAgBkGQAmogBikDsAIgBikDuAIgDyAUEC4gBkGgAmpCACAOIAEbQgAgEiABGyATIBEQICAGQYACaiAGKQOgAiAGKQOoAiAGKQOQAiAGKQOYAhAuIAZB8AFqIAYpA4ACIAYpA4gCIA8gFBCIASAGKQPwASIPIAYpA/gBIhFCAEIAEEhFBEBB3JwCQcQANgIACyAGQeABaiAPIBEgEKcQtQEgBikD4AEhDiAGKQPoAQwDC0HcnAJBxAA2AgAgBkHQAWogBBAwIAZBwAFqIAYpA9ABIAYpA9gBQgBCgICAgICAwAAQICAGQbABaiAGKQPAASAGKQPIAUIAQoCAgICAgMAAECAgBikDsAEhDiAGKQO4AQwCCyABQgAQNAsgBkHgAGogBLdEAAAAAAAAAACiEEAgBikDYCEOIAYpA2gLIRAgACAONwMAIAAgEDcDCCAGQbADaiQAC/sBAQN/IwBBEGshBSACQcitAiACGyIDKAIAIQICQAJAIAFFBEAgAg0BQQAPCyABLQAAIgRBGHRBGHUhASAAIAVBDGogABshACACRQRAIAFBAE4EQCAAIAQ2AgAgAUEARw8LQbiLAigCACgCAEUEQCAAIAFB/78DcTYCAEEBDwsgBEG+fmoiAEEySw0BIABBAnRB0O0BaigCACECDAILIAFB+AFxQQN2IgFBcGogAkEadSABanJBB0sNACAEQYB/aiACQQZ0ciICQQBIDQEgA0EANgIAIAAgAjYCAEEBDwsgA0EANgIAQdycAkEZNgIAQX8PCyADIAI2AgBBfguDAQECfyMAQZABayIDJAAgA0G47AFBkAEQGCIDIAA2AiwgAyAANgIUIANBfiAAayIEQf////8HIARB/////wdJGyIENgIwIAMgACAEaiIANgIcIAMgADYCECADIAEgAhCFASAEBEAgAygCFCIAIAAgAygCEEZrQQA6AAALIANBkAFqJAALMwEBfyAAKAIUIgMgASACIAAoAhAgA2siASABIAJLGyIBEBgaIAAgACgCFCABajYCFCACCygAIAEgASgCAEEPakFwcSIBQRBqNgIAIAAgASkDACABKQMIEG05AwAL6BYDEX8DfgF8IwBBsARrIgkkACAJQQA2AiwCfyABvSIXQn9XBEBBASERIAGaIgG9IRdBkOwBDAELIARBgBBxBEBBASERQZPsAQwBC0GW7AFBkewBIARBAXEiERsLIRUCQCAXQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEUEDaiIMIARB//97cRArIAAgFSARECcgAEHN8QFBq+wBIAVBBXZBAXEiAxtBo+wBQafsASADGyABIAFiG0EDECcMAQsgCUEQaiEQAkACfwJAIAEgCUEsahC7ASIBIAGgIgFEAAAAAAAAAABiBEAgCSAJKAIsIgZBf2o2AiwgBUEgciIPQeEARw0BDAMLIAVBIHIiD0HhAEYNAiAJKAIsIQtBBiADIANBAEgbDAELIAkgBkFjaiILNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyEKIAlBMGogCUHQAmogC0EASBsiDiEIA0AgCAJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgM2AgAgCEEEaiEIIAEgA7ihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIAtBAUgEQCALIQMgCCEGIA4hBwwBCyAOIQcgCyEDA0AgA0EdIANBHUgbIQ0CQCAIQXxqIgYgB0kNACANrSEYQgAhFwNAIAYgF0L/////D4MgBjUCACAYhnwiGUKAlOvcA4AiF0KA7JSjfH4gGXw+AgAgBkF8aiIGIAdPDQALIBenIgNFDQAgB0F8aiIHIAM2AgALA0AgCCIGIAdLBEAgBkF8aiIIKAIARQ0BCwsgCSAJKAIsIA1rIgM2AiwgBiEIIANBAEoNAAsLIANBf0wEQCAKQRlqQQltQQFqIRIgD0HmAEYhFgNAQQlBACADayADQXdIGyEMAkAgByAGTwRAIAcgB0EEaiAHKAIAGyEHDAELQYCU69wDIAx2IRRBfyAMdEF/cyETQQAhAyAHIQgDQCAIIAMgCCgCACINIAx2ajYCACANIBNxIBRsIQMgCEEEaiIIIAZJDQALIAcgB0EEaiAHKAIAGyEHIANFDQAgBiADNgIAIAZBBGohBgsgCSAJKAIsIAxqIgM2AiwgDiAHIBYbIgggEkECdGogBiAGIAhrQQJ1IBJKGyEGIANBAEgNAAsLQQAhCAJAIAcgBk8NACAOIAdrQQJ1QQlsIQhBCiEDIAcoAgAiDUEKSQ0AA0AgCEEBaiEIIA0gA0EKbCIDTw0ACwsgCkEAIAggD0HmAEYbayAPQecARiAKQQBHcWsiAyAGIA5rQQJ1QQlsQXdqSARAIANBgMgAaiITQQltIg1BAnQgCUEwakEEciAJQdQCaiALQQBIG2pBgGBqIQxBCiEDIA1Bd2wgE2oiDUEHTARAA0AgA0EKbCEDIA1BAWoiDUEIRw0ACwsCQEEAIAYgDEEEaiISRiAMKAIAIhMgEyADbiINIANsayIUGw0ARAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IBQgA0EBdiILRhtEAAAAAAAA+D8gBiASRhsgFCALSRshGkQBAAAAAABAQ0QAAAAAAABAQyANQQFxGyEBAkAgEUUNACAVLQAAQS1HDQAgGpohGiABmiEBCyAMIBMgFGsiCzYCACABIBqgIAFhDQAgDCADIAtqIgM2AgAgA0GAlOvcA08EQANAIAxBADYCACAMQXxqIgwgB0kEQCAHQXxqIgdBADYCAAsgDCAMKAIAQQFqIgM2AgAgA0H/k+vcA0sNAAsLIA4gB2tBAnVBCWwhCEEKIQMgBygCACILQQpJDQADQCAIQQFqIQggCyADQQpsIgNPDQALCyAMQQRqIgMgBiAGIANLGyEGCwJ/A0BBACAGIgsgB00NARogC0F8aiIGKAIARQ0AC0EBCyEWAkAgD0HnAEcEQCAEQQhxIQ8MAQsgCEF/c0F/IApBASAKGyIGIAhKIAhBe0pxIgMbIAZqIQpBf0F+IAMbIAVqIQUgBEEIcSIPDQBBCSEGAkAgFkUNACALQXxqKAIAIgNFDQBBCiENQQAhBiADQQpwDQADQCAGQQFqIQYgAyANQQpsIg1wRQ0ACwsgCyAOa0ECdUEJbEF3aiEDIAVBX3FBxgBGBEBBACEPIAogAyAGayIDQQAgA0EAShsiAyAKIANIGyEKDAELQQAhDyAKIAMgCGogBmsiA0EAIANBAEobIgMgCiADSBshCgsgCiAPciIUQQBHIRMgAEEgIAICfyAIQQAgCEEAShsgBUFfcSINQcYARg0AGiAQIAggCEEfdSIDaiADc60gEBBOIgZrQQFMBEADQCAGQX9qIgZBMDoAACAQIAZrQQJIDQALCyAGQX5qIhIgBToAACAGQX9qQS1BKyAIQQBIGzoAACAQIBJrCyAKIBFqIBNqakEBaiIMIAQQKyAAIBUgERAnIABBMCACIAwgBEGAgARzECsCQAJAAkAgDUHGAEYEQCAJQRBqQQhyIQMgCUEQakEJciEIIA4gByAHIA5LGyIFIQcDQCAHNQIAIAgQTiEGAkAgBSAHRwRAIAYgCUEQak0NAQNAIAZBf2oiBkEwOgAAIAYgCUEQaksNAAsMAQsgBiAIRw0AIAlBMDoAGCADIQYLIAAgBiAIIAZrECcgB0EEaiIHIA5NDQALIBQEQCAAQa/sAUEBECcLIApBAUggByALT3INAQNAIAc1AgAgCBBOIgYgCUEQaksEQANAIAZBf2oiBkEwOgAAIAYgCUEQaksNAAsLIAAgBiAKQQkgCkEJSBsQJyAKQXdqIQYgB0EEaiIHIAtPDQMgCkEJSiEDIAYhCiADDQALDAILAkAgCkEASA0AIAsgB0EEaiAWGyEFIAlBEGpBCHIhAyAJQRBqQQlyIQsgByEIA0AgCyAINQIAIAsQTiIGRgRAIAlBMDoAGCADIQYLAkAgByAIRwRAIAYgCUEQak0NAQNAIAZBf2oiBkEwOgAAIAYgCUEQaksNAAsMAQsgACAGQQEQJyAGQQFqIQYgD0VBACAKQQFIGw0AIABBr+wBQQEQJwsgACAGIAsgBmsiBiAKIAogBkobECcgCiAGayEKIAhBBGoiCCAFTw0BIApBf0oNAAsLIABBMCAKQRJqQRJBABArIAAgEiAQIBJrECcMAgsgCiEGCyAAQTAgBkEJakEJQQAQKwsMAQsgFUEJaiAVIAVBIHEiCxshCgJAIANBC0sNAEEMIANrIgZFDQBEAAAAAAAAIEAhGgNAIBpEAAAAAAAAMECiIRogBkF/aiIGDQALIAotAABBLUYEQCAaIAGaIBqhoJohAQwBCyABIBqgIBqhIQELIBFBAnIhDiAQIAkoAiwiCCAIQR91IgZqIAZzrSAQEE4iBkYEQCAJQTA6AA8gCUEPaiEGCyAGQX5qIg0gBUEPajoAACAGQX9qQS1BKyAIQQBIGzoAACAEQQhxIQggCUEQaiEHA0AgByIFAn8gAZlEAAAAAAAA4EFjBEAgAaoMAQtBgICAgHgLIgZBgOwBai0AACALcjoAACAFQQFqIgcgCUEQamtBAUcgCCADQQBKckVBACABIAa3oUQAAAAAAAAwQKIiAUQAAAAAAAAAAGEbckUEQCAFQS46AAEgBUECaiEHCyABRAAAAAAAAAAAYg0ACyAAQSAgAiAOIBAgCUEQamsgDWsgB2ogAyAQaiANa0ECaiADRSAHIAlrQW5qIANOchsiA2oiDCAEECsgACAKIA4QJyAAQTAgAiAMIARBgIAEcxArIAAgCUEQaiAHIAlBEGprIgUQJyAAQTAgAyAFIBAgDWsiA2prQQBBABArIAAgDSADECcLIABBICACIAwgBEGAwABzECsgCUGwBGokACACIAwgDCACSBsLLQAgAFBFBEADQCABQX9qIgEgAKdBB3FBMHI6AAAgAEIDiCIAQgBSDQALCyABCzUAIABQRQRAA0AgAUF/aiIBIACnQQ9xQYDsAWotAAAgAnI6AAAgAEIEiCIAQgBSDQALCyABC5ECAQF/QQEhAgJAIAAEfyABQf8ATQ0BAkBBuIsCKAIAKAIARQRAIAFBgH9xQYC/A0YNAwwBCyABQf8PTQRAIAAgAUE/cUGAAXI6AAEgACABQQZ2QcABcjoAAEECDwsgAUGAsANPQQAgAUGAQHFBgMADRxtFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAw8LIAFBgIB8akH//z9NBEAgACABQT9xQYABcjoAAyAAIAFBEnZB8AFyOgAAIAAgAUEGdkE/cUGAAXI6AAIgACABQQx2QT9xQYABcjoAAUEEDwsLQdycAkEZNgIAQX8FQQELDwsgACABOgAAQQELBABCAAsEAEEAC0gBAX8jAEGQAWsiAyQAIANBAEGQARAbIgNBfzYCTCADIAA2AiwgA0E6NgIgIAMgADYCVCADIAEgAhCaAiEAIANBkAFqJAAgAAu+AQECfyMAQaABayIEJAAgBEEIakG47AFBkAEQGBoCQAJAIAFBf2pB/////wdPBEAgAQ0BQQEhASAEQZ8BaiEACyAEIAA2AjQgBCAANgIcIARBfiAAayIFIAEgASAFSxsiATYCOCAEIAAgAWoiADYCJCAEIAA2AhggBEEIaiACIANBO0E8ELoBIQAgAUUNASAEKAIcIgEgASAEKAIYRmtBADoAAAwBC0HcnAJBPTYCAEF/IQALIARBoAFqJAAgAAtQAQJ/IwBBEGsiASQAIAAoAkAhAiAAED8DQCACIAFBDGpBAEEAEBUiAEFlRg0ACwJ/IABBf0wEQCAAEFoMAQsgASgCDAshACABQRBqJAAgAAuxAQECfyACKAJMQQBOBH9BAQVBAAsaIAIgAi0ASiIDQX9qIANyOgBKAn8gASACKAIIIAIoAgQiBGsiA0EBSA0AGiAAIAQgAyABIAMgAUkbIgMQGBogAiACKAIEIANqNgIEIAAgA2ohACABIANrCyIDBEADQAJAIAIQhgFFBEAgAiAAIAMgAigCIBEDACIEQQFqQQFLDQELIAEgA2sPCyAAIARqIQAgAyAEayIDDQALCyABCy4BAX8gAEGknQIoAgA2AjhBpJ0CKAIAIgEEQCABIAA2AjQLQaSdAiAANgIAIAALuAIBAn8jAEEgayIDJAACf0H85wEgASwAABAyRQRAQdycAkEcNgIAQQAMAQtBAEGYCRAaIgJFDQAaIAJBAEGQARAbGiABQSsQMkUEQCACQQhBBCABLQAAQfIARhs2AgALAkAgAS0AAEHhAEcEQCACKAIAIQEMAQsgAEEDQQAQAyIBQYAIcUUEQCADIAFBgAhyNgIQIABBBCADQRBqEAMaCyACIAIoAgBBgAFyIgE2AgALIAJB/wE6AEsgAkGACDYCMCACIAA2AjwgAiACQZgBajYCLAJAIAFBCHENACADIANBGGo2AgAgAEGTqAEgAxAIDQAgAkEKOgBLCyACQTY2AiggAkE3NgIkIAJBODYCICACQTk2AgxB5JwCKAIARQRAIAJBfzYCTAsgAhCrAgshACADQSBqJAAgAAsJACAAKAI8EAULTAEBfyMAQRBrIgMkAAJ+IAAoAjwgAacgAUIgiKcgAkH/AXEgA0EIahAMEGlFBEAgAykDCAwBCyADQn83AwhCfwshASADQRBqJAAgAQvZAgEHfyMAQSBrIgMkACADIAAoAhwiBDYCECAAKAIUIQUgAyACNgIcIAMgATYCGCADIAUgBGsiATYCFCABIAJqIQRBAiEHIANBEGohAQJ/AkACQCAAKAI8IANBEGpBAiADQQxqEAYQaUUEQANAIAQgAygCDCIFRg0CIAVBf0wNAyABIAUgASgCBCIISyIGQQN0aiIJIAUgCEEAIAYbayIIIAkoAgBqNgIAIAFBDEEEIAYbaiIJIAkoAgAgCGs2AgAgBCAFayEEIAAoAjwgAUEIaiABIAYbIgEgByAGayIHIANBDGoQBhBpRQ0ACwsgA0F/NgIMIARBf0cNAQsgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCECACDAELIABBADYCHCAAQgA3AxAgACAAKAIAQSByNgIAQQAgB0ECRg0AGiACIAEoAgRrCyEEIANBIGokACAEC+MBAQR/IwBBIGsiAyQAIAMgATYCECADIAIgACgCMCIEQQBHazYCFCAAKAIsIQUgAyAENgIcIAMgBTYCGAJAAkACfyAAKAI8IANBEGpBAiADQQxqEAcQaQRAIANBfzYCDEF/DAELIAMoAgwiBEEASg0BIAQLIQIgACAAKAIAIAJBMHFBEHNyNgIADAELIAQgAygCFCIGTQRAIAQhAgwBCyAAIAAoAiwiBTYCBCAAIAUgBCAGa2o2AgggACgCMEUNACAAIAVBAWo2AgQgASACakF/aiAFLQAAOgAACyADQSBqJAAgAgtzAQF/QQIhAQJ/IABBKxAyRQRAIAAtAABB8gBHIQELIAFBgAFyCyABIABB+AAQMhsiAUGAgCByIAEgAEHlABAyGyIBIAFBwAByIAAtAAAiAEHyAEYbIgFBgARyIAEgAEH3AEYbIgFBgAhyIAEgAEHhAEYbC2cBA39B8IsCKAIAIgFBAnRBhIwCaiIAIAAoAgBBoJ0CKAIAIgBBAnRBhIwCaigCAGoiAjYCAEGgnQJBACAAQQFqIgAgAEEfRhs2AgBB8IsCQQAgAUEBaiIBIAFBH0YbNgIAIAJBAXYLcQEDfwJAAkADQCAAIAJBkNkBai0AAEcEQEHXACEDIAJBAWoiAkHXAEcNAQwCCwsgAiIDDQBB8NkBIQAMAQtB8NkBIQIDQCACLQAAIQQgAkEBaiIAIQIgBA0AIAAhAiADQX9qIgMNAAsLIAEoAhQaIAALBgBB3JwCC7QDAgN/AX4jAEEgayIDJAACQCABQv///////////wCDIgVCgICAgICAwL9AfCAFQoCAgICAgMDAv398VARAIAFCGYinIQIgAFAgAUL///8PgyIFQoCAgAhUIAVCgICACFEbRQRAIAJBgYCAgARqIQIMAgsgAkGAgICABGohAiAAIAVCgICACIWEQgBSDQEgAkEBcSACaiECDAELIABQIAVCgICAgICAwP//AFQgBUKAgICAgIDA//8AURtFBEAgAUIZiKdB////AXFBgICA/gdyIQIMAQtBgICA/AchAiAFQv///////7+/wABWDQBBACECIAVCMIinIgRBkf4ASQ0AIANBEGogACABQv///////z+DQoCAgICAgMAAhCIFIARB/4F/ahAoIAMgACAFQYH/ACAEaxBTIAMpAwgiAEIZiKchAiADKQMAIAMpAxAgAykDGIRCAFKthCIFUCAAQv///w+DIgBCgICACFQgAEKAgIAIURtFBEAgAkEBaiECDAELIAUgAEKAgIAIhYRCAFINACACQQFxIAJqIQILIANBIGokACACIAFCIIinQYCAgIB4cXK+C8YBAgN/An4jAEEQayIDJAACfiABvCIEQf////8HcSICQYCAgHxqQf////cHTQRAIAKtQhmGQoCAgICAgIDAP3wMAQsgAkGAgID8B08EQCAErUIZhkKAgICAgIDA//8AhAwBCyACRQRAQgAMAQsgAyACrUIAIAJnIgJB0QBqECggAykDACEFIAMpAwhCgICAgICAwACFQYn/ACACa61CMIaECyEGIAAgBTcDACAAIAYgBEGAgICAeHGtQiCGhDcDCCADQRBqJAALEAAjACAAa0FwcSIAJAAgAAuNBQEFfwJAIAAoAjwiAigCmAEiBEF/TARAQdCQAkGSC0EUIgAQGBoMAQsgAi0AnwEEQEHQkAIgAkGAAWoiAEH/ASAAEBwiASABQf8BShsiABAYIQMgAigCfARAIAAgA2ohASAAQX9zQYACaiIAQQFIQf3/A0H9/wMgAigCACAEQRRsaigCBCICIAJBgHBxQYCwA0YbIAJB///DAEsbIgJB/wBKckUEQCABIAI6AAAgAUEBaiADayEADAMLAkAgAEECSCACQf8PSnIEfwJ/IABBA0ggAkH//wNKckUEQEEBIQQgASEAIAJBDHZBYHIMAQsgAEEESA0CIAEgAkESdkHwAXI6AAAgAUEBaiEAQQIhBCACQQx2QT9xQYB/cgshBSAAIAU6AAAgASAEaiEBIAJBBnZBP3FBgH9yBSACQQZ2QUByCyEAIAEgADoAACABIAJBP3FBgAFyOgABIAFBAmohAQsgASADayEADAILQf8BIAFMDQEgACADaiACKAIAIARBFGxqKAIEOgAAIABBAWohAAwBCyACLQCgASEDQdCQAiACQYABaiIAQf8BIAAQHCIAIABB/wFKGyIAEBghASADBEAgACABakGaCSAAQX9zQYACaiIDQQMgA0EDSBsiAxAYGiABIAAgA2oiAGogAigCACAEQRRsaigCACACKAIEIARBDGxqLQACaiIBIABBf3NBgAJqIgIgARAcIgEgASACShsiARAYGiAAIAFqIQAMAQsgACABaiACKAIAIARBFGxqKAIAIAIoAgQgBEEMbGotAAJqIgEgAEF/c0GAAmoiAiABEBwiASABIAJKGyIBEBgaIAAgAWohAAsgAEGAAkgEQCAAQdCQAmpBADoAAAsLgAEBAn8jAEGQAmsiBCQAIAQgBEGMAmo2AgggBCAEQQxqIgU2AgAgBCAFNgIEIAAgBCACIAMQkwEgASAEKAIAIgAgBCgCBCAAayICQf8HIAJBgAhJGyIBEBggAWpBADoAACAAIAVHBEAgABAWIAQoAgQgBCgCAGsaCyAEQZACaiQAC0QCAX8BfiABQv///////z+DIQMCfyABQjCIp0H//wFxIgJB//8BRwRAQQQgAg0BGkECQQMgACADhFAbDwsgACADhFALC7UCAwJ/AX4CfAJAAnwgAL0iA0IgiKdB/////wdxIgFBgOC/hARPBEAgAUGAgMCEBEkgA0IAU3JFBEAgAEQAAAAAAADgf6IPCyABQYCAwP8HTwRARAAAAAAAAPC/IACjDwsgAEQAAAAAAMyQwGVBAXMNAkQAAAAAAAAAACADQn9XDQEaDAILIAFB//+/5ANLDQEgAEQAAAAAAADwP6ALDwsgAEQAAAAAAAC4QqAiBL2nQYABaiIBQQR0QfAfcSICQZC5AWorAwAiBSAFIAAgBEQAAAAAAAC4wqChIAJBCHJBkLkBaisDAKEiAKIgACAAIAAgAER0XIcDgNhVP6JEAAT3iKuygz+gokSmoATXCGusP6CiRHXFgv+9v84/oKJE7zn6/kIu5j+goqAgAUGAfnFBgAJtEEEL2AECAX8BfkF/IQICQCAAQgBSIAFC////////////AIMiA0KAgICAgIDA//8AViADQoCAgICAgMD//wBRGw0AIAAgA0KAgICAgICA/z+EhFAEQEEADwsgAUKAgICAgICA/z+DQgBZBEAgAEIAVCABQoCAgICAgID/P1MgAUKAgICAgICA/z9RGw0BIAAgAUKAgICAgICA/z+FhEIAUg8LIABCAFYg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IAJBoAJqEBkLQcCXAkJ/NwMAQYCVAkGAlQIoAgBBAnI2AgAMOgtBkJcCKAIAKAIEDQACQEH4lAItAABBgAFxRQ0AQdicAi0AAEUEQCACQdSLATYC2AIgAkHUiwE2AtQCIAJB1IsBNgLQAkEAQfGxASACQdACahAZQdicAkEBOgAADAELIAJB1IsBNgLAAkEAQdeyASACQcACahAZC0H4lAJB+JQCKAIAQYABcjYCAEHIlgIoAgAhAUEAQTBBARAXIQACQCABBEAgACABKQIANwIAIAAgASkCKDcCKCAAIAEpAiA3AiAgACABKQIYNwIYIAAgASkCEDcCECAAIAEpAgg3AggMAQsgAEIANwIAIABCADcCKCAAQgA3AiAgAEIANwIYIABCADcCECAAQgA3AggLIABBADYCACAAQfSTAigCADYCCCAAQfiTAigCADYCDCAAQeyTAigCADYCECAAQfCTAigCADYCFEHIlgIgADYCAAw5C0HIlgJBADYCAAw4C0HIlgIoAgAhAEGQlwIoAgAoAgRFBEBBAEEwQQEQFyEBAkAgAARAIAEgACkCADcCACABIAApAig3AiggASAAKQIgNwIgIAEgACkCGDcCGCABIAApAhA3AhAgASAAKQIINwIIDAELIAFCADcCACABQgA3AiggAUIANwIgIAFCADcCGCABQgA3AhAgAUIANwIICyABQQA2AgBByJYCIAE2AgAgAUEBNgIEDDgLIABFDTcgACgCBEUNN0EAQTBBARAXIgEgACkCADcCACABIAApAig3AiggASAAKQIgNwIgIAEgACkCGDcCGCABIAApAhA3AhAgASAAKQIINwIIIAFBADYCAEHIlgIgATYCACABQQA2AgQMNwtB5JYCQQE2AgAMNgtB6JYCQQE2AgAMNQtB5JYCQQA2AgAMNAtB6JYCQQA2AgAMMwsgAkGQlwIoAgAiASgCDCIANgKIDCABQQEQjAEiBEUEQCABQZq0AUEAECIaDAILQfiUAkH4lAIoAgBBgAJyNgIAAkAgACwAACIDQVBqQQpPBEAgAC0AAUUNAQsgACACQYgMakEAECQiA0H/AUsNLyACKAKIDC0AAA0vCyADQQBBABCCASIAIAQ2AgwgACAEEBw2AhAgAEHslgIoAgA2AiBB7JYCIAA2AgAMMgtBkJcCKAIAIgAoAgwhAyAAQQEQ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BCEDIAFBADYCwAEgAUEANgKcASABQQA2AgQgASADNgIAIAFCADcDECABQgA3AzAgAUIANwNIIAEgAy8BEiIGNgIYIAMvARQhBSABIAQ2AlQgASACNgJQIAEgBDYCPCABIAI2AjggASAFNgIcIAFCADcDiAEgASACtyIHIAa4IgijOQNwIAFCADcDgAEgASAIIAejOQNgIAFBgP0ANgLYASABQgA3AwggASAEtyIHIAW4IgijOQN4IAEgCCAHozkDaCABIAAoAhg2AtwBIAAoAgghAgNAIAEgAjYCCCABIAMoAgAgAkECdGooAgA2AgQgASAAKAIcEM8BIAAoAgwiAyADKAIAQQFqIgI2AgAgACACNgIIIAIgACgCBCIDKAIESA0ACyABEM4BIAFB4AFqJABBAAu4AwEMfyABKAIwIgQoAhwgAC8BDiILayIJQQAgCUEAShshByAJIAQoAiQiDGoiBSAALwEKIgMgBSADSBshBQJAIAQoAhggAC8BDCINayIDIAQoAiAiDmoiBiAALwEIIgogBiAKSBsiCiADQQAgA0EASiIDGyIGSgRAIAogBmshCAwBCyAEKAIoIA5Bf2pBACADGyANa2ohBgsCfyAFIAdKBEAgBCgCLCEDIAUgB2sMAQsgBCgCLCIDIAxBf2pBACAJQQBKGyALa2ohB0EACyEFIAQoAighBCABIAM2AjggASAENgI0AkACQCAIQQFIIAVBAUhyDQAgACgCACIERQ0AQQAhAiAAQQBBBCAFQQFqEBciAzYCAANAIAMgAkECdGogBCACIAdqQQJ0aigCACAGajYCACAAKAIAIQMgAkEBaiICIAVIDQALIAMgBUECdGpBADYCACAEEBYgACAFOwEKIAAgCDsBCAwBCyACBEAgABB6DAELIAAoAgAQFiAAQQA2AgAgAEEANgIICyAAIAAvAQwgBiABKAI0a2o7AQwgACAALwEOIAcgASgCOGtqOwEOIAAoAgBBAEcL1QEBCn8gASgCHCACLwEOIglrIgZBACAGQQBKGyEEIAYgASgCJCIKaiIFIAIvAQoiAyAFIANIGyEFAkAgASgCGCACLwEMIgtrIgMgASgCICIMaiIHIAIvAQgiAiAHIAJIGyIHIANBACADQQBKIgMbIgJKBEAgByACayEIDAELIAEoAiggDEF/akEAIAMbIAtraiECCyAA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Qb7QACADECILIQEgA0EQaiQAIAEL5wEBA38jAEEwayIEJAAgABAcIQYgAgR/IAIQHAVBCgshBUHckwIoAgAQFkHckwJBAEEBIAUgBmpBA2oQFyIFNgIAAkAgAgRAIAQgAjYCBCAEIAA2AgAgBUG6zwAgBBA+DAELIANB6QdOBEBBkM4AIQZBBCECIANBkM4ASwRAA0AgAkEBaiECIAZBCmwiBiADSQ0ACwsgBCABNgIoIAQgAjYCJCAEIAA2AiAgBUHIzwAgBEEgahA+DAELIAQgATYCFCAEIAA2AhAgBUHAzwAgBEEQahA+C0HckwIoAgAhACAEQTBqJAAgAAveBAEDfyMAQZABayIEJAACQCABRSACRXINACABIAIQYCEBQdiTAigCAARAQQpBgOgBKAIAIgUQJSAFEEcaQdiTAkEANgIACyAEIAE2AoABIABB3c0AIARBgAFqECEgAigCHCIBBEAgBCABNgJwIABB7M0AIARB8ABqECELIAIvAQghASAEIAIvAQo2AmQgBCABNgJgIABB8c0AIARB4ABqECEgAi8BDCIBIAIvAQ4iBXIEQCAEIAU2AlQgBCABNgJQIABB980AIARB0ABqECELIAItABMEQEGBzgBBC0EBIAAQIxoLIAIuARQiAUEATgRAIAQgAUH//wNxNgJAIABBjc4AIARBQGsQIQtBCiAAECUCQCADQQRxRQ0AIAIoAjRFDQAgBCACKAIsNgIwIABBnc4AIARBMGoQIQsCQCACKAIgIgFFDQAgASgCCEEBSA0AQQAhBQNAQbXOAEEMQQEgABAjGiAFQQJ0IgYgASgCAGooAgAgASgCBCAGaigCACAAEJcBQQogABAlIAVBAWoiBSABKAIISA0ACwsCQCACKAIYIgFFDQAgBCABKAIANgIgIABBws4AIARBIGoQISADQQFxRQ0AIAAgAigCGEHezgAQ2QELIAItABJFBEAgAi8BEEUNAQtB5M4AQQNBASAAECMaIAItABIiAQRAIAQgAUECdEGAzwBqKAIANgIQIABB6M4AIARBEGoQIQsgAi8BECIBBEAgBCABQeQAbiICNgIAIAQgASACQeQAbGtB//8DcTYCBCAAQaDPACAEECELQQogABAlCyAEQZABaiQAC8sEAQR/IwBB4ABrIgQkAAJAIAFFDQBB2JMCKAIABEBBCkGA6AEo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b24gJTwlcyVzJT4AJTwlTyU+IGNhbiUsdCB0YWtlIGFuIGFyZ3VtZW50ACU8JU8lPiByZXF1aXJlcyBhIG5vbi1vcHRpb24gYXJndW1lbnQAJTwlTyU+IHJlcXVpcmVzIGFuIGFyZ3VtZW50AChubyBjdXJyZW50IG9wdGlvbiEpAABDTFAgaW50ZXJuYWwgZXJyb3I6IG1vcmUgdGhhbiAxIG9wdGlvbiBoYXMgc2hvcnQgbmFtZSAlPCVjJT4AQ0xQIGludGVybmFsIGVycm9yOiAxLWNoYXIgbG9uZyBuYW1lIGNvbmZsaWN0cyB3aXRoIHNob3J0IG5hbWUgJTwlYyU+AENMUCBpbnRlcm5hbCBlcnJvcjogZHVwbGljYXRlIGxvbmcgbmFtZSAlPCVzJT4AJTwlTyU+IGV4cGVjdHMgYSBub25uZWdhdGl2ZSBpbnRlZ2VyLCBub3QgJTwlcyU+ACU8JU8lPiBleHBlY3RzIGFuIGludGVnZXIsIG5vdCAlPCVzJT4AJTwlTyU+IGV4cGVjdHMgYSByZWFsIG51bWJlciwgbm90ICU8JXMlPgB5ZXMAdHJ1ZQBubwBmYWxzZQAlPCVPJT4gZXhwZWN0cyBhIHRydWUtb3ItZmFsc2UgdmFsdWUsIG5vdCAlPCVzJT4AbWluX21hdGNoID4gMABhcmdjbXAAYW1iaWd1b3VzAGludmFsaWQAb3B0aW9uICU8JVYlPiBpcyAlcwBhbnkgaW50ZWdlcgAwAG5leHRfYXJndW1lbnQAbl9vcHRpb25fY2hhcnMgPCBDbHBfT3B0aW9uQ2hhcnNTaXplAHNldF9vcHRpb25fdGV4dABsZW4gPiAwAGZpbmRfbG9uZwBjbGktPmNvdWxkX2JlX3Nob3J0AHN3aXRjaF90b19zaG9ydF9hcmd1bWVudAAobnVsbCkAXCUwM28AJWQA4oCYACcA4oCZAG91dCBvZiBtZW1vcnkKAChQb3NzaWJpbGl0aWVzIGFyZQAgYW5kIAAsIGFuZCAALCBhbmQgb3RoZXJzAC4pCgAlczogT3V0IG9mIG1lbW9yeSwgZ2l2aW5nIHVwCgAlczogT3V0IG9mIG1lbW9yeSwgZ2l2aW5nIHVwIChodWdlIGFsbG9jYXRpb24pCgBnaWZmdW5jLmMAZ2lmcmVhZC5jAGltYWdlIGNvcnJ1cHRlZCwgbWluX2NvZGVfc2l6ZSB0b28gYmlnAGltYWdlIGNvcnJ1cHRlZCwgbWluX2NvZGVfc2l6ZSB0b28gc21hbGwAaW1hZ2UgY29ycnVwdGVkLCBjb2RlIG91dCBvZiByYW5nZQAobm90IHJlcG9ydGluZyBtb3JlIGVycm9ycykAbWlzc2luZyAlbGQgJXMgb2YgaW1hZ2UgZGF0YQBwaXhlbABwaXhlbHMAJWxkIHN1cGVyZmx1b3VzIHBpeGVscyBvZiBpbWFnZSBkYXRhAHVua25vd24gYmxvY2sgdHlwZSAlZCBhdCBmaWxlIG9mZnNldCAldQB0cmFpbGluZyBnYXJiYWdlIGFmdGVyIEdJRiBpZ25vcmVkAGltYWdlIGhhcyB6ZXJvIHdpZHRoIGFuZC9vciBoZWlnaHQAaW1hZ2UgcG9zaXRpb24gYW5kL29yIGRpbWVuc2lvbnMgb3V0IG9mIHJhbmdlAGJhZCBncmFwaGljIGV4dGVuc2lvbgBORVRTQ0FQRTIuMABBTklNRVhUUzEuMABiYWQgbG9vcCBleHRlbnNpb24AZ2lmdW5vcHQuYwBtYXB0byA+PSAwICYmIG1hcHRvIDwgbmRlc3Rjb2wAbWVyZ2UuYwBtZXJnZV9jb2xvcm1hcF9pZl9wb3NzaWJsZQBHSUZfQ09MT1JFUSgmZGVzdGNvbFttYXB0b10sICZzcmNjb2xbaV0pAHRvbyBtYW55IGNvbG9ycywgdXNpbmcgbG9jYWwgY29sb3JtYXBzCiAgKFlvdSBtYXkgd2FudCB0byB0cnkgJTwtLWNvbG9ycyAyNTYlPi4pAHRvbyBtYW55IGNvbG9ycywgdXNpbmcgbG9jYWwgY29sb3JtYXBzAGRlc3QtPmdsb2JhbABtZXJnZV9zdHJlYW0Ac29tZSBjb2xvcnMgdW5kZWZpbmVkIGJ5IGNvbG9ybWFwAGMtPmhhc3BpeGVsID09IDIgJiYgZm91bmRfdHJhbnNwYXJlbnQgPCAyNTYAbWVyZ2VfaW1hZ2UAZGVzdGNtLT5uY29sIDw9IDI1NgBvcHRpbWl6ZS5jAC4vb3B0dGVtcGxhdGUuYwAlZCBjb2xvcnMgcmVxdWlyZWQgaW4gYSBmcmFtZSAoMjU2IGlzIG1heCkAYm91bmRzLT50b3AgPCBzY3Jl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CgYKBQkGCQIJBA0EDQMIAwoBDQYLAQwDDgUPAwgDCAMMBAsDDQMIBAkGDAQLBgsDCgAMAQsHDAQMBAsFAQ4ACgIJAgsBCAEIAwkEDwcNBw4HDgAKAA4HCQALAQ8ACwALAw8HDgYKBQgACwAIBwsADwAMAQ0GCQAPBAkBCAoFDwYNBg4HDgQMBQ8GCgILAwoDCwMNBgsFDgMOBggFDgUOBwoHCwMNAw0CDgQPBQ8DCAQLBAkFDAMIBQ8CDQUDCgIJBQ8ECQALBwsADgULBQ4HDwYJAAkACAQOBgwACwQPBQgGCgYLBgoDDAUJBgkFDAYMBw4ADgIPBQgCCgMJDgcOBwgBDAIOBA8DCwUMAggACgMMAQ0FDgULAAsDDQcIAQwDDwMOAg8DCwYPAQwBCQMJAwsDCwcLBQwADgYNBgUKBgwDDwMIBwoADwcKBQgBDgUKBw4CDgAOAQgDCAUKBQ8ACAYOAAgCDwQLBgoACAUJBA4BDwMKAQ8ADwUIBw0PAwgACQYMBg8ACwQOAw8DCgUMAwoDCQYJBQ0FDwYOAAkADAQLAw8ECwYPAg8DDgQNAgsBCAUMBwkECAUMAgsAAA0FCwUOBQ8HCQUIAgoDDwYJAwwFCwYOAw0GDQAJAQsDCAMJBAkGDgcIBgwHDQYJBQ0DDwUOAw8EDAQMAg0ADwoHDgEIAgoCDAANAQ0FCwYMAwkGDwEJAQoGCgMPBg8FDwcMBgwACQMMAwsDCAMNAgkDCQYKAgsGCQAJAQkGCgQDCgQJBAkGDQMPAAgECgAOBQ8HDwIMBwoFDwcIAAkACAYOBA8CDwEPAAkFDgAMBwoGCAYLAA0HDgENAgoFCQAODgYNAQwDCAMJBgwEDwIIBQkBCgEIBQ8ACAIMAwwFDAULAgoCCAUKBQwECQMIBA0BDwAMAwgECgMJBQ0FDQMLBAQMAwoGCQAOAAgBCQEJBg8ACgIJBgoHCgIOBAgADQQIAQsGDgcOAAgEDgcOBAkCDAAMAwgFCQYOAAkCDgUKAQ8KAg8GDgMLBg8EDwQNBQsDDAQOBQwADQMIBg8CCgYNAgwGCAMKAw4FCAAKAw0CCQYKBg8EDQIIAw4GCwcNAAoFAg0BCQUKAw8GCgAPBA8EDwYJAA4BCQYMAAsFCQAOBQ4GCQMLBwsBDwEJAw0FDAAJAgkGDQIJBg0HCwcIAA0DCQkGDQYNAAgFDgILBwsCCwIMAwsEDQQKAw8FDQALBgoADQMPBw4DCAQMBgkGCgMOBQ0FCwMNBggCDgMPAwsEDAYECgcLAQoCDgcOAA4EDwAIAA8FDwcLBw4GDAAIAQ8BDgIIAAsECAULAQ8ADAcOAAsECAIIAA4CDgQJBAoHDwUODgANAg4FCwUKAgoGCwMMBQsHCwEMAwsDCQMMBAsGCQUOBQwHDgIMAQgECwcKAw4EDgAOBQsHCwUPAQ4ACgMKAAUMBwoHCwAOBQ4BDgMIAA8ACQUJAQgGDwYPBw0HCQQLAAoGCgcMBw8ACQcOAgsADAcLBw0ACQYOAgsBDwAIAAoKAw8DDwMIBAsDCwYPBgsFDAUNAA8ECAELAwoDDwMOAQ4GDQMLAwsDDQYIAwwFCAQNAwgCDQQIAw4HCAUOBA8FAwkACgAMAwsHCgYIBwwACwEIBQwFDAcLAg4ACgAMAA8CCQUJAA8EDgYJBwsGCgAJAQkADgQMBQkGCgQLBgwFDAwGDwQIBA8HDwMOAAkDDQUOBQsBCQAPAwgHDAcIBQkEDAYMAQoGCQAPAw4ADwMNBQ8FCQYKAA4ADQEPAQgDCAECCAcPAAsBDAEMAA8ACwINAQoFCAcNBgoACwQMBwoBCQEJAAwCCwcPAQsACQIIBAwCDAYOBA4DDQMPAQ4EDwYMDQYLAwwECAQJBAkFDAYKBQ4HDgMKAg0DDgUIAg0BDwYPBAgEDwUKAQ4FDAQNBQsBCQUJAwkACgcKBwsGCgMJAAMPBQgBCQUIBA0GCAQPBgoGDgcLAAkBDAAIBgwGCgMMBw0HCwMIAA0HDAAPBAwFCAQPBQoADwMPAQgBDwQOBg8KBg4ADQQNAQkBDQMLAgwBCAMMAw4GCAQPBAgDDwEJBgsCDgMNBwoECgMIBwsCDAELAQ4DCQYJBw0FCwcKAgkDAQkADgcMBw4FCQYKBg4GDwEOBwoDDAAOBQkGCAEMAA0CCAQJBg8ADgQKBwsFDgIIBA8DCAcNAQkADwAOBQ4ADg8ECgYLAQoCDgMPAQoDCgMIBAwDCgYJBg4CDAMLBAkGDAUPAAoDCAQOAQ4DCwIMBwsCDAYKAQ0ECwQKBQsCCwcACAELBAgECgYLAwoGCgYIAQsBDwcPBgkBCQcIAA4FDAMNBAwADwUMAQwHCQYIAw8ADQYPBw8HDQIPAQ4CDwAIDAUNBQ8BDAEPAQ4GDgIOAg4GCwYLAwwCDQYPAwkFCAIIBQkBCQQJAggEDQENAAsGCwYJAgsDCgEKBgkGCwcPBQUMAAkFCAUJAAoCDQQIBQ4CCQIPBAgCCAAMBgwACgUPBAkDDQAJBA8BDgEJAAkCDgYMAA8HCQIJAA8GCgMPAw0JAQ8FDAMOAA8HCAUOAQsBDQYKBw0ADgUKBwsDDwYLAQwCCAQNBQoCCgYNBQ0ECgUJAwgEDAEMBQsGDgMLBwsHAgsEDAcIAw8DCwQLBwoBCgIKAAsEDAAKAQgHCwEKAQ8HCgILAQkGDgILAQ4EDAINAQkFCAcLBwoHDwQNAwoBCw0FCAAPAwsGDAcPAw8BDwQOBQ0GCAEPBg0FDAIPBAkEDwMOBg4FCQMMBgsFCAIJBQwFDwENAw4CCAAIAAwHDwUADgEIAggCDwIJBgwADAcMBw0ADwYOBQsBDAUIBQgBDgAKBAwGCQYIAAkADwQPBQ0BDwUMBwoGDgQJBg8ADwcNCgQNBQ0FCwUMBQkDCQQIAwkDCgYLAQ8CCAUPAQ0CCwYOBggCDwMOAw0GCQYJAAoCCgcLAQ8DCQMNAwoDCQQKAQQLBwoCDgQPAw8CDwcKAg4BCAAPAggBDAINAQgHDAYLAQoECwIPAA0ADAcLBQwHCAYPBAwHCgYKAAoACwQMBwoNAg4CCgcLAQsHCwcMAwsHDQQLBgwFCwYKBw0ECwMPAw4EDwMIBQoHCgYPAwkDDwELAwkADwEPAw8EDQUIAw8DAwkBDAQOAAsHDwELAw4ACwUKAgoCCAYOBwsACgcOBw8GCQYJAQwHCQQIBw0ADQYMBggBCQEPBAwADAQKAA0ADA0FCgYJAQ0GCwAOBwsHDgUPAg0FDwQJAg0DDgcKAwoDDAMMAggFDwMNAwsDCgQJAw8BDgQLBgoDCAQNAAoECAUFCAMNBA4BDQcJAg4EDgQMBwoGCgUMAgsGDAcNBAsCCwMIBQ8CCgEJAgwADAAKAQwACQcKAA8ECQAIAQ4EDgQNDAIIBgoACAUNAwgFCgMLAg8ADQMIAg8GCQEIAw4BDwUOBwgADAYPBQgFCQQPBQgFDwQMAwkGDAMNBQsHCgEIAwQPAgsCCgYLAw4HDwAKAA4DDAQIBwkDCwANAgwCDQUIBQgCCwQMAgoHCAYKBwwHCwAPBwgHDwAJAgwGDQAJBAkIAwwFDwUNAQgHCAMMBQkFCQYOAQwDDwcKBwgFCAUPAA0BDgcJAQ4HDQIMAwgBDQMIBAwACwMMBQsFCQMMBg4CBQ0CCAYMBwoFDgQLAgsCDQINBQoFCQAKBw0EDwIJAQkFCQYKBAwFDAQKAw4DDwEIBAwFCAUOBwsHDwULAg0BCQoADQYKAg8DCAEMAg4GCAUKBw0BDQEMBwkBCQIMBQwEDAMMAgkACAEPAQoHCgYMBAsBDgILAA4BCQIMAggFDQUGCgcLAAkDCQULAAgADQINBA0FCQQIAggACgAOBgkGCQQOBwkACwcKBwsHDgQOBQ8ECAQLBQ4ACAEOBw4CCwcNDAMNAw4FDwYMAA8ECwUJBQkCDgEMAQ0FDwQLBwwBDQIIAQwADwYOAg4DCgELAwsADAEPAgsBDAQJBAoCDQYKAgIIBAgECQAJAg8FCQYLBw4ACQIMAggACgEJBwgCCQELAgsCCAEJAQsHDQYLAQsACQINBA4BDwIIBw8ADQYJBA0NBQ0BDgAMBgkGDAANAAsDDQYLBwwFDgYOBQ8DDQYOBw8GDwUNBA4FCAIOAw4GDgUKBgoCCQUPBQsBCAUNAwsCAggGCAAJAQ8ACwQPBwgECAENBwsBDQUPAQ8CCQANBQwDDAIIAQoBDQUPAwkDCQIMBQ4GDQEJBgkBCAQPBwoHDw4FDgMMBAoHDAcIAgwBDQILBA0DCAUIAQoHDAYJBQgACAcOBQ0GCAQIAgwGDQUIBwgDCgMNBAwBDQQLAQ4DCAECDQYKAAkBDwAMBAsCCQAJAA0BCAALBQkGDQIPAgwHDAYPAg4BDQEOBAsCDgEJAA8BDAUOBg0CDwMJAQ8HCAEOCwcNAw8GCAQIBA4CDgYNBgsEDgQPBA4DCgIKBQkGCQMJAQsGCQQIBA8ACAQNBAkECQUJAwoCCQUMBggEDAALBAQKBA0BDAcIAA0EDAINAQ4HDwMIBwwDCgQJBAsHCAILAgoADAEOBg4HDQcLAwoACgQJAw0ADQcIBwkHCwIIAQ4PAAsBCQYPAwoHCQEJBwoHCgEMBQgBDwcNAwwCDQIOBw4FCgQIBAsBCgMOAA4GDgUNAggHCgcNAg4CDQIOBQsGBwsFDQELBwgFDgQNAQ4FCgIPBA0HCwcKAQgFCQQMBwoBDQcNBwsADgUOAg4EDAQNBw0HCAIOAg0FCQUJAggBCgwACAINBAwBCwEKAQoEDAILBQgBDwMOAQ0EDgIJAgwCCAQIAgwDCgYLAAsHCgEJAgoADQELBwoGDQEMAQwGDgcCDgQPBw4FCAQNAgoEDQANAQsBDAcMBg0EDQQNAgwCDQENBwoCCwIKBw8HCwUNAggCDgQJAg4ACAEIBwoFDwYOCwcKAgsBDQALAQ8HCAEJBA0ECAQIAwoACQAJAgkHCQYKBw0BDQcOBgsDDAIIAgwFCwUMAgoFDgQMBA0CCQEKAAIMAA0HDQIMBAgBDAQNBgsHDQcNAQkHCgIKAQkCCgELBgkEDQIKAAoCDgANBwoHCgAMAAkADQINAQkADwIOAg0LBwgECgIKBwwBCwcIAg0BCgAKAg0GDgAOBw0GDgUNBA8BCgINBw0HCQQJBg0DDQMIBA0ECgYKBQwECgcLBgkGBA4GCwcNBgoECAQLBggFDQcOBw4BCQAMAQkBDAQOBwoEDQcNBwsECgELBw0EDAEKBAwCCAIMAgoCDAEMBAwCDAgCDQIIAQ0BDAEMAgwCCwEJAgsDDAQIBAwECgYKAQ0CCwIKAQwADgIOBAkCCAENBAgADAQLBgwGCwcKBwsCCgdkaWFnNDUAZGlhZ29uYWwAQZDGAAvkCAgIQAIQIDA4KBgIACQ0PCwcDAQUMTkpGQkBESE9LR0NBRUlNSoaCgISIjI6Hg4GFiY2Pi4LAxMjMzsrGwcXJzc/Lx8PaGFsZnRvbmUAaGFsZgB0cmloYWxmdG9uZQB0cmloYWxmAHNxaGFsZnRvbmUAc3FoYWxmAHNxdWFyZWhhbGZ0b25lAHRyaXZpYWwgYWRhcHRpdmUgcGFsZXR0ZSAob25seSAlZCBjb2xvcnMgaW4gc291cmNlKQAAGQAAABoAAAAbAAAAcGxhbnBvcyA9PSBucGxhbgBwbGFuX2Zyb21fY3BsYW4AKm5ld19uY29sIDwgbmV3X2NtLT5jYXBhY2l0eQB0cnlfYXNzaWduX3RyYW5zcGFyZW5jeQAqbmV3X25jb2wgPT0gMjU2ACh1bnNpZ25lZCkgaSA8ICh1bnNpZ25lZCkga2QzLT5uaXRlbXMALi9rY29sb3IuaABrZDNfZGlzYWJsZQBrZDMtPmRpc2FibGVkIDwgMCB8fCBrZDMtPmRpc2FibGVkID09IGkAZ2lmc2ljbGUAVXNhZ2U6ICVzIFtPUFRJT04gfCBGSUxFIHwgRlJBTUVdLi4uClRyeSAnJXMgLS1oZWxwJyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4KACdHaWZzaWNsZScgbWFuaXB1bGF0ZXMgR0lGIGltYWdlcy4gSXRzIG1vc3QgY29tbW9uIHVzZXMgaW5jbHVkZSBjb21iaW5pbmcKc2luZ2xlIGltYWdlcyBpbnRvIGFuaW1hdGlvbnMsIGFkZGluZyB0cmFuc3BhcmVuY3ksIG9wdGltaXppbmcgYW5pbWF0aW9ucyBmb3IKc3BhY2UsIGFuZCBwcmludGluZyBpbmZvcm1hdGlvbiBhYm91dCBHSUZzLgoKVXNhZ2U6ICVzIFtPUFRJT04gfCBGSUxFIHwgRlJBTUVdLi4uCgoAUmVwb3J0IGJ1Z3MgdG8gPGVrb2hsZXJAZ21haWwuY29tPi4KVG9vIG11Y2ggaW5mb3JtYXRpb24/IFRyeSAnJXMgLS1oZWxwIHwgbW9yZScuCgAqICVzICVkIGltYWdlJXMKADxzdGRpbj4AAHMAICBsb2dpY2FsIHNjcmVlbiAlZHglZAoAICBnbG9iYWwgY29sb3IgdGFibGUgWyVkXQoAICB8ACAgYmFja2dyb3VuZCAlZAoAICBlbmQgY29tbWVudCAAICBsb29wIGZvcmV2ZXIKACAgbG9vcCBjb3VudCAldQoAICBleHRlbnNpb25zICVkCgAgICsgaW1hZ2UgIyVkIAAjJXMgACVkeCVkACBhdCAlZCwlZAAgaW50ZXJsYWNlZAAgdHJhbnNwYXJlbnQgJWQAICAgIGNvbXByZXNzZWQgc2l6ZSAldQoAICAgIGNvbW1lbnQgACAgICBsb2NhbCBjb2xvciB0YWJsZSBbJWRdCgAgICAgfAAgICAAIGRpc3Bvc2FsICVzAEGAzwALwUQ2KwAAOysAAEArAABLKwAAVCsAAFYrAABYKwAAWisAACBkZWxheSAlZC4lMDJkcwBzdXBwb3J0LmMAJXMuJXMAJXMuJTAzZAAlcy4lMCpkAGZyYW1lIHNwZWNpZmljYXRpb25zIG11c3Qgc3RhcnQgd2l0aCAjAG5vIGZyYW1lIG5hbWVkICU8IyVzJT4AZnJhbWUgJTwjJXMlPiBvdXQgb2YgcmFuZ2UsIGltYWdlIGhhcyAlZCBmcmFtZXMAaW52YWxpZCBkaW1lbnNpb25zICU8JXMlPiAod2FudCBXeEgpAGludmFsaWQgcG9zaXRpb24gJTwlcyU+ICh3YW50ICdYLFknKQBpbnZhbGlkIHNjYWxlIGZhY3RvciAlPCVzJT4gKHdhbnQgWHhZKQBpbnZhbGlkIHJlY3RhbmdsZSAlPCVzJT4gKHdhbnQgWDEsWTEtWDIsWTIgb3IgWDEsWTErV3hIADAxMjM0NTY3ODlBQkNERUZhYmNkZWYAaW52YWxpZCBjb2xvciAlPCVzJT4gKHdhbnQgI1JHQiBvciAjUlJHR0JCKQBpbnZhbGlkIGNvbG9yICU8JXMlPgAlPCVPJT4gdGFrZXMgdHdvIGNvbG9yIGFyZ3VtZW50cwAtAHJiACVzAGZpbGUgbm90IGluIEdJRiBmb3JtYXQAY2FuJSx0IHVzZSBhcyBwYWxldHRlIChubyBnbG9iYWwgY29sb3IgdGFibGUpAHRoZXJlIHdlcmUgZXJyb3JzIHJlYWRpbmcgdGhpcyBHSUYAZW1wdHkgb3V0cHV0IEdJRiBub3Qgd3JpdHRlbgBodWdlIEdJRiwgY29uc2VydmluZyBtZW1vcnkgKHByb2Nlc3NpbmcgbWF5IHRha2UgYSB3aGlsZSkAc3JjaS0+cmVmY291bnQgPiAxAG1lcmdlX2ZyYW1lX2ludGVydmFsACVzOiVzJXMgZmF0YWwgZXJyb3I6IAAlczolcyVzIHdhcm5pbmc6IAAlczolcyVzIAA6ACUuKnMlLipzACAgICAAICUzZDogIyUwMlglMDJYJTAyWABcYQBcYgBcZgBcbgBccgBcdABcdgBcXABcMDAwAFwlMDNvACAgZXh0ZW5zaW9uICVkOiAAYXBwICcAJyVjJyAoMHglMDJYKQAweCUwMlgAIGF0IGVuZAAgYmVmb3JlICMlZAAgcGFja2V0aXplZAAgICAgJTA4eDogACUwMnggICAAJTAyeCUwMnggACAgICAgAG5vbmUAYXNpcwBiYWNrZ3JvdW5kAHByZXZpb3VzADQANQA2ADcAJWcgJWcgJWcAMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRgAlMXglMXglMXgAJTJ4JTJ4JTJ4AG1heGltdW0gMjU2IGNvbG9ycyBhbGxvd2VkIGluIGNvbG9ybWFwAGZpbGUgbm90IGluIGNvbG9ybWFwIGZvcm1hdABmMSA+PSAwICYmIGYyIDwgZnNldC0+Y291bnQAbWVyZ2VyX2ZsYXR0ZW4AY3JvcHBpbmcgZGltZW5zaW9ucyBkb24lLHQgZml0IGltYWdlAHRyYW5zcGFyZW50ACVzIGNvbG9yIG91dCBvZiByYW5nZQAlcyBjb2xvciBub3QgaW4gY29sb3JtYXAAZGVzdC0+bmltYWdlcyA+IDAAZml4X3RvdGFsX2Nyb3AAaXJyZWxldmFudCBiYWNrZ3JvdW5kIGNvbG9yCiAgKFRoZSBiYWNrZ3JvdW5kIHdpbGwgYXBwZWFyIHRyYW5zcGFyZW50IGJlY2F1c2UgIHRoZSBmaXJzdCBpbWFnZSBjb250YWlucyB0cmFuc3BhcmVuY3kuKQBpcnJlbGV2YW50IGJhY2tncm91bmQgY29sb3IAaW5wdXQgaW1hZ2VzIGhhdmUgY29uZmxpY3RpbmcgYmFja2dyb3VuZCBjb2xvcnMKICAoVGhpcyBtZWFucyBzb21lIGFuaW1hdGlvbiBmcmFtZXMgbWF5IGFwcGVhciBpbmNvcnJlY3QuKQBpbnB1dCBpbWFnZXMgaGF2ZSBjb25mbGljdGluZyBiYWNrZ3JvdW5kIGNvbG9ycwBNb2RlIG9wdGlvbnM6IGF0IG1vc3Qgb25lLCBiZWZvcmUgYW55IGZpbGVuYW1lcy4KICAtbSwgLS1tZXJnZSAgICAgICAgICAgICAgICAgICBNZXJnZSBtb2RlOiBjb21iaW5lIGlucHV0cywgd3JpdGUgc3Rkb3V0LgogIC1iLCAtLWJhdGNoICAgICAgICAgICAgICAgICAgIEJhdGNoIG1vZGU6IG1vZGlmeSBpbnB1dHMsIHdyaXRlIGJhY2sgdG8KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lIGZpbGVuYW1lcy4KICAtZSwgLS1leHBsb2RlICAgICAgICAgICAgICAgICBFeHBsb2RlIG1vZGU6IHdyaXRlIE4gZmlsZXMgZm9yIGVhY2ggaW5wdXQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lIHBlciBmcmFtZSwgdG8gJ2lucHV0LmZyYW1lLW51bWJlcicuCiAgLUUsIC0tZXhwbG9kZS1ieS1uYW1lICAgICAgICAgRXhwbG9kZSBtb2RlLCBidXQgd3JpdGUgJ2lucHV0Lm5hbWUnLgoAR2VuZXJhbCBvcHRpb25zOiBBbHNvIC0tbm8tT1BUSU9OIGZvciBpbmZvIGFuZCB2ZXJib3NlLgogIC1JLCAtLWluZm8gICAgICAgICAgICAgICAgICAgIFByaW50IGluZm8gYWJvdXQgaW5wdXQgR0lGcy4gVHdvIC1JJ3MgbWVhbnMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwgb3V0cHV0IGlzIG5vdCBzdXBwcmVzc2VkLgogICAgICAtLWNvbG9yLWluZm8sIC0tY2luZm8gICAgIC0taW5mbyBwbHVzIGNvbG9ybWFwIGRldGFpbHMuCiAgICAgIC0tZXh0ZW5zaW9uLWluZm8sIC0teGluZm8gLS1pbmZvIHBsdXMgZXh0ZW5zaW9uIGRldGFpbHMuCiAgICAgIC0tc2l6ZS1pbmZvLCAtLXNpbmZvICAgICAgLS1pbmZvIHBsdXMgY29tcHJlc3Npb24gaW5mb3JtYXRpb24uCiAgLVYsIC0tdmVyYm9zZSAgICAgICAgICAgICAgICAgUHJpbnRzIHByb2dyZXNzIGluZm9ybWF0aW9uLgAgIC1oLCAtLWhlbHAgICAgICAgICAgICAgICAgICAgIFByaW50IHRoaXMgbWVzc2FnZSBhbmQgZXhpdC4KICAgICAgLS12ZXJzaW9uICAgICAgICAgICAgICAgICBQcmludCB2ZXJzaW9uIG51bWJlciBhbmQgZXhpdC4KICAtbywgLS1vdXRwdXQgRklMRSAgICAgICAgICAgICBXcml0ZSBvdXRwdXQgdG8gRklMRS4KICAtdywgLS1uby13YXJuaW5ncyAgICAgICAgICAgICBEb24ndCByZXBvcnQgd2FybmluZ3MuCiAgICAgIC0tbm8taWdub3JlLWVycm9ycyAgICAgICAgUXVpdCBvbiB2ZXJ5IGVycm9uZW91cyBpbnB1dCBHSUZzLgogICAgICAtLWNvbnNlcnZlLW1lbW9yeSAgICAgICAgIENvbnNlcnZlIG1lbW9yeSBhdCB0aGUgZXhwZW5zZSBvZiBzcGVlZC4KICAgICAgLS1tdWx0aWZpbGUgICAgICAgICAgICAgICBTdXBwb3J0IGNvbmNhdGVuYXRlZCBHSUYgZmlsZXMuCgBGcmFtZSBzZWxlY3Rpb25zOiAgICAgICAgICAgICAgICNudW0sICNudW0xLW51bTIsICNudW0xLSwgI25hbWUKCkZyYW1lIGNoYW5nZSBvcHRpb25zOgogIC0tZGVsZXRlIEZSQU1FUyAgICAgICAgICAgICAgIERlbGV0ZSBGUkFNRVMgZnJvbSBpbnB1dC4KICAtLWluc2VydC1iZWZvcmUgRlJBTUUgR0lGUyAgICBJbnNlcnQgR0lGUyBiZWZvcmUgRlJBTUVTIGluIGlucHV0LgogIC0tYXBwZW5kIEdJRlMgICAgICAgICAgICAgICAgIEFwcGVuZCBHSUZTIHRvIGlucHV0LgogIC0tcmVwbGFjZSBGUkFNRVMgR0lGUyAgICAgICAgIFJlcGxhY2UgRlJBTUVTIHdpdGggR0lGUyBpbiBpbnB1dC4KICAtLWRvbmUgICAgICAgICAgICAgICAgICAgICAgICBEb25lIHdpdGggZnJhbWUgY2hhbmdlcy4KAEltYWdlIG9wdGlvbnM6IEFsc28gLS1uby1PUFRJT04gYW5kIC0tc2FtZS1PUFRJT04uCiAgLUIsIC0tYmFja2dyb3VuZCBDT0wgICAgICAgICAgTWFrZSBDT0wgdGhlIGJhY2tncm91bmQgY29sb3IuCiAgICAgIC0tY3JvcCBYLFkrV3hILCAtLWNyb3AgWCxZLVgyLFkyCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ3JvcCB0aGUgaW1hZ2UuCiAgICAgIC0tY3JvcC10cmFuc3BhcmVuY3kgICAgICAgQ3JvcCB0cmFuc3BhcmVudCBib3JkZXJzIG9mZiB0aGUgaW1hZ2UuCiAgICAgIC0tZmxpcC1ob3Jpem9udGFsLCAtLWZsaXAtdmVydGljYWwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGbGlwIHRoZSBpbWFnZS4AICAtaSwgLS1pbnRlcmxhY2UgICAgICAgICAgICAgICBUdXJuIG9uIGludGVybGFjaW5nLgogIC1TLCAtLWxvZ2ljYWwtc2NyZWVuIFd4SCAgICAgIFNldCBsb2dpY2FsIHNjcmVlbiB0byBXeEguCiAgLXAsIC0tcG9zaXRpb24gWCxZICAgICAgICAgICAgU2V0IGZyYW1lIHBvc2l0aW9uIHRvIChYLFkpLgogICAgICAtLXJvdGF0ZS05MCwgLS1yb3RhdGUtMTgwLCAtLXJvdGF0ZS0yNzAsIC0tbm8tcm90YXRlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUm90YXRlIHRoZSBpbWFnZS4KICAtdCwgLS10cmFuc3BhcmVudCBDT0wgICAgICAgICBNYWtlIENPTCB0cmFuc3BhcmVudC4KAEV4dGVuc2lvbiBvcHRpb25zOgogICAgICAtLWFwcC1leHRlbnNpb24gTiBEICAgICAgIEFkZCBhbiBhcHAgZXh0ZW5zaW9uIG5hbWVkIE4gd2l0aCBkYXRhIEQuCiAgLWMsIC0tY29tbWVudCBURVhUICAgICAgICAgICAgQWRkIGEgY29tbWVudCBiZWZvcmUgdGhlIG5leHQgZnJhbWUuCiAgICAgIC0tZXh0ZW5zaW9uIE4gRCAgICAgICAgICAgQWRkIGFuIGV4dGVuc2lvbiBudW1iZXIgTiB3aXRoIGRhdGEgRC4KICAtbiwgLS1uYW1lIFRFWFQgICAgICAgICAgICAgICBTZXQgbmV4dCBmcmFtZSdzIG5hbWUuCiAgICAgIC0tbm8tY29tbWVudHMsIC0tbm8tbmFtZXMsIC0tbm8tZXh0ZW5zaW9ucwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlbW92ZSBjb21tZW50cyAobmFtZXMsIGV4dGVuc2lvbnMpIGZyb20gaW5wdXQuAEFuaW1hdGlvbiBvcHRpb25zOiBBbHNvIC0tbm8tT1BUSU9OIGFuZCAtLXNhbWUtT1BUSU9OLgogIC1kLCAtLWRlbGF5IFRJTUUgICAgICAgICAgICAgIFNldCBmcmFtZSBkZWxheSB0byBUSU1FIChpbiAxLzEwMHNlYykuCiAgLUQsIC0tZGlzcG9zYWwgTUVUSE9EICAgICAgICAgU2V0IGZyYW1lIGRpc3Bvc2FsIHRvIE1FVEhPRC4KICAtbCwgLS1sb29wY291bnRbPU5dICAgICAgICAgICBTZXQgbG9vcCBleHRlbnNpb24gdG8gTiAoZGVmYXVsdCBmb3JldmVyKS4KICAtTywgLS1vcHRpbWl6ZVs9TEVWRUxdICAgICAgICBPcHRpbWl6ZSBvdXRwdXQgR0lGcy4KICAtVSwgLS11bm9wdGltaXplICAgICAgICAgICAgICBVbm9wdGltaXplIGlucHV0IEdJRnMuACAgLWosIC0tdGhyZWFkc1s9VEhSRUFEU10gICAgICAgVXNlIG11bHRpcGxlIHRocmVhZHMgdG8gaW1wcm92ZSBzcGVlZC4ACldob2xlLUdJRiBvcHRpb25zOiBBbHNvIC0tbm8tT1BUSU9OLgogICAgICAtLWNhcmVmdWwgICAgICAgICAgICAgICAgIFdyaXRlIGxhcmdlciBHSUZzIHRoYXQgYXZvaWQgYnVncyBpbiBvdGhlcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW1zLgogICAgICAtLWNoYW5nZS1jb2xvciBDT0wxIENPTDIgIENoYW5nZSBDT0wxIHRvIENPTDIgdGhyb3VnaG91dC4KICAtaywgLS1jb2xvcnMgTiAgICAgICAgICAgICAgICBSZWR1Y2UgdGhlIG51bWJlciBvZiBjb2xvcnMgdG8gTi4KICAgICAgLS1jb2xvci1tZXRob2QgTUVUSE9EICAgICBTZXQgbWV0aG9kIGZvciBjaG9vc2luZyByZWR1Y2VkIGNvbG9ycy4KICAtZiwgLS1kaXRoZXIgICAgICAgICAgICAgICAgICBEaXRoZXIgaW1hZ2UgYWZ0ZXIgY2hhbmdpbmcgY29sb3JtYXAuACAgICAgIC0tZ2FtbWEgRyAgICAgICAgICAgICAgICAgU2V0IGdhbW1hIGZvciBjb2xvciByZWR1Y3Rpb24gWzIuMl0uACAgICAgIC0tbG9zc3lbPUxPU1NJTkVTU10gICAgICAgQWx0ZXIgaW1hZ2UgY29sb3JzIHRvIHNocmluayBvdXRwdXQgZmlsZSBzaXplCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXQgdGhlIGNvc3Qgb2YgYXJ0aWZhY3RzIGFuZCBub2lzZS4KICAgICAgLS1yZXNpemUgV3hIICAgICAgICAgICAgICBSZXNpemUgdGhlIG91dHB1dCBHSUYgdG8gV3hILgogICAgICAtLXJlc2l6ZS13aWR0aCBXICAgICAgICAgIFJlc2l6ZSB0byB3aWR0aCBXIGFuZCBwcm9wb3J0aW9uYWwgaGVpZ2h0LgogICAgICAtLXJlc2l6ZS1oZWlnaHQgSCAgICAgICAgIFJlc2l6ZSB0byBoZWlnaHQgSCBhbmQgcHJvcG9ydGlvbmFsIHdpZHRoLgogICAgICAtLXJlc2l6ZS1maXQgV3hIICAgICAgICAgIFJlc2l6ZSBpZiBuZWNlc3NhcnkgdG8gZml0IHdpdGhpbiBXeEguACAgICAgIC0tc2NhbGUgWEZBQ1RPUlt4WUZBQ1RPUl0gU2NhbGUgdGhlIG91dHB1dCBHSUYgYnkgWEZBQ1RPUnhZRkFDVE9SLgogICAgICAtLXJlc2l6ZS1tZXRob2QgTUVUSE9EICAgIFNldCByZXNpemluZyBtZXRob2QuCiAgICAgIC0tcmVzaXplLWNvbG9ycyBOICAgICAgICAgUmVzaXplIGNhbiBhZGQgbmV3IGNvbG9ycyB1cCB0byBOLgogICAgICAtLXRyYW5zZm9ybS1jb2xvcm1hcCBDTUQgIFRyYW5zZm9ybSBlYWNoIG91dHB1dCBjb2xvcm1hcCBieSBzaGVsbCBDTUQuCiAgICAgIC0tdXNlLWNvbG9ybWFwIENNQVAgICAgICAgU2V0IG91dHB1dCBHSUYncyBjb2xvcm1hcCB0byBDTUFQLCB3aGljaCBjYW4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSAnd2ViJywgJ2dyYXknLCAnYncnLCBvciBhIEdJRiBmaWxlLgoAAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAP////////////////////////////////////8KAAAACwAAAAwAAAANAAAADgAAAA8AAAD//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////woAAAALAAAADAAAAA0AAAAOAAAADwAAAHhmb3JtLmMAAAAAAC90bXAvZ2lmc2ljbGUuWFhYWFhYAGNhbiUsdCBjcmVhdGUgdGVtcG9yYXJ5IGZpbGUhACVzICA+JXMAdwBjYW4lLHQgcnVuIGNvbG9yIHRyYW5zZm9ybWF0aW9uIGNvbW1hbmQ6ICVzACVkICVkICVkCgBjb2xvciB0cmFuc2Zvcm1hdGlvbiBlcnJvcjogJXMAY29sb3IgdHJhbnNmb3JtYXRpb24gY29tbWFuZCBmYWlsZWQAcgBjb2xvciB0cmFuc2Zvcm1hdGlvbiBjb21tYW5kIGdlbmVyYXRlZCBubyBvdXRwdXQAPGNvbG9yIHRyYW5zZm9ybWF0aW9uPgB0b28gZmV3IGNvbG9ycyBpbiBjb2xvciB0cmFuc2Zvcm1hdGlvbiByZXN1bHRzAHRvbyBtYW55IGNvbG9ycyBpbiBjb2xvciB0cmFuc2Zvcm1hdGlvbiByZXN1bHRzAHJvdGF0aW9uID09IDEgfHwgcm90YXRpb24gPT0gMwByb3RhdGVfaW1hZ2UAbmV3IGltYWdlIGlzIHRvbyBsYXJnZSAobWF4IHNpemUgNjU1MzV4NjU1MzUpAGdmcy0+bmltYWdlcyA+IDAAcmVzaXplX3N0cmVhbQBpbWFnZSB0b28gY29tcGxleCBmb3IgbXVsdGl0aHJlYWRlZCByZXNpemUsIHVzaW5nIDEgdGhyZWFkCiAgKFRyeSBydW5uaW5nIHRoZSBHSUYgdGhyb3VnaCAlPGdpZnNpY2xlIC1VJT4uKQBzY3R4LT5rZDMgPT0gJnNjdHgtPmdsb2JhbF9rZDMAc2NhbGVfaW1hZ2VfdXBkYXRlX2dsb2JhbF9rZDMAKHVuc2lnbmVkKSBpIDwgKHVuc2lnbmVkKSBrZDMtPm5pdGVtcwAuL2tjb2xvci5oAGtkM19kaXNhYmxlAGtkMy0+ZGlzYWJsZWQgPCAwIHx8IGtkMy0+ZGlzYWJsZWQgPT0gaQAha3NzLT5kYXRhICYmICFrc3MtPnNjcmF0Y2gAa3NzY3JlZW5faW5pdAAha2NzLT5kYXRhICYmICFrY3MtPnNjcmF0Y2gAa2NzY3JlZW5faW5pdAAodW5zaWduZWQpIGdmaS0+bGVmdCArIGdmaS0+d2lkdGggPD0ga3NzLT53aWR0aABrc3NjcmVlbl9hcHBseQAodW5zaWduZWQpIGdmaS0+dG9wICsgZ2ZpLT5oZWlnaHQgPD0ga3NzLT5oZWlnaHQAa3NzY3JlZW5fZGlzcG9zZQAodW5zaWduZWQpIGdmaS0+bGVmdCArIGdmaS0+d2lkdGggPD0ga2NzLT53aWR0aABrY3NjcmVlbl9kaXNwb3NlACh1bnNpZ25lZCkgZ2ZpLT50b3AgKyBnZmktPmhlaWdodCA8PSBrY3MtPmhlaWdodABrY3NjcmVlbl9hcHBseQB3LT5pcG9zID49IHlpMCAmJiB3LT5pcG9zIDwgeWkxAHNjYWxlX2ltYWdlX2RhdGFfd2VpZ2h0ZWQAYXBwZW5kAGFwcC1leHRlbnNpb24Abm8tYXBwLWV4dGVuc2lvbnMAYmFja2dyb3VuZABiYXRjaABiZwBjYXJlZnVsAGNoYW5nZS1jb2xvcgBjaW5mbwBjbGlwAGNvbG9ycwBjb2xvci1tZXRob2QAY29sb3ItaW5mbwBjb21tZW50AG5vLWNvbW1lbnRzAGNvbnNlcnZlLW1lbW9yeQBjcm9wAGNyb3AtdHJhbnNwYXJlbmN5AGRlbGF5AGRlbGV0ZQBkaXNwb3NhbABkaXRoZXIAZG9uZQBleHBsb2RlAGV4cGxvZGUtYnktbmFtZQBleHRlbnNpb24Abm8tZXh0ZW5zaW9uAG5vLWV4dGVuc2lvbnMAZXh0ZW5zaW9uLWluZm8AZmxpcC1ob3Jpem9udGFsAGZsaXAtdmVydGljYWwAbm8tZmxpcABnYW1tYQBncmF5AGhlbHAAaWdub3JlLWVycm9ycwBpbmZvAGluc2VydC1iZWZvcmUAaW50ZXJsYWNlAGxvZ2ljYWwtc2NyZWVuAGxvb3Bjb3VudABsb3NzeQBtZXJnZQBtZXRob2QAbXVsdGlmaWxlAG5hbWUAbmV4dGZpbGUAbm8tbmFtZXMAb3B0aW1pemUAb3V0cHV0AHBvc2l0aW9uAHJlcGxhY2UAcmVzaXplAHJlc2l6ZS13aWR0aAByZXNpemUtaGVpZ2h0AHJlc2l6AHJlc2kAcmVzAHJlc2l6ZS1maXQAcmVzaXplLWZpdC13aWR0aAByZXNpemUtZml0LWhlaWdodAByZXNpemUtZmkAcmVzaXplLWYAcmVzaXplLXRvdWNoAHJlc2l6ZS10b3VjaC13aWR0aAByZXNpemUtdG91Y2gtaGVpZ2h0AHJlc2l6ZS10b3VjAHJlc2l6ZS10b3UAcmVzaXplLXRvAHJlc2l6ZS10AHJlc2l6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ZQB0cmFpbGluZyBnYXJiYWdlIGlnbm9yZWQAZmlsZSBub3QgaW4gR0lGIGZvcm1hdAAlczogJTwtLW11bHRpZmlsZSU+IGlzIHVzZWZ1bCBvbmx5IGluIG1lcmdlIG1vZGUAI3N0ZGluIwBHSUYgdG9vIGNvbXBsZXggdG8gdW5vcHRpbWl6ZQogIChUaGUgcmVhc29uIHdhcyBsb2NhbCBjb2xvciB0YWJsZXMgb3IgY29tcGxleCB0cmFuc3BhcmVuY3kuCiAgVHJ5IHJ1bm5pbmcgdGhlIEdJRiB0aHJvdWdoICU8Z2lmc2ljbGUgLS1jb2xvcnM9MjU1JT4gZmlyc3QuKQBHSUYgdG9vIGNvbXBsZXggdG8gdW5vcHRpbWl6ZQAtAGluZmluaXRlAGZvcmV2ZXIAbm9uZQBhc2lzAHByZXZpb3VzAGRpdmVyc2l0eQBibGVuZC1kaXZlcnNpdHkAbWVkaWFuLWN1dABrZWVwLWVtcHR5AG5vLWtlZXAtZW1wdHkAZHJvcC1lbXB0eQBuby1kcm9wLWVtcHR5AHBvaW50AHNhbXBsZQBtaXgAYm94AGNhdHJvbQBsYW5jem9zAGxhbmN6b3MyAGxhbmN6b3MzAG1pdGNoZWxsAGZhc3QAZ29vZAAAAAAAALBGAAD4RQAA60UAAGtZAACwRQAA8EYAABdHAADURQAAJUYAAHhZAAB9WQAAAAAAAMlGAACGWQAAlVkAAKJZAACuWQAAAUYAALxZAADFWQAAXUUAANVZAAAoRwAA6lkAAH9GAAD+WQAADFoAAGRpc3Bvc2FsIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA3AENPTE9SMiBtdXN0IGJlIGluIFJHQiBmb3JtYXQgaW4gJTwtLWNoYW5nZS1jb2xvciBDT0xPUjEgQ09MT1IyJT4AYXJndW1lbnQgdG8gJU8gbXVzdCBiZSBiZXR3ZWVuIDIgYW5kIDI1NgBkZWZhdWx0AHBvc3Rlcml6ZQAlPCVzJT4gaXMgbm90IGEgdmFsaWQgZGl0aGVyAHNSR0IAc3JnYgAlTyBzaG91bGQgYmUgYSBudW1iZXIgb3IgJTxzcmdiJT4Ab25lIG9mIFcgYW5kIEggbXVzdCBiZSBwb3NpdGl2ZSBpbiAlPCVzIFd4SCU+ACVzIGFyZ3VtZW50IG11c3QgYmUgcG9zaXRpdmUAJXMgWCBhbmQgWSBmYWN0b3JzIG11c3QgYmUgcG9zaXRpdmUAJXMgY2FuIGJlIGF0IG1vc3QgMjU2AExDREYgR2lmc2ljbGUgJXMKADEuOTIAZnJhbWUAaW5wdXQAAAAFWwAAFFsAACU8LS1pbmZvJT4gc3VwcHJlc3NlcyBub3JtYWwgb3V0cHV0LCBjYW4lLHQgdXNlIHdpdGggYW4KICBvdXRwdXQgbW9kZSBsaWtlICU8LS1tZXJnZSU+IG9yICU8LS1iYXRjaCU+LgogIChUcnkgJTwtSUklPiwgd2hpY2ggZG9lc24lLHQgc3VwcHJlc3Mgbm9ybWFsIG91dHB1dC4pAHRvbyBsYXRlIHRvIGNoYW5nZSBtb2RlcwBJcyBhIHRlcm1pbmFsAHJiACVzADx1bmtub3duPgAlczojJWQAcmVhZCBlcnJvcjogAAAlcyVzACVzJXMgKCVkIHRpbWVzKQAocGx1cyBtb3JlIGVycm9yczsgaXMgdGhpcyBHSUYgY29ycnVwdD8pAG1pc3NpbmcgJWx1IHBpeGVsAGZhdGFsIGVycm9yOiB0b28gbWFueSBtaXNzaW5nIHBpeGVscywgZ2l2aW5nIHVwAHcAbWVyZ2VfYW5kX3dyaXRlX2ZyYW1lcwAjc3Rkb3V0IwB0cml2aWFsIGFkYXB0aXZlIHBhbGV0dGUgKG9ubHkgJWQgY29sb3JzIGluIHNvdXJjZSkAY2FuJ3QgaGFwcGVuAHdiADxzdGRvdXQ+AElzIGEgdGVybWluYWw6IHRyeSBgLW8gT1VUUFVURklMRWAAcmVkdW5kYW50ICVzIG9wdGlvbgogIChUaGUgJXMgb3B0aW9uIHdhcyBvdmVycmlkZGVuIGJ5IGFub3RoZXIgJXMgb3B0aW9uCiAgYmVmb3JlIGl0IGhhZCBhbnkgZWZmZWN0LikAcmVkdW5kYW50ICVzIG9wdGlvbgB0cmFuc3BhcmVuY3kAZmxpcAByb3RhdGlvbgBsb2dpY2FsIHNjcmVlbgBvcHRpbWl6YXRpb24Ab3V0cHV0IGZpbGUAY29sb3JtYXAgc2l6ZQBjb2xvcm1hcABjb2xvcm1hcCBtZXRob2QAY29sb3IgdHJhbnNmb3JtYXRpb24AbWVtb3J5IGNvbnNlcnZhdGlvbgByZXNpemUgbWV0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c3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE5vIGVycm9yIGluZm9ybWF0aW9uAAByd2EAgIYAABCHAACghwAAAAAAABEACgAREREAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAEQAPChEREQMKBwABAAkLCwAACQYLAAALAAYRAAAAERERAEHh6AELIQsAAAAAAAAAABEACgoREREACgAAAgAJCwAAAAkACwAACwBBm+kBCwEMAEGn6QELFQwAAAAADAAAAAAJDAAAAAAADAAADABB1ekBCwEOAEHh6QELFQ0AAAAEDQAAAAAJDgAAAAAADgAADgBBj+oBCwEQAEGb6gELHg8AAAAADwAAAAAJEAAAAAAAEAAAEAAAEgAAABISEgBB0uoBCw4SAAAAEhISAAAAAAAACQBBg+sBCwELAEGP6wELFQoAAAAACgAAAAAJCwAAAAAACwAACwBBvesBCwEMAEHJ6wELJwwAAAAADAAAAAAJDAAAAAAADAAADAAALSsgICAwWDB4AChudWxsKQBBgOwBCzAwMTIzNDU2Nzg5QUJDREVGLTBYKzBYIDBYLTB4KzB4IDB4AGluZgBJTkYATkFOAC4AQdzsAQsBPwBBg+0BCwX//////wBB0O0BC4AEAgAAwAMAAMAEAADABQAAwAYAAMAHAADACAAAwAkAAMAKAADACwAAwAwAAMANAADADgAAwA8AAMAQAADAEQAAwBIAAMATAADAFAAAwBUAAMAWAADAFwAAwBgAAMAZAADAGgAAwBsAAMAcAADAHQAAwB4AAMAfAADAAAAAswEAAMMCAADDAwAAwwQAAMMFAADDBgAAwwcAAMMIAADDCQAAwwoAAMMLAADDDAAAww0AANMOAADDDwAAwwAADLsBAAzDAgAMwwMADMMEAAzTAAAAAP////////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAECBAcDBgUAAAAYAAAANQAAAHEAAABr////zvv//5K///9pbmZpbml0eQBuYW4AQeDxAQs2CgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QXRdJ4AV529KoBwUg///z4nWFhYWFhYAEGg8gEL1xUDAAAABAAAAAQAAAAGAAAAg/miAERObgD8KRUA0VcnAN009QBi28AAPJmVAEGQQwBjUf4Au96rALdhxQA6biQA0k1CAEkG4AAJ6i4AHJLRAOsd/gApsRwA6D6nAPU1ggBEuy4AnOmEALQmcABBfl8A1pE5AFODOQCc9DkAi1+EACj5vQD4HzsA3v+XAA+YBQARL+8AClqLAG0fbQDPfjYACcsnAEZPtwCeZj8ALepfALondQDl68cAPXvxAPc5BwCSUooA+2vqAB+xXwAIXY0AMANWAHv8RgDwq2sAILzPADb0mgDjqR0AXmGRAAgb5gCFmWUAoBRfAI1AaACA2P8AJ3NNAAYGMQDKVhUAyahzAHviYABrjMAAGcRHAM1nwwAJ6NwAWYMqAIt2xACmHJYARK/dABlX0QClPgUABQf/ADN+PwDCMugAmE/eALt9MgAmPcMAHmvvAJ/4XgA1HzoAf/LKAPGHHQB8kCEAaiR8ANVu+gAwLXcAFTtDALUUxgDDGZ0ArcTCACxNQQAMAF0Ahn1GAONxLQCbxpoAM2IAALTSfAC0p5cAN1XVANc+9gCjEBgATXb8AGSd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";function pe(){try{if(l)return new Uint8Array(l);if(o)return o(P);throw"both async and sync fetching of the wasm failed"}catch(e){D(e)}}function he(){var e=function(){var r=new Error;if(!r.stack){try{throw new Error}catch(e){r=e}if(!r.stack)return"(no stack trace available)"}return r.stack.toString()}();return h.extraStackTrace&&(e+="\\n"+h.extraStackTrace()),e.replace(/\\b_Z[\\w\\d_]+/g,function(e){return e===e?e:e+" ["+e+"]"})}J.push({func:function(){_e()}});var me=s?function(){var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:"undefined"!=typeof dateNow?dateNow:function(){return performance.now()},we=!0;function A(e){return k[De()>>2]=e}var x={splitPath:function(e){return/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/.exec(e).slice(1)},normalizeArray:function(e,r){for(var t=0,n=e.length-1;0<=n;n--){var o=e[n];"."===o?e.splice(n,1):".."===o?(e.splice(n,1),t++):t&&(e.splice(n,1),t--)}if(r)for(;t;t--)e.unshift("..");return e},normalize:function(e){var r="/"===e.charAt(0),t="/"===e.substr(-1);return(e=(e=x.normalizeArray(e.split("/").filter(function(e){return!!e}),!r).join("/"))||r?e:".")&&t&&(e+="/"),(r?"/":"")+e},dirname:function(e){var e=x.splitPath(e),r=e[0],e=e[1];return r||e?r+(e=e&&e.substr(0,e.length-1)):"."},basename:function(e){if("/"===e)return"/";var r=e.lastIndexOf("/");return-1===r?e:e.substr(r+1)},extname:function(e){return x.splitPath(e)[3]},join:function(){var e=Array.prototype.slice.call(arguments,0);return x.normalize(e.join("/"))},join2:function(e,r){return x.normalize(e+"/"+r)}},R={resolve:function(){for(var e="",r=!1,t=arguments.length-1;-1<=t&&!r;t--){var n=0<=t?arguments[t]:T.cwd();if("string"!=typeof n)throw new TypeError("Arguments to path.resolve must be strings");if(!n)return"";e=n+"/"+e,r="/"===n.charAt(0)}return(r?"/":"")+(e=x.normalizeArray(e.split("/").filter(function(e){return!!e}),!r).join("/"))||"."},relative:function(e,r){function t(e){for(var r=0;r<e.length&&""===e[r];r++);for(var t=e.length-1;0<=t&&""===e[t];t--);return t<r?[]:e.slice(r,t-r+1)}e=R.resolve(e).substr(1),r=R.resolve(r).substr(1);for(var n=t(e.split("/")),o=t(r.split("/")),i=Math.min(n.length,o.length),a=i,s=0;s<i;s++)if(n[s]!==o[s]){a=s;break}for(var u=[],s=a;s<n.length;s++)u.push("..");return(u=u.concat(o.slice(a))).join("/")}},M={ttys:[],init:function(){},shutdown:function(){},register:function(e,r){M.ttys[e]={input:[],output:[],ops:r},T.registerDevice(e,M.stream_ops)},stream_ops:{open:function(e){var r=M.ttys[e.node.rdev];if(!r)throw new T.ErrnoError(43);e.tty=r,e.seekable=!1},close:function(e){e.tty.ops.flush(e.tty)},flush:function(e){e.tty.ops.flush(e.tty)},read:function(e,r,t,n,o){if(!e.tty||!e.tty.ops.get_char)throw new T.ErrnoError(60);for(var i,a=0,s=0;s<n;s++){try{i=e.tty.ops.get_char(e.tty)}catch(e){throw new T.ErrnoError(29)}if(void 0===i&&0===a)throw new T.ErrnoError(6);if(null==i)break;a++,r[t+s]=i}return a&&(e.node.timestamp=Date.now()),a},write:function(e,r,t,n,o){if(!e.tty||!e.tty.ops.put_char)throw new T.ErrnoError(60);try{for(var i=0;i<n;i++)e.tty.ops.put_char(e.tty,r[t+i])}catch(e){throw new T.ErrnoError(29)}return n&&(e.node.timestamp=Date.now()),i}},default_tty_ops:{get_char:function(e){if(!e.input.length){var r=null;if(s){var t=Buffer.alloc?Buffer.alloc(256):new Buffer(256),n=0;try{n=i.readSync(process.stdin.fd,t,0,256,null)}catch(e){if(-1==e.toString().indexOf("EOF"))throw e;n=0}r=0<n?t.slice(0,n).toString("utf-8"):null}else"undefined"!=typeof window&&"function"==typeof window.prompt?null!==(r=window.prompt("Input: "))&&(r+="\\n"):"function"==typeof readline&&null!==(r=readline())&&(r+="\\n");if(!r)return null;e.input=ye(r,!0)}return e.input.shift()},put_char:function(e,r){null===r||10===r?(m(g(e.output,0)),e.output=[]):0!=r&&e.output.push(r)},flush:function(e){e.output&&0<e.output.length&&(m(g(e.output,0)),e.output=[])}},default_tty1_ops:{put_char:function(e,r){null===r||10===r?(w(g(e.output,0)),e.output=[]):0!=r&&e.output.push(r)},flush:function(e){e.output&&0<e.output.length&&(w(g(e.output,0)),e.output=[])}}},B={ops_table:null,mount:function(e){return B.createNode(null,"/",16895,0)},createNode:function(e,r,t,n){if(T.isBlkdev(t)||T.isFIFO(t))throw new T.ErrnoError(63);B.ops_table||(B.ops_table={dir:{node:{getattr:B.node_ops.getattr,setattr:B.node_ops.setattr,lookup:B.node_ops.lookup,mknod:B.node_ops.mknod,rename:B.node_ops.rename,unlink:B.node_ops.unlink,rmdir:B.node_ops.rmdir,readdir:B.node_ops.readdir,symlink:B.node_ops.symlink},stream:{llseek:B.stream_ops.llseek}},file:{node:{getattr:B.node_ops.getattr,setattr:B.node_ops.setattr},stream:{llseek:B.stream_ops.llseek,read:B.stream_ops.read,write:B.stream_ops.write,allocate:B.stream_ops.allocate,mmap:B.stream_ops.mmap,msync:B.stream_ops.msync}},link:{node:{getattr:B.node_ops.getattr,setattr:B.node_ops.setattr,readlink:B.node_ops.readlink},stream:{}},chrdev:{node:{getattr:B.node_ops.getattr,setattr:B.node_ops.setattr},stream:T.chrdev_stream_ops}});t=T.createNode(e,r,t,n);return T.isDir(t.mode)?(t.node_ops=B.ops_table.dir.node,t.stream_ops=B.ops_table.dir.stream,t.contents={}):T.isFile(t.mode)?(t.node_ops=B.ops_table.file.node,t.stream_ops=B.ops_table.file.stream,t.usedBytes=0,t.contents=null):T.isLink(t.mode)?(t.node_ops=B.ops_table.link.node,t.stream_ops=B.ops_table.link.stream):T.isChrdev(t.mode)&&(t.node_ops=B.ops_table.chrdev.node,t.stream_ops=B.ops_table.chrdev.stream),t.timestamp=Date.now(),e&&(e.contents[r]=t),t},getFileDataAsRegularArray:function(e){if(e.contents&&e.contents.subarray){for(var r=[],t=0;t<e.usedBytes;++t)r.push(e.contents[t]);return r}return e.contents},getFileDataAsTypedArray:function(e){return e.contents?e.contents.subarray?e.contents.subarray(0,e.usedBytes):new Uint8Array(e.contents):new Uint8Array(0)},expandFileStorage:function(e,r){var t=e.contents?e.contents.length:0;r<=t||(r=Math.max(r,t*(t<1048576?2:1.125)>>>0),0!=t&&(r=Math.max(r,256)),t=e.contents,e.contents=new Uint8Array(r),0<e.usedBytes&&e.contents.set(t.subarray(0,e.usedBytes),0))},resizeFileStorage:function(e,r){if(e.usedBytes!=r){if(0==r)return e.contents=null,void(e.usedBytes=0);var t;if(!e.contents||e.contents.subarray)return t=e.contents,e.contents=new Uint8Array(r),t&&e.contents.set(t.subarray(0,Math.min(r,e.usedBytes))),void(e.usedBytes=r);if(e.contents||(e.contents=[]),e.contents.length>r)e.contents.length=r;else for(;e.contents.length<r;)e.contents.push(0);e.usedBytes=r}},node_ops:{getattr:function(e){var r={};return r.dev=T.isChrdev(e.mode)?e.id:1,r.ino=e.id,r.mode=e.mode,r.nlink=1,r.uid=0,r.gid=0,r.rdev=e.rdev,T.isDir(e.mode)?r.size=4096:T.isFile(e.mode)?r.size=e.usedBytes:T.isLink(e.mode)?r.size=e.link.length:r.size=0,r.atime=new Date(e.timestamp),r.mtime=new Date(e.timestamp),r.ctime=new Date(e.timestamp),r.blksize=4096,r.blocks=Math.ceil(r.size/r.blksize),r},setattr:function(e,r){void 0!==r.mode&&(e.mode=r.mode),void 0!==r.timestamp&&(e.timestamp=r.timestamp),void 0!==r.size&&B.resizeFileStorage(e,r.size)},lookup:function(e,r){throw T.genericErrors[44]},mknod:function(e,r,t,n){return B.createNode(e,r,t,n)},rename:function(e,r,t){if(T.isDir(e.mode)){var n;try{n=T.lookupNode(r,t)}catch(e){}if(n)for(var o in n.contents)throw new T.ErrnoError(55)}delete e.parent.contents[e.name],e.name=t,(r.contents[t]=e).parent=r},unlink:function(e,r){delete e.contents[r]},rmdir:function(e,r){for(var t in T.lookupNode(e,r).contents)throw new T.ErrnoError(55);delete e.contents[r]},readdir:function(e){var r,t=[".",".."];for(r in e.contents)e.contents.hasOwnProperty(r)&&t.push(r);return t},symlink:function(e,r,t){e=B.createNode(e,r,41471,0);return e.link=t,e},readlink:function(e){if(T.isLink(e.mode))return e.link;throw new T.ErrnoError(28)}},stream_ops:{read:function(e,r,t,n,o){var i=e.node.contents;if(o>=e.node.usedBytes)return 0;var a=Math.min(e.node.usedBytes-o,n);if(8<a&&i.subarray)r.set(i.subarray(o,o+a),t);else for(var s=0;s<a;s++)r[t+s]=i[o+s];return a},write:function(e,r,t,n,o,i){if(r.buffer===y.buffer&&(i=!1),!n)return 0;var a=e.node;if(a.timestamp=Date.now(),r.subarray&&(!a.contents||a.contents.subarray)){if(i)return a.contents=r.subarray(t,t+n),a.usedBytes=n;if(0===a.usedBytes&&0===o)return a.contents=r.slice(t,t+n),a.usedBytes=n;if(o+n<=a.usedBytes)return a.contents.set(r.subarray(t,t+n),o),n}if(B.expandFileStorage(a,o+n),a.contents.subarray&&r.subarray)a.contents.set(r.subarray(t,t+n),o);else for(var s=0;s<n;s++)a.contents[o+s]=r[t+s];return a.usedBytes=Math.max(a.usedBytes,o+n),n},llseek:function(e,r,t){if(1===t?r+=e.position:2===t&&T.isFile(e.node.mode)&&(r+=e.node.usedBytes),r<0)throw new T.ErrnoError(28);return r},allocate:function(e,r,t){B.expandFileStorage(e.node,r+t),e.node.usedBytes=Math.max(e.node.usedBytes,r+t)},mmap:function(e,r,t,n,o,i){if(H(0===r),!T.isFile(e.node.mode))throw new T.ErrnoError(43);var a,s,r=e.node.contents;if(2&i||r.buffer!==v){if((0<n||n+t<r.length)&&(r=r.subarray?r.subarray(n,n+t):Array.prototype.slice.call(r,n,n+t)),s=!0,!(a=be(t)))throw new T.ErrnoError(48);y.set(r,a)}else s=!1,a=r.byteOffset;return{ptr:a,allocated:s}},msync:function(e,r,t,n,o){if(T.isFile(e.node.mode))return 2&o||B.stream_ops.write(e,r,0,n,t,!1),0;throw new T.ErrnoError(43)}}},T={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:!1,ignorePermissions:!0,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function(e){if(e instanceof T.ErrnoError)return A(e.errno);throw e+" : "+he()},lookupPath:function(e,r){if(r=r||{},!(e=R.resolve(T.cwd(),e)))return{path:"",node:null};var t,n={follow_mount:!0,recurse_count:0};for(t in n)void 0===r[t]&&(r[t]=n[t]);if(8<r.recurse_count)throw new T.ErrnoError(32);for(var o=x.normalizeArray(e.split("/").filter(function(e){return!!e}),!1),i=T.root,a="/",s=0;s<o.length;s++){var u=s===o.length-1;if(u&&r.parent)break;if(i=T.lookupNode(i,o[s]),a=x.join2(a,o[s]),!T.isMountpoint(i)||u&&!r.follow_mount||(i=i.mounted.root),!u||r.follow)for(var c=0;T.isLink(i.mode);){var f=T.readlink(a),a=R.resolve(x.dirname(a),f),i=T.lookupPath(a,{recurse_count:r.recurse_count}).node;if(40<c++)throw new T.ErrnoError(32)}}return{path:a,node:i}},getPath:function(e){for(var r,t;;){if(T.isRoot(e))return t=e.mount.mountpoint,r?"/"!==t[t.length-1]?t+"/"+r:t+r:t;r=r?e.name+"/"+r:e.name,e=e.parent}},hashName:function(e,r){for(var t=0,n=0;n<r.length;n++)t=(t<<5)-t+r.charCodeAt(n)|0;return(e+t>>>0)%T.nameTable.length},hashAddNode:function(e){var r=T.hashName(e.parent.id,e.name);e.name_next=T.nameTable[r],T.nameTable[r]=e},hashRemoveNode:function(e){var r=T.hashName(e.parent.id,e.name);if(T.nameTable[r]===e)T.nameTable[r]=e.name_next;else for(var t=T.nameTable[r];t;){if(t.name_next===e){t.name_next=e.name_next;break}t=t.name_next}},lookupNode:function(e,r){var t=T.mayLookup(e);if(t)throw new T.ErrnoError(t,e);for(var t=T.hashName(e.id,r),n=T.nameTable[t];n;n=n.name_next){var o=n.name;if(n.parent.id===e.id&&o===r)return n}return T.lookup(e,r)},createNode:function(e,r,t,n){e=new T.FSNode(e,r,t,n);return T.hashAddNode(e),e},destroyNode:function(e){T.hashRemoveNode(e)},isRoot:function(e){return e===e.parent},isMountpoint:function(e){return!!e.mounted},isFile:function(e){return 32768==(61440&e)},isDir:function(e){return 16384==(61440&e)},isLink:function(e){return 40960==(61440&e)},isChrdev:function(e){return 8192==(61440&e)},isBlkdev:function(e){return 24576==(61440&e)},isFIFO:function(e){return 4096==(61440&e)},isSocket:function(e){return 49152==(49152&e)},flagModes:{r:0,rs:1052672,"r+":2,w:577,wx:705,xw:705,"w+":578,"wx+":706,"xw+":706,a:1089,ax:1217,xa:1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function(e){var r=T.flagModes[e];if(void 0===r)throw new Error("Unknown file open mode: "+e);return r},flagsToPermissionString:function(e){var r=["r","w","rw"][3&e];return 512&e&&(r+="w"),r},nodePermissions:function(e,r){return T.ignorePermissions||(-1===r.indexOf("r")||292&e.mode)&&(-1===r.indexOf("w")||146&e.mode)&&(-1===r.indexOf("x")||73&e.mode)?0:2},mayLookup:function(e){var r=T.nodePermissions(e,"x");return r||(e.node_ops.lookup?0:2)},mayCreate:function(e,r){try{T.lookupNode(e,r);return 20}catch(e){}return T.nodePermissions(e,"wx")},mayDelete:function(e,r,t){var n;try{n=T.lookupNode(e,r)}catch(e){return e.errno}r=T.nodePermissions(e,"wx");if(r)return r;if(t){if(!T.isDir(n.mode))return 54;if(T.isRoot(n)||T.getPath(n)===T.cwd())return 10}else if(T.isDir(n.mode))return 31;return 0},mayOpen:function(e,r){return e?T.isLink(e.mode)?32:T.isDir(e.mode)&&("r"!==T.flagsToPermissionString(r)||512&r)?31:T.nodePermissions(e,T.flagsToPermissionString(r)):44},MAX_OPEN_FDS:4096,nextfd:function(e,r){r=r||T.MAX_OPEN_FDS;for(var t=e=e||0;t<=r;t++)if(!T.streams[t])return t;throw new T.ErrnoError(33)},getStream:function(e){return T.streams[e]},createStream:function(e,r,t){T.FSStream||(T.FSStream=function(){},T.FSStream.prototype={object:{get:function(){return this.node},set:function(e){this.node=e}},isRead:{get:function(){return 1!=(2097155&this.flags)}},isWrite:{get:function(){return 0!=(2097155&this.flags)}},isAppend:{get:function(){return 1024&this.flags}}});var n,o=new T.FSStream;for(n in e)o[n]=e[n];e=o;r=T.nextfd(r,t);return e.fd=r,T.streams[r]=e},closeStream:function(e){T.streams[e]=null},chrdev_stream_ops:{open:function(e){var r=T.getDevice(e.node.rdev);e.stream_ops=r.stream_ops,e.stream_ops.open&&e.stream_ops.open(e)},llseek:function(){throw new T.ErrnoError(70)}},major:function(e){return e>>8},minor:function(e){return 255&e},makedev:function(e,r){return e<<8|r},registerDevice:function(e,r){T.devices[e]={stream_ops:r}},getDevice:function(e){return T.devices[e]},getMounts:function(e){for(var r=[],t=[e];t.length;){var n=t.pop();r.push(n),t.push.apply(t,n.mounts)}return r},syncfs:function(r,t){"function"==typeof r&&(t=r,r=!1),T.syncFSRequests++,1<T.syncFSRequests&&w("warning: "+T.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work");var n=T.getMounts(T.root.mount),o=0;function i(e){return T.syncFSRequests--,t(e)}function a(e){if(e)return a.errored?void 0:(a.errored=!0,i(e));++o>=n.length&&i(null)}n.forEach(function(e){if(!e.type.syncfs)return a(null);e.type.syncfs(e,r,a)})},mount:function(e,r,t){var n,o="/"===t,i=!t;if(o&&T.root)throw new T.ErrnoError(10);if(!o&&!i){i=T.lookupPath(t,{follow_mount:!1});if(t=i.path,n=i.node,T.isMountpoint(n))throw new T.ErrnoError(10);if(!T.isDir(n.mode))throw new T.ErrnoError(54)}i={type:e,opts:r,mountpoint:t,mounts:[]},r=e.mount(i);return(r.mount=i).root=r,o?T.root=r:n&&(n.mounted=i,n.mount&&n.mount.mounts.push(i)),r},unmount:function(e){e=T.lookupPath(e,{follow_mount:!1});if(!T.isMountpoint(e.node))throw new T.ErrnoError(28);var e=e.node,r=e.mounted,n=T.getMounts(r),r=(Object.keys(T.nameTable).forEach(function(e){for(var r=T.nameTable[e];r;){var t=r.name_next;-1!==n.indexOf(r.mount)&&T.destroyNode(r),r=t}}),e.mounted=null,e.mount.mounts.indexOf(r));e.mount.mounts.splice(r,1)},lookup:function(e,r){return e.node_ops.lookup(e,r)},mknod:function(e,r,t){var n=T.lookupPath(e,{parent:!0}).node,e=x.basename(e);if(!e||"."===e||".."===e)throw new T.ErrnoError(28);var o=T.mayCreate(n,e);if(o)throw new T.ErrnoError(o);if(n.node_ops.mknod)return n.node_ops.mknod(n,e,r,t);throw new T.ErrnoError(63)},create:function(e,r){return T.mknod(e,r=(r=void 0!==r?r:438)&4095|32768,0)},mkdir:function(e,r){return T.mknod(e,r=(r=void 0!==r?r:511)&1023|16384,0)},mkdirTree:function(e,r){for(var t=e.split("/"),n="",o=0;o<t.length;++o)if(t[o]){n+="/"+t[o];try{T.mkdir(n,r)}catch(e){if(20!=e.errno)throw e}}},mkdev:function(e,r,t){return void 0===t&&(t=r,r=438),T.mknod(e,r|=8192,t)},symlink:function(e,r){if(!R.resolve(e))throw new T.ErrnoError(44);var t=T.lookupPath(r,{parent:!0}).node;if(!t)throw new T.ErrnoError(44);var r=x.basename(r),n=T.mayCreate(t,r);if(n)throw new T.ErrnoError(n);if(t.node_ops.symlink)return t.node_ops.symlink(t,r,e);throw new T.ErrnoError(63)},rename:function(r,t){var e,n,o=x.dirname(r),i=x.dirname(t),a=x.basename(r),s=x.basename(t);try{e=T.lookupPath(r,{parent:!0}).node,n=T.lookupPath(t,{parent:!0}).node}catch(e){throw new T.ErrnoError(10)}if(!e||!n)throw new T.ErrnoError(44);if(e.mount!==n.mount)throw new T.ErrnoError(75);var u,c=T.lookupNode(e,a),i=R.relative(r,i);if("."!==i.charAt(0))throw new T.ErrnoError(28);if("."!==(i=R.relative(t,o)).charAt(0))throw new T.ErrnoError(55);try{u=T.lookupNode(n,s)}catch(e){}if(c!==u){o=T.isDir(c.mode),i=T.mayDelete(e,a,o);if(i)throw new T.ErrnoError(i);if(i=u?T.mayDelete(n,s,o):T.mayCreate(n,s))throw new T.ErrnoError(i);if(!e.node_ops.rename)throw new T.ErrnoError(63);if(T.isMountpoint(c)||u&&T.isMountpoint(u))throw new T.ErrnoError(10);if(n!==e&&(i=T.nodePermissions(e,"w")))throw new T.ErrnoError(i);try{T.trackingDelegate.willMovePath}catch(e){w("FS.trackingDelegate[\'willMovePath\'](\'"+r+"\', \'"+t+"\') threw an exception: "+e.message)}T.hashRemoveNode(c);try{e.node_ops.rename(c,n,s)}catch(e){throw e}finally{T.hashAddNode(c)}try{T.trackingDelegate.onMovePath}catch(e){w("FS.trackingDelegate[\'onMovePath\'](\'"+r+"\', \'"+t+"\') threw an exception: "+e.message)}}},rmdir:function(r){var e=T.lookupPath(r,{parent:!0}).node,t=x.basename(r),n=T.lookupNode(e,t),o=T.mayDelete(e,t,!0);if(o)throw new T.ErrnoError(o);if(!e.node_ops.rmdir)throw new T.ErrnoError(63);if(T.isMountpoint(n))throw new T.ErrnoError(10);try{T.trackingDelegate.willDeletePath}catch(e){w("FS.trackingDelegate[\'willDeletePath\'](\'"+r+"\') threw an exception: "+e.message)}e.node_ops.rmdir(e,t),T.destroyNode(n);try{T.trackingDelegate.onDeletePath}catch(e){w("FS.trackingDelegate[\'onDeletePath\'](\'"+r+"\') threw an exception: "+e.message)}},readdir:function(e){e=T.lookupPath(e,{follow:!0}).node;if(e.node_ops.readdir)return e.node_ops.readdir(e);throw new T.ErrnoError(54)},unlink:function(r){var e=T.lookupPath(r,{parent:!0}).node,t=x.basename(r),n=T.lookupNode(e,t),o=T.mayDelete(e,t,!1);if(o)throw new T.ErrnoError(o);if(!e.node_ops.unlink)throw new T.ErrnoError(63);if(T.isMountpoint(n))throw new T.ErrnoError(10);try{T.trackingDelegate.willDeletePath}catch(e){w("FS.trackingDelegate[\'willDeletePath\'](\'"+r+"\') threw an exception: "+e.message)}e.node_ops.unlink(e,t),T.destroyNode(n);try{T.trackingDelegate.onDeletePath}catch(e){w("FS.trackingDelegate[\'onDeletePath\'](\'"+r+"\') threw an exception: "+e.message)}},readlink:function(e){e=T.lookupPath(e).node;if(!e)throw new T.ErrnoError(44);if(e.node_ops.readlink)return R.resolve(T.getPath(e.parent),e.node_ops.readlink(e));throw new T.ErrnoError(28)},stat:function(e,r){e=T.lookupPath(e,{follow:!r}).node;if(!e)throw new T.ErrnoError(44);if(e.node_ops.getattr)return e.node_ops.getattr(e);throw new T.ErrnoError(63)},lstat:function(e){return T.stat(e,!0)},chmod:function(e,r,t){if(!(t="string"==typeof e?T.lookupPath(e,{follow:!t}).node:e).node_ops.setattr)throw new T.ErrnoError(63);t.node_ops.setattr(t,{mode:4095&r|-4096&t.mode,timestamp:Date.now()})},lchmod:function(e,r){T.chmod(e,r,!0)},fchmod:function(e,r){e=T.getStream(e);if(!e)throw new T.ErrnoError(8);T.chmod(e.node,r)},chown:function(e,r,t,n){if(!(n="string"==typeof e?T.lookupPath(e,{follow:!n}).node:e).node_ops.setattr)throw new T.ErrnoError(63);n.node_ops.setattr(n,{timestamp:Date.now()})},lchown:function(e,r,t){T.chown(e,r,t,!0)},fchown:function(e,r,t){e=T.getStream(e);if(!e)throw new T.ErrnoError(8);T.chown(e.node,r,t)},truncate:function(e,r){if(r<0)throw new T.ErrnoError(28);if(!(e="string"==typeof e?T.lookupPath(e,{follow:!0}).node:e).node_ops.setattr)throw new T.ErrnoError(63);if(T.isDir(e.mode))throw new T.ErrnoError(31);if(!T.isFile(e.mode))throw new T.ErrnoError(28);var t=T.nodePermissions(e,"w");if(t)throw new T.ErrnoError(t);e.node_ops.setattr(e,{size:r,timestamp:Date.now()})},ftruncate:function(e,r){e=T.getStream(e);if(!e)throw new T.ErrnoError(8);if(0==(2097155&e.flags))throw new T.ErrnoError(28);T.truncate(e.node,r)},utime:function(e,r,t){e=T.lookupPath(e,{follow:!0}).node;e.node_ops.setattr(e,{timestamp:Math.max(r,t)})},open:function(r,e,t,n,o){if(""===r)throw new T.ErrnoError(44);if(t=void 0===t?438:t,t=64&(e="string"==typeof e?T.modeStringToFlags(e):e)?4095&t|32768:0,"object"==typeof r)i=r;else{r=x.normalize(r);try{var i=T.lookupPath(r,{follow:!(131072&e)}).node}catch(e){}}var a=!1;if(64&e)if(i){if(128&e)throw new T.ErrnoError(20)}else i=T.mknod(r,t,0),a=!0;if(!i)throw new T.ErrnoError(44);if(T.isChrdev(i.mode)&&(e&=-513),65536&e&&!T.isDir(i.mode))throw new T.ErrnoError(54);if(!a){t=T.mayOpen(i,e);if(t)throw new T.ErrnoError(t)}512&e&&T.truncate(i,0),e&=-131713;a=T.createStream({node:i,path:T.getPath(i),flags:e,seekable:!0,position:0,stream_ops:i.stream_ops,ungotten:[],error:!1},n,o);a.stream_ops.open&&a.stream_ops.open(a),!h.logReadFiles||1&e||(T.readFiles||(T.readFiles={}),r in T.readFiles||(T.readFiles[r]=1,w("FS.trackingDelegate error on read file: "+r)));try{T.trackingDelegate.onOpenFile}catch(e){w("FS.trackingDelegate[\'onOpenFile\'](\'"+r+"\', flags) threw an exception: "+e.message)}return a},close:function(e){if(T.isClosed(e))throw new T.ErrnoError(8);e.getdents&&(e.getdents=null);try{e.stream_ops.close&&e.stream_ops.close(e)}catch(e){throw e}finally{T.closeStream(e.fd)}e.fd=null},isClosed:function(e){return null===e.fd},llseek:function(e,r,t){if(T.isClosed(e))throw new T.ErrnoError(8);if(!e.seekable||!e.stream_ops.llseek)throw new T.ErrnoError(70);if(0!=t&&1!=t&&2!=t)throw new T.ErrnoError(28);return e.position=e.stream_ops.llseek(e,r,t),e.ungotten=[],e.position},read:function(e,r,t,n,o){if(n<0||o<0)throw new T.ErrnoError(28);if(T.isClosed(e))throw new T.ErrnoError(8);if(1==(2097155&e.flags))throw new T.ErrnoError(8);if(T.isDir(e.node.mode))throw new T.ErrnoError(31);if(!e.stream_ops.read)throw new T.ErrnoError(28);var i=void 0!==o;if(i){if(!e.seekable)throw new T.ErrnoError(70)}else o=e.position;r=e.stream_ops.read(e,r,t,n,o);return i||(e.position+=r),r},write:function(r,e,t,n,o,i){if(n<0||o<0)throw new T.ErrnoError(28);if(T.isClosed(r))throw new T.ErrnoError(8);if(0==(2097155&r.flags))throw new T.ErrnoError(8);if(T.isDir(r.node.mode))throw new T.ErrnoError(31);if(!r.stream_ops.write)throw new T.ErrnoError(28);r.seekable&&1024&r.flags&&T.llseek(r,0,2);var a=void 0!==o;if(a){if(!r.seekable)throw new T.ErrnoError(70)}else o=r.position;e=r.stream_ops.write(r,e,t,n,o,i);a||(r.position+=e);try{r.path&&T.trackingDelegate.onWriteToFile&&T.trackingDelegate.onWriteToFile(r.path)}catch(e){w("FS.trackingDelegate[\'onWriteToFile\'](\'"+r.path+"\') threw an exception: "+e.message)}return e},allocate:function(e,r,t){if(T.isClosed(e))throw new T.ErrnoError(8);if(r<0||t<=0)throw new T.ErrnoError(28);if(0==(2097155&e.flags))throw new T.ErrnoError(8);if(!T.isFile(e.node.mode)&&!T.isDir(e.node.mode))throw new T.ErrnoError(43);if(!e.stream_ops.allocate)throw new T.ErrnoError(138);e.stream_ops.allocate(e,r,t)},mmap:function(e,r,t,n,o,i){if(0!=(2&o)&&0==(2&i)&&2!=(2097155&e.flags))throw new T.ErrnoError(2);if(1==(2097155&e.flags))throw new T.ErrnoError(2);if(e.stream_ops.mmap)return e.stream_ops.mmap(e,r,t,n,o,i);throw new T.ErrnoError(43)},msync:function(e,r,t,n,o){return e&&e.stream_ops.msync?e.stream_ops.msync(e,r,t,n,o):0},munmap:function(e){return 0},ioctl:function(e,r,t){if(e.stream_ops.ioctl)return e.stream_ops.ioctl(e,r,t);throw new T.ErrnoError(59)},readFile:function(e,r){if((r=r||{}).flags=r.flags||"r",r.encoding=r.encoding||"binary","utf8"!==r.encoding&&"binary"!==r.encoding)throw new Error(\'Invalid encoding type "\'+r.encoding+\'"\');var t,n=T.open(e,r.flags),e=T.stat(e).size,o=new Uint8Array(e);return T.read(n,o,0,e,0),"utf8"===r.encoding?t=g(o,0):"binary"===r.encoding&&(t=o),T.close(n),t},writeFile:function(e,r,t){(t=t||{}).flags=t.flags||"w";e=T.open(e,t.flags,t.mode);if("string"==typeof r){var n=new Uint8Array(G(r)+1),o=X(r,n,0,n.length);T.write(e,n,0,o,void 0,t.canOwn)}else{if(!ArrayBuffer.isView(r))throw new Error("Unsupported data type");T.write(e,r,0,r.byteLength,void 0,t.canOwn)}T.close(e)},cwd:function(){return T.currentPath},chdir:function(e){e=T.lookupPath(e,{follow:!0});if(null===e.node)throw new T.ErrnoError(44);if(!T.isDir(e.node.mode))throw new T.ErrnoError(54);var r=T.nodePermissions(e.node,"x");if(r)throw new T.ErrnoError(r);T.currentPath=e.path},createDefaultDirectories:function(){T.mkdir("/tmp"),T.mkdir("/home"),T.mkdir("/home/web_user")},createDefaultDevices:function(){if(T.mkdir("/dev"),T.registerDevice(T.makedev(1,3),{read:function(){return 0},write:function(e,r,t,n,o){return n}}),T.mkdev("/dev/null",T.makedev(1,3)),M.register(T.makedev(5,0),M.default_tty_ops),M.register(T.makedev(6,0),M.default_tty1_ops),T.mkdev("/dev/tty",T.makedev(5,0)),T.mkdev("/dev/tty1",T.makedev(6,0)),"object"==typeof crypto&&"function"==typeof crypto.getRandomValues)var e=new Uint8Array(1),r=function(){return crypto.getRandomValues(e),e[0]};else if(s)try{var t=require("crypto");r=function(){return t.randomBytes(1)[0]}}catch(e){}T.createDevice("/dev","random",r=r||function(){D("random_device")}),T.createDevice("/dev","urandom",r),T.mkdir("/dev/shm"),T.mkdir("/dev/shm/tmp")},createSpecialDirectories:function(){T.mkdir("/proc"),T.mkdir("/proc/self"),T.mkdir("/proc/self/fd"),T.mount({mount:function(){var e=T.createNode("/proc/self","fd",16895,73);return e.node_ops={lookup:function(e,r){var t=T.getStream(+r);if(!t)throw new T.ErrnoError(8);r={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:function(){return t.path}}};return r.parent=r}},e}},{},"/proc/self/fd")},createStandardStreams:function(){h.stdin?T.createDevice("/dev","stdin",h.stdin):T.symlink("/dev/tty","/dev/stdin"),h.stdout?T.createDevice("/dev","stdout",null,h.stdout):T.symlink("/dev/tty","/dev/stdout"),h.stderr?T.createDevice("/dev","stderr",null,h.stderr):T.symlink("/dev/tty1","/dev/stderr"),T.open("/dev/stdin","r"),T.open("/dev/stdout","w"),T.open("/dev/stderr","w")},ensureErrnoError:function(){T.ErrnoError||(T.ErrnoError=function(e,r){this.node=r,this.setErrno=function(e){this.errno=e},this.setErrno(e),this.message="FS error"},T.ErrnoError.prototype=new Error,T.ErrnoError.prototype.constructor=T.ErrnoError,[44].forEach(function(e){T.genericErrors[e]=new T.ErrnoError(e),T.genericErrors[e].stack="<generic error, no stack>"}))},staticInit:function(){T.ensureErrnoError(),T.nameTable=new Array(4096),T.mount(B,{},"/"),T.createDefaultDirectories(),T.createDefaultDevices(),T.createSpecialDirectories(),T.filesystems={MEMFS:B}},init:function(e,r,t){T.init.initialized=!0,T.ensureErrnoError(),h.stdin=e||h.stdin,h.stdout=r||h.stdout,h.stderr=t||h.stderr,T.createStandardStreams()},quit:function(){T.init.initialized=!1;var e=h._fflush;e&&e(0);for(var r=0;r<T.streams.length;r++){var t=T.streams[r];t&&T.close(t)}},getMode:function(e,r){var t=0;return e&&(t|=365),r&&(t|=146),t},joinPath:function(e,r){e=x.join.apply(null,e);return e=r&&"/"==e[0]?e.substr(1):e},absolutePath:function(e,r){return R.resolve(r,e)},standardizePath:function(e){return x.normalize(e)},findObject:function(e,r){e=T.analyzePath(e,r);return e.exists?e.object:(A(e.error),null)},analyzePath:function(e,r){try{e=(n=T.lookupPath(e,{follow:!r})).path}catch(e){}var t={isRoot:!1,exists:!1,error:0,name:null,path:null,object:null,parentExists:!1,parentPath:null,parentObject:null};try{var n=T.lookupPath(e,{parent:!0});t.parentExists=!0,t.parentPath=n.path,t.parentObject=n.node,t.name=x.basename(e),n=T.lookupPath(e,{follow:!r}),t.exists=!0,t.path=n.path,t.object=n.node,t.name=n.node.name,t.isRoot="/"===n.path}catch(e){t.error=e.errno}return t},createFolder:function(e,r,t,n){e=x.join2("string"==typeof e?e:T.getPath(e),r),r=T.getMode(t,n);return T.mkdir(e,r)},createPath:function(e,r,t,n){e="string"==typeof e?e:T.getPath(e);for(var o=r.split("/").reverse();o.length;){var i=o.pop();if(i){var a=x.join2(e,i);try{T.mkdir(a)}catch(e){}e=a}}return a},createFile:function(e,r,t,n,o){e=x.join2("string"==typeof e?e:T.getPath(e),r),r=T.getMode(n,o);return T.create(e,r)},createDataFile:function(e,r,t,n,o,i){r=r?x.join2("string"==typeof e?e:T.getPath(e),r):e,e=T.getMode(n,o),n=T.create(r,e);if(t){if("string"==typeof t){for(var a=new Array(t.length),s=0,u=t.length;s<u;++s)a[s]=t.charCodeAt(s);t=a}T.chmod(n,146|e);o=T.open(n,"w");T.write(o,t,0,t.length,0,i),T.close(o),T.chmod(n,e)}return n},createDevice:function(e,r,u,a){var e=x.join2("string"==typeof e?e:T.getPath(e),r),r=T.getMode(!!u,!!a),t=(T.createDevice.major||(T.createDevice.major=64),T.makedev(T.createDevice.major++,0));return T.registerDevice(t,{open:function(e){e.seekable=!1},close:function(e){a&&a.buffer&&a.buffer.length&&a(10)},read:function(e,r,t,n,o){for(var i,a=0,s=0;s<n;s++){try{i=u()}catch(e){throw new T.ErrnoError(29)}if(void 0===i&&0===a)throw new T.ErrnoError(6);if(null==i)break;a++,r[t+s]=i}return a&&(e.node.timestamp=Date.now()),a},write:function(e,r,t,n,o){for(var i=0;i<n;i++)try{a(r[t+i])}catch(e){throw new T.ErrnoError(29)}return n&&(e.node.timestamp=Date.now()),i}}),T.mkdev(e,r,t)},createLink:function(e,r,t,n,o){e=x.join2("string"==typeof e?e:T.getPath(e),r);return T.symlink(t,e)},forceLoadFile:function(e){if(e.isDevice||e.isFolder||e.link||e.contents)return!0;var r=!0;if("undefined"!=typeof XMLHttpRequest)throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");if(!n)throw new Error("Cannot load without read() or XMLHttpRequest.");try{e.contents=ye(n(e.url),!0),e.usedBytes=e.contents.length}catch(e){r=!1}return r||A(29),r},createLazyFile:function(e,r,a,t,n){function o(){this.lengthKnown=!1,this.chunks=[]}if(o.prototype.get=function(e){var r;if(!(e>this.length-1||e<0))return r=e%this.chunkSize,e=e/this.chunkSize|0,this.getter(e)[r]},o.prototype.setDataGetter=function(e){this.getter=e},o.prototype.cacheLength=function(){var e=new XMLHttpRequest;if(e.open("HEAD",a,!1),e.send(null),!(200<=e.status&&e.status<300||304===e.status))throw new Error("Couldn\'t load "+a+". Status: "+e.status);var r,n=Number(e.getResponseHeader("Content-length")),t=(r=e.getResponseHeader("Accept-Ranges"))&&"bytes"===r,e=(r=e.getResponseHeader("Content-Encoding"))&&"gzip"===r,o=1048576,i=(t||(o=n),this);i.setDataGetter(function(e){var r=e*o,t=(e+1)*o-1,t=Math.min(t,n-1);if(void 0===i.chunks[e]&&(i.chunks[e]=function(e,r){if(r<e)throw new Error("invalid range ("+e+", "+r+") or no bytes requested!");if(n-1<r)throw new Error("only "+n+" bytes available! programmer error!");var t=new XMLHttpRequest;if(t.open("GET",a,!1),n!==o&&t.setRequestHeader("Range","bytes="+e+"-"+r),"undefined"!=typeof Uint8Array&&(t.responseType="arraybuffer"),t.overrideMimeType&&t.overrideMimeType("text/plain; charset=x-user-defined"),t.send(null),200<=t.status&&t.status<300||304===t.status)return void 0!==t.response?new Uint8Array(t.response||[]):ye(t.responseText||"",!0);throw new Error("Couldn\'t load "+a+". Status: "+t.status)}(r,t)),void 0===i.chunks[e])throw new Error("doXHR failed!");return i.chunks[e]}),!e&&n||(o=n=1,n=this.getter(0).length,o=n,m("LazyFiles on gzip forces download of the whole file when length is accessed")),this._length=n,this._chunkSize=o,this.lengthKnown=!0},"undefined"!=typeof XMLHttpRequest){if(!c)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var i=new o,i=(Object.defineProperties(i,{length:{get:function(){return this.lengthKnown||this.cacheLength(),this._length}},chunkSize:{get:function(){return this.lengthKnown||this.cacheLength(),this._chunkSize}}}),{isDevice:!1,contents:i})}else i={isDevice:!1,url:a};var u=T.createFile(e,r,i,t,n),s=(i.contents?u.contents=i.contents:i.url&&(u.contents=null,u.url=i.url),Object.defineProperties(u,{usedBytes:{get:function(){return this.contents.length}}}),{});return Object.keys(u.stream_ops).forEach(function(e){var r=u.stream_ops[e];s[e]=function(){if(T.forceLoadFile(u))return r.apply(null,arguments);throw new T.ErrnoError(29)}}),s.read=function(e,r,t,n,o){if(!T.forceLoadFile(u))throw new T.ErrnoError(29);var i=e.node.contents;if(o>=i.length)return 0;var a=Math.min(i.length-o,n);if(i.slice)for(var s=0;s<a;s++)r[t+s]=i[o+s];else for(s=0;s<a;s++)r[t+s]=i.get(o+s);return a},u.stream_ops=s,u},createPreloadedFile:function(o,i,e,a,s,u,c,f,l,d){Browser.init();var p=i?R.resolve(x.join2(o,i)):o;function r(r){function t(e){d&&d(),f||T.createDataFile(o,i,e,a,s,l),u&&u(),ue()}var n=!1;h.preloadPlugins.forEach(function(e){n||e.canHandle(p)&&(e.handle(r,p,t,function(){c&&c(),ue()}),n=!0)}),n||t(r)}se(),"string"==typeof e?Browser.asyncLoad(e,function(e){r(e)},c):r(e)},indexedDB:function(){return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:function(){return"EM_FS_"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(a,s,u){s=s||function(){},u=u||function(){};var e=T.indexedDB();try{var c=e.open(T.DB_NAME(),T.DB_VERSION)}catch(e){return u(e)}c.onupgradeneeded=function(){m("creating db"),c.result.createObjectStore(T.DB_STORE_NAME)},c.onsuccess=function(){var e=c.result.transaction([T.DB_STORE_NAME],"readwrite"),r=e.objectStore(T.DB_STORE_NAME),t=0,n=0,o=a.length;function i(){(0==n?s:u)()}a.forEach(function(e){e=r.put(T.analyzePath(e).object.contents,e);e.onsuccess=function(){++t+n==o&&i()},e.onerror=function(){t+ ++n==o&&i()}}),e.onerror=u},c.onerror=u},loadFilesFromDB:function(s,u,c){u=u||function(){},c=c||function(){};var e=T.indexedDB();try{var f=e.open(T.DB_NAME(),T.DB_VERSION)}catch(e){return c(e)}f.onupgradeneeded=c,f.onsuccess=function(){var e=f.result;try{var r=e.transaction([T.DB_STORE_NAME],"readonly")}catch(e){return void c(e)}var t=r.objectStore(T.DB_STORE_NAME),n=0,o=0,i=s.length;function a(){(0==o?u:c)()}s.forEach(function(e){var r=t.get(e);r.onsuccess=function(){T.analyzePath(e).exists&&T.unlink(e),T.createDataFile(x.dirname(e),x.basename(e),r.result,!0,!0,!0),++n+o==i&&a()},r.onerror=function(){n+ ++o==i&&a()}}),r.onerror=c},f.onerror=c}},N={mappings:{},DEFAULT_POLLMASK:5,umask:511,calculateAt:function(e,r){if("/"!==r[0]){var t;if(-100===e)t=T.cwd();else{e=T.getStream(e);if(!e)throw new T.ErrnoError(8);t=e.path}r=x.join2(t,r)}return r},doStat:function(e,r,t){try{var n=e(r)}catch(e){if(e&&e.node&&x.normalize(r)!==x.normalize(T.getPath(e.node)))return-54;throw e}return k[t>>2]=n.dev,k[t+4>>2]=0,k[t+8>>2]=n.ino,k[t+12>>2]=n.mode,k[t+16>>2]=n.nlink,k[t+20>>2]=n.uid,k[t+24>>2]=n.gid,k[t+28>>2]=n.rdev,k[t+32>>2]=0,F=[n.size>>>0,(S=n.size,1<=+ne(S)?0<S?(0|ae(+ie(S/4294967296),4294967295))>>>0:~~+oe((S-(~~S>>>0))/4294967296)>>>0:0)],k[t+40>>2]=F[0],k[t+44>>2]=F[1],k[t+48>>2]=4096,k[t+52>>2]=n.blocks,k[t+56>>2]=n.atime.getTime()/1e3|0,k[t+60>>2]=0,k[t+64>>2]=n.mtime.getTime()/1e3|0,k[t+68>>2]=0,k[t+72>>2]=n.ctime.getTime()/1e3|0,k[t+76>>2]=0,F=[n.ino>>>0,(S=n.ino,1<=+ne(S)?0<S?(0|ae(+ie(S/4294967296),4294967295))>>>0:~~+oe((S-(~~S>>>0))/4294967296)>>>0:0)],k[t+80>>2]=F[0],k[t+84>>2]=F[1],0},doMsync:function(e,r,t,n,o){e=E.slice(e,e+t);T.msync(r,e,o,t,n)},doMkdir:function(e,r){return"/"===(e=x.normalize(e))[e.length-1]&&(e=e.substr(0,e.length-1)),T.mkdir(e,r,0),0},doMknod:function(e,r,t){switch(61440&r){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return-28}return T.mknod(e,r,t),0},doReadlink:function(e,r,t){if(t<=0)return-28;var e=T.readlink(e),n=Math.min(t,G(e)),o=y[r+n];return X(e,E,r,t+1),y[r+n]=o,n},doAccess:function(e,r){if(-8&r)return-28;e=T.lookupPath(e,{follow:!0}).node;if(!e)return-44;var t="";return 4&r&&(t+="r"),2&r&&(t+="w"),1&r&&(t+="x"),t&&T.nodePermissions(e,t)?-2:0},doDup:function(e,r,t){var n=T.getStream(t);return n&&T.close(n),T.open(e,r,0,t,t).fd},doReadv:function(e,r,t,n){for(var o=0,i=0;i<t;i++){var a=k[r+8*i>>2],s=k[r+(8*i+4)>>2],a=T.read(e,y,a,s,n);if(a<0)return-1;if(o+=a,a<s)break}return o},doWritev:function(e,r,t,n){for(var o=0,i=0;i<t;i++){var a=k[r+8*i>>2],s=k[r+(8*i+4)>>2],a=T.write(e,y,a,s,n);if(a<0)return-1;o+=a}return o},varargs:void 0,get:function(){return N.varargs+=4,k[N.varargs-4>>2]},getStr:function(e){return W(e)},getStreamFromFD:function(e){e=T.getStream(e);if(e)return e;throw new T.ErrnoError(8)},get64:function(e,r){return e}};var ge={};function z(){if(!z.strings){var e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:C||"./this.program"};for(r in ge)e[r]=ge[r];var r,t=[];for(r in e)t.push(r+"="+e[r]);z.strings=t}return z.strings}function ve(e,r,t,n){this.parent=e=e||this,this.mount=e.mount,this.mounted=null,this.id=T.nextInode++,this.name=r,this.mode=t,this.node_ops={},this.stream_ops={},this.rdev=n}function ye(e,r,t){t=0<t?t:G(e)+1,t=new Array(t),e=X(e,t,0,t.length);return r&&(t.length=e),t}Object.defineProperties(ve.prototype,{read:{get:function(){return 365==(365&this.mode)},set:function(e){e?this.mode|=365:this.mode&=-366}},write:{get:function(){return 146==(146&this.mode)},set:function(e){e?this.mode|=146:this.mode&=-147}},isFolder:{get:function(){return T.isDir(this.mode)}},isDevice:{get:function(){return T.isChrdev(this.mode)}}}),T.FSNode=ve,T.staticInit();var Ee,ke={a:function(e,r,t,n){D("Assertion failed: "+W(e)+", at: "+[r?W(r):"unknown filename",t,n?W(n):"unknown function"])},s:function(e,r){var t;if(0===e)t=Date.now();else{if(1!==e&&4!==e||!we)return A(28),-1;t=me()}return k[r>>2]=t/1e3|0,k[r+4>>2]=t%1e3*1e3*1e3|0,0},d:function(e,r,t){N.varargs=t;try{var n=N.getStreamFromFD(e);switch(r){case 0:return(o=N.get())<0?-28:T.open(n.path,n.flags,0,o).fd;case 1:case 2:return 0;case 3:return n.flags;case 4:var o=N.get();return n.flags|=o,0;case 12:o=N.get();return K[o+0>>1]=2,0;case 13:case 14:return 0;case 16:case 8:return-28;case 9:return A(28),-1;default:return-28}}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},i:function(e,r,t){N.varargs=t;try{var n=N.getStreamFromFD(e);switch(r){case 21509:case 21505:return n.tty?0:-59;case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:return n.tty?0:-59;case 21519:if(!n.tty)return-59;var o=N.get();return k[o>>2]=0;case 21520:return n.tty?-28:-59;case 21531:o=N.get();return T.ioctl(n,r,o);case 21523:case 21524:return n.tty?0:-59;default:D("bad ioctl syscall "+r)}}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},e:function(e,r,t){N.varargs=t;try{var n=N.getStr(e),o=N.get();return T.open(n,r,o).fd}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},t:function(e){try{return e=N.getStr(e),T.rmdir(e),0}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},j:function(e){try{var r=N.umask;return N.umask=e,r}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},u:function(e){try{return e=N.getStr(e),T.unlink(e),0}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},v:function(e,r,t,n){try{D("cannot wait on child processes")}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},n:function(e,r,t){E.copyWithin(e,r,r+t)},b:function(e){var r=E.length,t=2147483648;if(t<(e>>>=0))return!1;for(var n,o=1;o<=4;o*=2){var i=r*(1+.2/o),i=Math.min(i,e+100663296);if(function(e){try{return p.grow(e-v.byteLength+65535>>>16),Y(p.buffer),1}catch(e){}}(Math.min(t,(0<(i=Math.max(16777216,e,i))%(n=65536)&&(i+=n-i%n),i))))return!0}return!1},p:function(a,s){var u=0;return z().forEach(function(e,r){for(var t=s+u,n=(k[a+4*r>>2]=t,e),o=t,r=void 0,i=0;i<n.length;++i)y[o++>>0]=n.charCodeAt(i);r||(y[o>>0]=0),u+=e.length+1}),0},q:function(e,r){var t=z(),n=(k[e>>2]=t.length,0);return t.forEach(function(e){n+=e.length+1}),k[r>>2]=n,0},c:function(e){xe(e)},f:function(e){try{var r=N.getStreamFromFD(e);return T.close(r),0}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),e.errno}},r:function(e,r){try{var t=N.getStreamFromFD(e),n=t.tty?2:T.isDir(t.mode)?3:T.isLink(t.mode)?7:4;return y[r>>0]=n,0}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),e.errno}},h:function(e,r,t,n){try{var o=N.getStreamFromFD(e),i=N.doReadv(o,r,t);return k[n>>2]=i,0}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),e.errno}},m:function(e,r,t,n,o){try{var i=N.getStreamFromFD(e),a=4294967296*t+(r>>>0),s=9007199254740992;return a<=-s||s<=a?-61:(T.llseek(i,a,n),F=[i.position>>>0,(S=i.position,1<=+ne(S)?0<S?(0|ae(+ie(S/4294967296),4294967295))>>>0:~~+oe((S-(~~S>>>0))/4294967296)>>>0:0)],k[o>>2]=F[0],k[o+4>>2]=F[1],i.getdents&&0==a&&0===n&&(i.getdents=null),0)}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),e.errno}},g:function(e,r,t,n){try{var o=N.getStreamFromFD(e),i=N.doWritev(o,r,t);return k[n>>2]=i,0}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),e.errno}},memory:p,o:function(){w("missing function: popen"),D(-1)},l:function(){return 6},k:function(){},table:I},_e=(!function(){var r={a:ke};function t(e,r){e=e.exports;h.asm=e,ue()}function n(e){t(e.instance)}function o(e){return(l||!L&&!c||"function"!=typeof fetch||de(P)?new Promise(function(e,r){e(pe())}):fetch(P,{credentials:"same-origin"}).then(function(e){if(e.ok)return e.arrayBuffer();throw"failed to load wasm binary file at \'"+P+"\'"}).catch(pe)).then(function(e){return WebAssembly.instantiate(e,r)}).then(e,function(e){w("failed to asynchronously prepare wasm: "+e),D(e)})}if(se(),h.instantiateWasm)try{h.instantiateWasm(r,t);return}catch(e){return w("Module.instantiateWasm callback failed with error: "+e)}l||"function"!=typeof WebAssembly.instantiateStreaming||ce(P,fe)||de(P)||"function"!=typeof fetch?o(n):fetch(P,{credentials:"same-origin"}).then(function(e){return WebAssembly.instantiateStreaming(e,r).then(n,function(e){return w("wasm streaming compile failed: "+e),w("falling back to ArrayBuffer instantiation"),o(n)})})}(),h.___wasm_call_ctors=function(){return(_e=h.___wasm_call_ctors=h.asm.w).apply(null,arguments)}),be=h._malloc=function(){return(be=h._malloc=h.asm.x).apply(null,arguments)},De=h.___errno_location=function(){return(De=h.___errno_location=h.asm.y).apply(null,arguments)},Se=(h._main=function(){return(h._main=h.asm.z).apply(null,arguments)},h.stackAlloc=function(){return(Se=h.stackAlloc=h.asm.A).apply(null,arguments)});function Fe(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function Pe(r){var t=h._main;r=r||[];try{for(let e=0;e<r.length;e++){const s=r[e];var n,{argc:o,argv:i}=function(e){var r=e.length+1,t=Se(4*(r+1));k[t>>2]=V(C);for(var n=1;n<r;n++)k[(t>>2)+n]=V(e[n-1]);return k[(t>>2)+r]=0,{argc:r,argv:t}}(s.split(" ").filter(e=>Boolean(e)));if(0!==(n=t(o,i)))break}xe(n,!0)}catch(e){if(e instanceof Fe)return;if("unwind"==e)return void(d=!0);var a=e;e&&"object"==typeof e&&e.stack&&(a=[e,e.stack]),w("exception thrown: "+a),u(1,e)}}function Ae(e){function r(){Ee||(Ee=!0,h.calledRun=!0,U||(h.noFSInit||T.init.initialized||T.init(),Z(J),T.ignorePermissions=!1,Z(Q),j(h),h.onRuntimeInitialized&&h.onRuntimeInitialized(),Re&&Pe(e),te()))}e=e||a,0<_||(re(),0<_||(h.setStatus?(h.setStatus("Running..."),setTimeout(function(){setTimeout(function(){h.setStatus("")},1),r()},1)):r()))}function xe(e,r){r&&d&&0===e||(d||(U=!0,h.onExit&&h.onExit(e)),u(e,new Fe(e)))}if(h.dynCall_vi=function(){return(h.dynCall_vi=h.asm.B).apply(null,arguments)},b=function e(){Ee||Ae(),Ee||(b=e)},h.run=Ae,h.preInit)for("function"==typeof h.preInit&&(h.preInit=[h.preInit]);0<h.preInit.length;)h.preInit.pop()();var Re=!0;return h.noInitialRun&&(Re=!1),d=!0,Ae(),e.ready};let r="";let t="";var f={flush:()=>{0<r.length&&(console.log(r),r=""),0<t.length&&(console.error(t),t="")},stderr:e=>{t+=String.fromCharCode(e),10===e&&(console.error(t),t="")},stdout:e=>{r+=String.fromCharCode(e),10===e&&(console.log(r),r="")}};const l=[];return async(e={})=>{let{data:i=null,command:a=[],folder:s=[],isStrict:u=!1}=e;return await new Promise(e=>{l.push(e),1===l.length&&l[0]()}),new Promise((r,t)=>{let n=!1,o="";c({stdout:f.stdout,stderr:e=>{o+=String.fromCharCode(e),10===e&&(console.error(o),u&&t(o))},arguments:a,input:i,folder:s,output:e=>{r(e),n=!0}}).then(()=>{(0,f.flush)(),n||t(),0<l.length&&(l.shift(),0<l.length&&l[0]())})})}}();onmessage=function(r){(async()=>{var e=await gifsicle(r.data).catch(e=>{postMessage(e)});postMessage(e)})().catch(e=>{postMessage(null)})};',
        workerBlobUrl: "",
        worker() {
            return this.workerBlobUrl || (this.workerLocalUrl ? this.workerBlobUrl = URL.createObjectURL(new Blob([ this.workerLocalUrl ])) : this.workerBlobUrl = "../src/worker.js", 
            this.workerBlobUrl);
        },
        errorLink: () => " \n Check: https://github.com/renzhezhilu/gifsicle-wasm-browser",
        testType: A => A instanceof Element ? "element" : Object.prototype.toString.call(A).replace(/\[object\s(.+)\]/, "$1").toLowerCase(),
        async textToUrl(A) {
            return this.worker();
        },
        loadCommand(A) {
            var I = this.testType(A);
            if (0 === A.length) throw "<command> the content can not be blank" + this.errorLink();
            if ("array" === I) return A.map((A => A.replace(/\n/gi, " ")));
            throw "<command> types:" + I + ", must be an array" + this.errorLink();
        },
        loadOne(B) {
            return new Promise((async (I, A) => {
                var g = this.testType(B);
                if ([ "string" ].includes(g)) fetch(B).then((A => {
                    if (200 !== A.status) throw "<" + B + "> Url error!!!" + this.errorLink();
                    return A.arrayBuffer();
                })).then((A => I(A))); else if ([ "blob", "file" ].includes(g)) new Response(B).arrayBuffer().then((A => I(A))); else {
                    if (![ "arraybuffer" ].includes(g)) throw "<input.file> types:" + g + ", only supports Url, blob, file, arraybuffer" + this.errorLink();
                    I(B);
                }
            }));
        },
        loadFile(B) {
            return new Promise((async (I, A) => {
                var g = this.testType(B);
                if ("array" !== g) throw "<input> types:" + g + ", only supports Array" + this.errorLink();
                if (0 === B.length) throw "<input> the content can not be blank" + this.errorLink();
                g = B.map((A => this.loadOne(A.file))), Promise.all(g).then((function(g) {
                    var A = B.map(((A, I) => (A.file = g[I], A)));
                    I(A);
                })).catch((function(A) {}));
            }));
        },
        loadFolder(B) {
            return new Promise((async (A, I) => {
                var g = this.testType(B);
                if (![ "array" ].includes(g)) throw "<folder> types:" + g + ", only supports Array" + this.errorLink();
                A(B);
            }));
        }
    },
    run(t = {}) {
        return new Promise((async (Q, A) => {
            let {input: I = [], command: g = "", folder: B = [], isStrict: C = !1, start: E = (A => {})} = t;
            var i = await this.tool.textToUrl();
            let o = new Worker(i);
            var D = this.tool.loadCommand(g), w = await this.tool.loadFile(I), e = (E(w), await this.tool.loadFolder(B));
            console.log(D), console.log(w), console.log(i), o.postMessage({
                data: w,
                command: D,
                folder: e,
                isStrict: C
            }), o.onmessage = async function(I) {
                if (!I.data || "string" == typeof I.data) return o.terminate(), void A(I.data);
                let g = [];
                for (let A = 0; A < I.data.length; A++) {
                    const C = I.data[A];
                    var B;
                    C.name.includes(".txt") ? (B = new File([ C.file ], C.name, {
                        type: "text/plain"
                    }), g.push(B)) : (B = new File([ C.file ], C.name, {
                        type: "image/gif"
                    }), g.push(B));
                }
                o.terminate(), Q(g);
            }, o.onerror = function(A) {
                console.error(A), o.terminate(), Q(null);
            };
        }));
    }
};

var commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}

function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var a = Object.defineProperty({}, "__esModule", {
        value: !0
    });
    return Object.keys(n).forEach((function(k) {
        var d = Object.getOwnPropertyDescriptor(n, k);
        Object.defineProperty(a, k, d.get ? d : {
            enumerable: !0,
            get: function() {
                return n[k];
            }
        });
    })), a;
}

var es$v = {}, interopRequireDefault = {
    exports: {}
};

!function(module) {
    module.exports = function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(interopRequireDefault);

var es$u = {}, interopRequireWildcard = {
    exports: {}
}, _typeof$1 = {
    exports: {}
};

!function(module) {
    function _typeof(obj) {
        return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, module.exports.__esModule = !0, module.exports.default = module.exports, _typeof(obj);
    }
    module.exports = _typeof, module.exports.__esModule = !0, module.exports.default = module.exports;
}(_typeof$1), function(module) {
    var _typeof = _typeof$1.exports.default;
    function _getRequireWildcardCache(nodeInterop) {
        if ("function" != typeof WeakMap) return null;
        var cacheBabelInterop = new WeakMap, cacheNodeInterop = new WeakMap;
        return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
            return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
    }
    module.exports = function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) return obj;
        if (null === obj || "object" !== _typeof(obj) && "function" != typeof obj) return {
            default: obj
        };
        var cache = _getRequireWildcardCache(nodeInterop);
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(interopRequireWildcard);

var toConsumableArray = {
    exports: {}
}, arrayWithoutHoles = {
    exports: {}
}, arrayLikeToArray = {
    exports: {}
};

!function(module) {
    module.exports = function _arrayLikeToArray(arr, len) {
        (null == len || len > arr.length) && (len = arr.length);
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(arrayLikeToArray), function(module) {
    var arrayLikeToArray$1 = arrayLikeToArray.exports;
    module.exports = function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return arrayLikeToArray$1(arr);
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(arrayWithoutHoles);

var iterableToArray = {
    exports: {}
};

!function(module) {
    module.exports = function _iterableToArray(iter) {
        if ("undefined" != typeof Symbol && null != iter[Symbol.iterator] || null != iter["@@iterator"]) return Array.from(iter);
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(iterableToArray);

var unsupportedIterableToArray = {
    exports: {}
};

!function(module) {
    var arrayLikeToArray$1 = arrayLikeToArray.exports;
    module.exports = function _unsupportedIterableToArray(o, minLen) {
        if (o) {
            if ("string" == typeof o) return arrayLikeToArray$1(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            return "Object" === n && o.constructor && (n = o.constructor.name), "Map" === n || "Set" === n ? Array.from(o) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? arrayLikeToArray$1(o, minLen) : void 0;
        }
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(unsupportedIterableToArray);

var nonIterableSpread = {
    exports: {}
};

!function(module) {
    module.exports = function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(nonIterableSpread), function(module) {
    var arrayWithoutHoles$1 = arrayWithoutHoles.exports, iterableToArray$1 = iterableToArray.exports, unsupportedIterableToArray$1 = unsupportedIterableToArray.exports, nonIterableSpread$1 = nonIterableSpread.exports;
    module.exports = function _toConsumableArray(arr) {
        return arrayWithoutHoles$1(arr) || iterableToArray$1(arr) || unsupportedIterableToArray$1(arr) || nonIterableSpread$1();
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(toConsumableArray);

var defineProperty = {
    exports: {}
};

!function(module) {
    module.exports = function _defineProperty(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
            value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : obj[key] = value, obj;
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(defineProperty);

var slicedToArray = {
    exports: {}
}, arrayWithHoles = {
    exports: {}
};

!function(module) {
    module.exports = function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(arrayWithHoles);

var iterableToArrayLimit = {
    exports: {}
};

!function(module) {
    module.exports = function _iterableToArrayLimit(arr, i) {
        var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
        if (null != _i) {
            var _s, _e, _arr = [], _n = !0, _d = !1;
            try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !i || _arr.length !== i); _n = !0) ;
            } catch (err) {
                _d = !0, _e = err;
            } finally {
                try {
                    _n || null == _i.return || _i.return();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(iterableToArrayLimit);

var nonIterableRest = {
    exports: {}
};

!function(module) {
    module.exports = function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(nonIterableRest), function(module) {
    var arrayWithHoles$1 = arrayWithHoles.exports, iterableToArrayLimit$1 = iterableToArrayLimit.exports, unsupportedIterableToArray$1 = unsupportedIterableToArray.exports, nonIterableRest$1 = nonIterableRest.exports;
    module.exports = function _slicedToArray(arr, i) {
        return arrayWithHoles$1(arr) || iterableToArrayLimit$1(arr, i) || unsupportedIterableToArray$1(arr, i) || nonIterableRest$1();
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(slicedToArray);

var es$t = {}, construct = {
    exports: {}
}, setPrototypeOf = {
    exports: {}
};

!function(module) {
    function _setPrototypeOf(o, p) {
        return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
            return o.__proto__ = p, o;
        }, module.exports.__esModule = !0, module.exports.default = module.exports, _setPrototypeOf(o, p);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = !0, module.exports.default = module.exports;
}(setPrototypeOf);

var isNativeReflectConstruct = {
    exports: {}
};

!function(module) {
    module.exports = function _isNativeReflectConstruct() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), 
            !0;
        } catch (e) {
            return !1;
        }
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(isNativeReflectConstruct), function(module) {
    var setPrototypeOf$1 = setPrototypeOf.exports, isNativeReflectConstruct$1 = isNativeReflectConstruct.exports;
    function _construct(Parent, args, Class) {
        return isNativeReflectConstruct$1() ? (module.exports = _construct = Reflect.construct.bind(), 
        module.exports.__esModule = !0, module.exports.default = module.exports) : (module.exports = _construct = function _construct(Parent, args, Class) {
            var a = [ null ];
            a.push.apply(a, args);
            var instance = new (Function.bind.apply(Parent, a));
            return Class && setPrototypeOf$1(instance, Class.prototype), instance;
        }, module.exports.__esModule = !0, module.exports.default = module.exports), _construct.apply(null, arguments);
    }
    module.exports = _construct, module.exports.__esModule = !0, module.exports.default = module.exports;
}(construct);

var classCallCheck = {
    exports: {}
};

!function(module) {
    module.exports = function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(classCallCheck);

var createClass = {
    exports: {}
};

!function(module) {
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
            "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    module.exports = function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
        Object.defineProperty(Constructor, "prototype", {
            writable: !1
        }), Constructor;
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(createClass);

var possibleConstructorReturn = {
    exports: {}
}, assertThisInitialized = {
    exports: {}
};

!function(module) {
    module.exports = function _assertThisInitialized(self) {
        if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(assertThisInitialized), function(module) {
    var _typeof = _typeof$1.exports.default, assertThisInitialized$1 = assertThisInitialized.exports;
    module.exports = function _possibleConstructorReturn(self, call) {
        if (call && ("object" === _typeof(call) || "function" == typeof call)) return call;
        if (void 0 !== call) throw new TypeError("Derived constructors may only return object or undefined");
        return assertThisInitialized$1(self);
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(possibleConstructorReturn);

var getPrototypeOf = {
    exports: {}
};

!function(module) {
    function _getPrototypeOf(o) {
        return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        }, module.exports.__esModule = !0, module.exports.default = module.exports, _getPrototypeOf(o);
    }
    module.exports = _getPrototypeOf, module.exports.__esModule = !0, module.exports.default = module.exports;
}(getPrototypeOf);

var inherits = {
    exports: {}
};

!function(module) {
    var setPrototypeOf$1 = setPrototypeOf.exports;
    module.exports = function _inherits(subClass, superClass) {
        if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: !0,
                configurable: !0
            }
        }), Object.defineProperty(subClass, "prototype", {
            writable: !1
        }), superClass && setPrototypeOf$1(subClass, superClass);
    }, module.exports.__esModule = !0, module.exports.default = module.exports;
}(inherits);

var es$s = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return generator._invoke = function makeInvokeMethod(innerFn, self, context) {
        var state = "suspendedStart";
        return function invoke(method, arg) {
            if ("executing" === state) throw new Error("Generator is already running");
            if ("completed" === state) {
                if ("throw" === method) throw arg;
                return {
                    value: void 0,
                    done: !0
                };
            }
            for (context.method = method, context.arg = arg; ;) {
                var delegate = context.delegate;
                if (delegate) {
                    var delegateResult = maybeInvokeDelegate(delegate, context);
                    if (delegateResult) {
                        if (delegateResult === ContinueSentinel) continue;
                        return delegateResult;
                    }
                }
                if ("next" === context.method) context.sent = context._sent = context.arg; else if ("throw" === context.method) {
                    if ("suspendedStart" === state) throw state = "completed", context.arg;
                    context.dispatchException(context.arg);
                } else "return" === context.method && context.abrupt("return", context.arg);
                state = "executing";
                var record = tryCatch(innerFn, self, context);
                if ("normal" === record.type) {
                    if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                    return {
                        value: record.arg,
                        done: context.done
                    };
                }
                "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
            }
        };
    }(innerFn, self, context), generator;
}

function tryCatch(fn, obj, arg) {
    try {
        return {
            type: "normal",
            arg: fn.call(obj, arg)
        };
    } catch (err) {
        return {
            type: "throw",
            arg: err
        };
    }
}

var ContinueSentinel = {};

function Generator() {}

function GeneratorFunction() {}

function GeneratorFunctionPrototype() {}

var IteratorPrototype = {};

IteratorPrototype[iteratorSymbol] = function() {
    return this;
};

var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));

NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);

var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

function defineIteratorMethods(prototype) {
    [ "next", "throw", "return" ].forEach((function(method) {
        prototype[method] = function(arg) {
            return this._invoke(method, arg);
        };
    }));
}

function isGeneratorFunction(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
}

function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
            var result = record.arg, value = result.value;
            return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then((function(value) {
                invoke("next", value, resolve, reject);
            }), (function(err) {
                invoke("throw", err, resolve, reject);
            })) : PromiseImpl.resolve(value).then((function(unwrapped) {
                result.value = unwrapped, resolve(result);
            }), (function(error) {
                return invoke("throw", error, resolve, reject);
            }));
        }
        reject(record.arg);
    }
    var previousPromise;
    this._invoke = function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
            return new PromiseImpl((function(resolve, reject) {
                invoke(method, arg, resolve, reject);
            }));
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
}

function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (void 0 === method) {
        if (context.delegate = null, "throw" === context.method) {
            if (delegate.iterator.return && (context.method = "return", context.arg = void 0, 
            maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
            context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
    }
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, 
    context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, 
    "return" !== context.method && (context.method = "next", context.arg = void 0), 
    context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), 
    context.delegate = null, ContinueSentinel);
}

function pushTryEntry(locs) {
    var entry = {
        tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], 
    entry.afterLoc = locs[3]), this.tryEntries.push(entry);
}

function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
}

function Context(tryLocsList) {
    this.tryEntries = [ {
        tryLoc: "root"
    } ], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
}

function values(iterable) {
    if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
            var i = -1, next = function next() {
                for (;++i < iterable.length; ) if (hasOwn.call(iterable, i)) return next.value = iterable[i], 
                next.done = !1, next;
                return next.value = void 0, next.done = !0, next;
            };
            return next.next = next;
        }
    }
    return {
        next: doneResult
    };
}

function doneResult() {
    return {
        value: void 0,
        done: !0
    };
}

GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype, GeneratorFunctionPrototype.constructor = GeneratorFunction, 
GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction", 
defineIteratorMethods(AsyncIterator.prototype), AsyncIterator.prototype[asyncIteratorSymbol] = function() {
    return this;
}, defineIteratorMethods(Gp), Gp[toStringTagSymbol] = "Generator", Gp[iteratorSymbol] = function() {
    return this;
}, Gp.toString = function() {
    return "[object Generator]";
}, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, 
        this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), 
        !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
    },
    dispatchException: function(exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", 
            context.arg = void 0), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i], record = entry.completion;
            if ("root" === entry.tryLoc) return handle("end");
            if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
                if (hasCatch && hasFinally) {
                    if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                    if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                } else if (hasCatch) {
                    if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                } else {
                    if (!hasFinally) throw new Error("try statement without catch or finally");
                    if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                }
            }
        }
    },
    abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
            }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", 
        this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, 
        this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), 
        ContinueSentinel;
    },
    finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), 
            resetTryEntry(entry), ContinueSentinel;
        }
    },
    catch: function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if ("throw" === record.type) {
                    var thrown = record.arg;
                    resetTryEntry(entry);
                }
                return thrown;
            }
        }
        throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
        return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
        }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
};

var index$1 = {
    wrap,
    isGeneratorFunction,
    AsyncIterator,
    mark: function mark(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, 
        toStringTagSymbol in genFun || (genFun[toStringTagSymbol] = "GeneratorFunction")), 
        genFun.prototype = Object.create(Gp), genFun;
    },
    awrap: function awrap(arg) {
        return {
            __await: arg
        };
    },
    async: function async(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return isGeneratorFunction(outerFn) ? iter : iter.next().then((function(result) {
            return result.done ? result.value : iter.next();
        }));
    },
    keys: function keys(object) {
        var keys = [];
        for (var key in object) keys.push(key);
        return keys.reverse(), function next() {
            for (;keys.length; ) {
                var key = keys.pop();
                if (key in object) return next.value = key, next.done = !1, next;
            }
            return next.done = !0, next;
        };
    },
    values
}, require$$1 = getAugmentedNamespace(Object.freeze({
    __proto__: null,
    default: index$1
})), _interopRequireDefault$2 = interopRequireDefault.exports;

Object.defineProperty(es$s, "__esModule", {
    value: !0
}), es$s.isNodePattern = function isNodePattern(cb) {
    if (void 0 === cb) return !1;
    if ("function" != typeof cb) throw new TypeError("Callback must be a function");
    return !0;
}, es$s.throwError = function throwError(error, cb) {
    if ("string" == typeof error && (error = new Error(error)), "function" == typeof cb) return cb.call(this, error);
    throw error;
}, es$s.scan = function scan(image, x, y, w, h, f) {
    x = Math.round(x), y = Math.round(y), w = Math.round(w), h = Math.round(h);
    for (var _y = y; _y < y + h; _y++) for (var _x = x; _x < x + w; _x++) {
        var idx = image.bitmap.width * _y + _x << 2;
        f.call(image, _x, _y, idx);
    }
    return image;
}, es$s.scanIterator = scanIterator;

var _regenerator = _interopRequireDefault$2(require$$1), _marked = _regenerator.default.mark(scanIterator);

function scanIterator(image, x, y, w, h) {
    var _y, _x, idx;
    return _regenerator.default.wrap((function scanIterator$(_context) {
        for (;;) switch (_context.prev = _context.next) {
          case 0:
            x = Math.round(x), y = Math.round(y), w = Math.round(w), h = Math.round(h), _y = y;

          case 5:
            if (!(_y < y + h)) {
                _context.next = 17;
                break;
            }
            _x = x;

          case 7:
            if (!(_x < x + w)) {
                _context.next = 14;
                break;
            }
            return idx = image.bitmap.width * _y + _x << 2, _context.next = 11, {
                x: _x,
                y: _y,
                idx,
                image
            };

          case 11:
            _x++, _context.next = 7;
            break;

          case 14:
            _y++, _context.next = 5;
            break;

          case 17:
          case "end":
            return _context.stop();
        }
    }), _marked);
}

function Converter$1(srcAlphabet, dstAlphabet) {
    if (!(srcAlphabet && dstAlphabet && srcAlphabet.length && dstAlphabet.length)) throw new Error("Bad alphabet");
    this.srcAlphabet = srcAlphabet, this.dstAlphabet = dstAlphabet;
}

Converter$1.prototype.convert = function(number) {
    var i, divide, newlen, numberMap = {}, fromBase = this.srcAlphabet.length, toBase = this.dstAlphabet.length, length = number.length, result = "string" == typeof number ? "" : [];
    if (!this.isValid(number)) throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
    if (this.srcAlphabet === this.dstAlphabet) return number;
    for (i = 0; i < length; i++) numberMap[i] = this.srcAlphabet.indexOf(number[i]);
    do {
        for (divide = 0, newlen = 0, i = 0; i < length; i++) (divide = divide * fromBase + numberMap[i]) >= toBase ? (numberMap[newlen++] = parseInt(divide / toBase, 10), 
        divide %= toBase) : newlen > 0 && (numberMap[newlen++] = 0);
        length = newlen, result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
    } while (0 !== newlen);
    return result;
}, Converter$1.prototype.isValid = function(number) {
    for (var i = 0; i < number.length; ++i) if (-1 === this.srcAlphabet.indexOf(number[i])) return !1;
    return !0;
};

var Converter = Converter$1;

function anyBase(srcAlphabet, dstAlphabet) {
    var converter = new Converter(srcAlphabet, dstAlphabet);
    return function(number) {
        return converter.convert(number);
    };
}

anyBase.BIN = "01", anyBase.OCT = "01234567", anyBase.DEC = "0123456789", anyBase.HEX = "0123456789abcdef";

var anyBase_1 = anyBase, path = require$$0__default.default, fs$2 = require$$1__default.default, _0777 = parseInt("0777", 8), mkdirp = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP(p, opts, f, made) {
    "function" == typeof opts ? (f = opts, opts = {}) : opts && "object" == typeof opts || (opts = {
        mode: opts
    });
    var mode = opts.mode, xfs = opts.fs || fs$2;
    void 0 === mode && (mode = _0777), made || (made = null);
    var cb = f || function() {};
    p = path.resolve(p), xfs.mkdir(p, mode, (function(er) {
        if (!er) return cb(null, made = made || p);
        if ("ENOENT" === er.code) {
            if (path.dirname(p) === p) return cb(er);
            mkdirP(path.dirname(p), opts, (function(er, made) {
                er ? cb(er, made) : mkdirP(p, opts, cb, made);
            }));
        } else xfs.stat(p, (function(er2, stat) {
            er2 || !stat.isDirectory() ? cb(er, made) : cb(null, made);
        }));
    }));
}

mkdirP.sync = function sync(p, opts, made) {
    opts && "object" == typeof opts || (opts = {
        mode: opts
    });
    var mode = opts.mode, xfs = opts.fs || fs$2;
    void 0 === mode && (mode = _0777), made || (made = null), p = path.resolve(p);
    try {
        xfs.mkdirSync(p, mode), made = made || p;
    } catch (err0) {
        if ("ENOENT" === err0.code) made = sync(path.dirname(p), opts, made), sync(p, opts, made); else {
            var stat;
            try {
                stat = xfs.statSync(p);
            } catch (err1) {
                throw err0;
            }
            if (!stat.isDirectory()) throw err0;
        }
    }
    return made;
};

var pixelmatch_1 = function pixelmatch(img1, img2, output, width, height, options) {
    options || (options = {});
    for (var threshold = void 0 === options.threshold ? 0.1 : options.threshold, maxDelta = 35215 * threshold * threshold, diff = 0, y = 0; y < height; y++) for (var x = 0; x < width; x++) {
        var pos = 4 * (y * width + x);
        if (colorDelta(img1, img2, pos, pos) > maxDelta) options.includeAA || !antialiased(img1, x, y, width, height, img2) && !antialiased(img2, x, y, width, height, img1) ? (output && drawPixel(output, pos, 255, 0, 0), 
        diff++) : output && drawPixel(output, pos, 255, 255, 0); else if (output) {
            var val = blend((a = (img = img1)[(i = pos) + 3] / 255, rgb2y(blend(img[i + 0], a), blend(img[i + 1], a), blend(img[i + 2], a))), 0.1);
            drawPixel(output, pos, val, val, val);
        }
    }
    var img, i, a;
    return diff;
};

function antialiased(img, x1, y1, width, height, img2) {
    for (var minX, minY, maxX, maxY, x0 = Math.max(x1 - 1, 0), y0 = Math.max(y1 - 1, 0), x2 = Math.min(x1 + 1, width - 1), y2 = Math.min(y1 + 1, height - 1), pos = 4 * (y1 * width + x1), zeroes = 0, positives = 0, negatives = 0, min = 0, max = 0, x = x0; x <= x2; x++) for (var y = y0; y <= y2; y++) if (x !== x1 || y !== y1) {
        var delta = colorDelta(img, img, pos, 4 * (y * width + x), !0);
        if (0 === delta ? zeroes++ : delta < 0 ? negatives++ : delta > 0 && positives++, 
        zeroes > 2) return !1;
        img2 && (delta < min && (min = delta, minX = x, minY = y), delta > max && (max = delta, 
        maxX = x, maxY = y));
    }
    return !img2 || 0 !== negatives && 0 !== positives && (!antialiased(img, minX, minY, width, height) && !antialiased(img2, minX, minY, width, height) || !antialiased(img, maxX, maxY, width, height) && !antialiased(img2, maxX, maxY, width, height));
}

function colorDelta(img1, img2, k, m, yOnly) {
    var a1 = img1[k + 3] / 255, a2 = img2[m + 3] / 255, r1 = blend(img1[k + 0], a1), g1 = blend(img1[k + 1], a1), b1 = blend(img1[k + 2], a1), r2 = blend(img2[m + 0], a2), g2 = blend(img2[m + 1], a2), b2 = blend(img2[m + 2], a2), y = rgb2y(r1, g1, b1) - rgb2y(r2, g2, b2);
    if (yOnly) return y;
    var i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2), q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);
    return 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;
}

function rgb2y(r, g, b) {
    return 0.29889531 * r + 0.58662247 * g + 0.11448223 * b;
}

function rgb2i(r, g, b) {
    return 0.59597799 * r - 0.27417610 * g - 0.32180189 * b;
}

function rgb2q(r, g, b) {
    return 0.21147017 * r - 0.52261711 * g + 0.31114694 * b;
}

function blend(c, a) {
    return 255 + (c - 255) * a;
}

function drawPixel(output, pos, r, g, b) {
    output[pos + 0] = r, output[pos + 1] = g, output[pos + 2] = b, output[pos + 3] = 255;
}

var tinycolor = {
    exports: {}
};

function ImagePHash(size, smallerSize) {
    this.size = this.size || size, this.smallerSize = this.smallerSize || smallerSize, 
    function initCoefficients(size) {
        for (var i = 1; i < size; i++) c$1[i] = 1;
        c$1[0] = 1 / Math.sqrt(2.0);
    }(this.size);
}

!function(module) {
    !function(Math) {
        var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math.round, mathMin = Math.min, mathMax = Math.max, mathRandom = Math.random;
        function tinycolor(color, opts) {
            if (opts = opts || {}, (color = color || "") instanceof tinycolor) return color;
            if (!(this instanceof tinycolor)) return new tinycolor(color, opts);
            var rgb = function inputToRGB(color) {
                var rgb = {
                    r: 0,
                    g: 0,
                    b: 0
                }, a = 1, s = null, v = null, l = null, ok = !1, format = !1;
                return "string" == typeof color && (color = function stringInputToObject(color) {
                    color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
                    var match, named = !1;
                    if (names[color]) color = names[color], named = !0; else if ("transparent" == color) return {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0,
                        format: "name"
                    };
                    return (match = matchers.rgb.exec(color)) ? {
                        r: match[1],
                        g: match[2],
                        b: match[3]
                    } : (match = matchers.rgba.exec(color)) ? {
                        r: match[1],
                        g: match[2],
                        b: match[3],
                        a: match[4]
                    } : (match = matchers.hsl.exec(color)) ? {
                        h: match[1],
                        s: match[2],
                        l: match[3]
                    } : (match = matchers.hsla.exec(color)) ? {
                        h: match[1],
                        s: match[2],
                        l: match[3],
                        a: match[4]
                    } : (match = matchers.hsv.exec(color)) ? {
                        h: match[1],
                        s: match[2],
                        v: match[3]
                    } : (match = matchers.hsva.exec(color)) ? {
                        h: match[1],
                        s: match[2],
                        v: match[3],
                        a: match[4]
                    } : (match = matchers.hex8.exec(color)) ? {
                        r: parseIntFromHex(match[1]),
                        g: parseIntFromHex(match[2]),
                        b: parseIntFromHex(match[3]),
                        a: convertHexToDecimal(match[4]),
                        format: named ? "name" : "hex8"
                    } : (match = matchers.hex6.exec(color)) ? {
                        r: parseIntFromHex(match[1]),
                        g: parseIntFromHex(match[2]),
                        b: parseIntFromHex(match[3]),
                        format: named ? "name" : "hex"
                    } : (match = matchers.hex4.exec(color)) ? {
                        r: parseIntFromHex(match[1] + "" + match[1]),
                        g: parseIntFromHex(match[2] + "" + match[2]),
                        b: parseIntFromHex(match[3] + "" + match[3]),
                        a: convertHexToDecimal(match[4] + "" + match[4]),
                        format: named ? "name" : "hex8"
                    } : !!(match = matchers.hex3.exec(color)) && {
                        r: parseIntFromHex(match[1] + "" + match[1]),
                        g: parseIntFromHex(match[2] + "" + match[2]),
                        b: parseIntFromHex(match[3] + "" + match[3]),
                        format: named ? "name" : "hex"
                    };
                }(color)), "object" == typeof color && (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b) ? (rgb = function rgbToRgb(r, g, b) {
                    return {
                        r: 255 * bound01(r, 255),
                        g: 255 * bound01(g, 255),
                        b: 255 * bound01(b, 255)
                    };
                }(color.r, color.g, color.b), ok = !0, format = "%" === String(color.r).substr(-1) ? "prgb" : "rgb") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v) ? (s = convertToPercentage(color.s), 
                v = convertToPercentage(color.v), rgb = function hsvToRgb(h, s, v) {
                    h = 6 * bound01(h, 360), s = bound01(s, 100), v = bound01(v, 100);
                    var i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6;
                    return {
                        r: 255 * [ v, q, p, p, t, v ][mod],
                        g: 255 * [ t, v, v, q, p, p ][mod],
                        b: 255 * [ p, p, t, v, v, q ][mod]
                    };
                }(color.h, s, v), ok = !0, format = "hsv") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l) && (s = convertToPercentage(color.s), 
                l = convertToPercentage(color.l), rgb = function hslToRgb(h, s, l) {
                    var r, g, b;
                    function hue2rgb(p, q, t) {
                        return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;
                    }
                    if (h = bound01(h, 360), s = bound01(s, 100), l = bound01(l, 100), 0 === s) r = g = b = l; else {
                        var q = l < 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
                        r = hue2rgb(p, q, h + 1 / 3), g = hue2rgb(p, q, h), b = hue2rgb(p, q, h - 1 / 3);
                    }
                    return {
                        r: 255 * r,
                        g: 255 * g,
                        b: 255 * b
                    };
                }(color.h, s, l), ok = !0, format = "hsl"), color.hasOwnProperty("a") && (a = color.a)), 
                a = boundAlpha(a), {
                    ok,
                    format: color.format || format,
                    r: mathMin(255, mathMax(rgb.r, 0)),
                    g: mathMin(255, mathMax(rgb.g, 0)),
                    b: mathMin(255, mathMax(rgb.b, 0)),
                    a
                };
            }(color);
            this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, 
            this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format, 
            this._gradientType = opts.gradientType, this._r < 1 && (this._r = mathRound(this._r)), 
            this._g < 1 && (this._g = mathRound(this._g)), this._b < 1 && (this._b = mathRound(this._b)), 
            this._ok = rgb.ok, this._tc_id = tinyCounter++;
        }
        function rgbToHsl(r, g, b) {
            r = bound01(r, 255), g = bound01(g, 255), b = bound01(b, 255);
            var h, s, max = mathMax(r, g, b), min = mathMin(r, g, b), l = (max + min) / 2;
            if (max == min) h = s = 0; else {
                var d = max - min;
                switch (s = l > 0.5 ? d / (2 - max - min) : d / (max + min), max) {
                  case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;

                  case g:
                    h = (b - r) / d + 2;
                    break;

                  case b:
                    h = (r - g) / d + 4;
                }
                h /= 6;
            }
            return {
                h,
                s,
                l
            };
        }
        function rgbToHsv(r, g, b) {
            r = bound01(r, 255), g = bound01(g, 255), b = bound01(b, 255);
            var h, s, max = mathMax(r, g, b), min = mathMin(r, g, b), v = max, d = max - min;
            if (s = 0 === max ? 0 : d / max, max == min) h = 0; else {
                switch (max) {
                  case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;

                  case g:
                    h = (b - r) / d + 2;
                    break;

                  case b:
                    h = (r - g) / d + 4;
                }
                h /= 6;
            }
            return {
                h,
                s,
                v
            };
        }
        function rgbToHex(r, g, b, allow3Char) {
            var hex = [ pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16)) ];
            return allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) ? hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) : hex.join("");
        }
        function rgbaToArgbHex(r, g, b, a) {
            return [ pad2(convertDecimalToHex(a)), pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16)) ].join("");
        }
        function desaturate(color, amount) {
            amount = 0 === amount ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            return hsl.s -= amount / 100, hsl.s = clamp01(hsl.s), tinycolor(hsl);
        }
        function saturate(color, amount) {
            amount = 0 === amount ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            return hsl.s += amount / 100, hsl.s = clamp01(hsl.s), tinycolor(hsl);
        }
        function greyscale(color) {
            return tinycolor(color).desaturate(100);
        }
        function lighten(color, amount) {
            amount = 0 === amount ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            return hsl.l += amount / 100, hsl.l = clamp01(hsl.l), tinycolor(hsl);
        }
        function brighten(color, amount) {
            amount = 0 === amount ? 0 : amount || 10;
            var rgb = tinycolor(color).toRgb();
            return rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(-amount / 100 * 255))), 
            rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(-amount / 100 * 255))), rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(-amount / 100 * 255))), 
            tinycolor(rgb);
        }
        function darken(color, amount) {
            amount = 0 === amount ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            return hsl.l -= amount / 100, hsl.l = clamp01(hsl.l), tinycolor(hsl);
        }
        function spin(color, amount) {
            var hsl = tinycolor(color).toHsl(), hue = (hsl.h + amount) % 360;
            return hsl.h = hue < 0 ? 360 + hue : hue, tinycolor(hsl);
        }
        function complement(color) {
            var hsl = tinycolor(color).toHsl();
            return hsl.h = (hsl.h + 180) % 360, tinycolor(hsl);
        }
        function triad(color) {
            var hsl = tinycolor(color).toHsl(), h = hsl.h;
            return [ tinycolor(color), tinycolor({
                h: (h + 120) % 360,
                s: hsl.s,
                l: hsl.l
            }), tinycolor({
                h: (h + 240) % 360,
                s: hsl.s,
                l: hsl.l
            }) ];
        }
        function tetrad(color) {
            var hsl = tinycolor(color).toHsl(), h = hsl.h;
            return [ tinycolor(color), tinycolor({
                h: (h + 90) % 360,
                s: hsl.s,
                l: hsl.l
            }), tinycolor({
                h: (h + 180) % 360,
                s: hsl.s,
                l: hsl.l
            }), tinycolor({
                h: (h + 270) % 360,
                s: hsl.s,
                l: hsl.l
            }) ];
        }
        function splitcomplement(color) {
            var hsl = tinycolor(color).toHsl(), h = hsl.h;
            return [ tinycolor(color), tinycolor({
                h: (h + 72) % 360,
                s: hsl.s,
                l: hsl.l
            }), tinycolor({
                h: (h + 216) % 360,
                s: hsl.s,
                l: hsl.l
            }) ];
        }
        function analogous(color, results, slices) {
            results = results || 6, slices = slices || 30;
            var hsl = tinycolor(color).toHsl(), part = 360 / slices, ret = [ tinycolor(color) ];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) hsl.h = (hsl.h + part) % 360, 
            ret.push(tinycolor(hsl));
            return ret;
        }
        function monochromatic(color, results) {
            results = results || 6;
            for (var hsv = tinycolor(color).toHsv(), h = hsv.h, s = hsv.s, v = hsv.v, ret = [], modification = 1 / results; results--; ) ret.push(tinycolor({
                h,
                s,
                v
            })), v = (v + modification) % 1;
            return ret;
        }
        tinycolor.prototype = {
            isDark: function() {
                return this.getBrightness() < 128;
            },
            isLight: function() {
                return !this.isDark();
            },
            isValid: function() {
                return this._ok;
            },
            getOriginalInput: function() {
                return this._originalInput;
            },
            getFormat: function() {
                return this._format;
            },
            getAlpha: function() {
                return this._a;
            },
            getBrightness: function() {
                var rgb = this.toRgb();
                return (299 * rgb.r + 587 * rgb.g + 114 * rgb.b) / 1000;
            },
            getLuminance: function() {
                var RsRGB, GsRGB, BsRGB, rgb = this.toRgb();
                return RsRGB = rgb.r / 255, GsRGB = rgb.g / 255, BsRGB = rgb.b / 255, 0.2126 * (RsRGB <= 0.03928 ? RsRGB / 12.92 : Math.pow((RsRGB + 0.055) / 1.055, 2.4)) + 0.7152 * (GsRGB <= 0.03928 ? GsRGB / 12.92 : Math.pow((GsRGB + 0.055) / 1.055, 2.4)) + 0.0722 * (BsRGB <= 0.03928 ? BsRGB / 12.92 : Math.pow((BsRGB + 0.055) / 1.055, 2.4));
            },
            setAlpha: function(value) {
                return this._a = boundAlpha(value), this._roundA = mathRound(100 * this._a) / 100, 
                this;
            },
            toHsv: function() {
                var hsv = rgbToHsv(this._r, this._g, this._b);
                return {
                    h: 360 * hsv.h,
                    s: hsv.s,
                    v: hsv.v,
                    a: this._a
                };
            },
            toHsvString: function() {
                var hsv = rgbToHsv(this._r, this._g, this._b), h = mathRound(360 * hsv.h), s = mathRound(100 * hsv.s), v = mathRound(100 * hsv.v);
                return 1 == this._a ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
            },
            toHsl: function() {
                var hsl = rgbToHsl(this._r, this._g, this._b);
                return {
                    h: 360 * hsl.h,
                    s: hsl.s,
                    l: hsl.l,
                    a: this._a
                };
            },
            toHslString: function() {
                var hsl = rgbToHsl(this._r, this._g, this._b), h = mathRound(360 * hsl.h), s = mathRound(100 * hsl.s), l = mathRound(100 * hsl.l);
                return 1 == this._a ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
            },
            toHex: function(allow3Char) {
                return rgbToHex(this._r, this._g, this._b, allow3Char);
            },
            toHexString: function(allow3Char) {
                return "#" + this.toHex(allow3Char);
            },
            toHex8: function(allow4Char) {
                return function rgbaToHex(r, g, b, a, allow4Char) {
                    var hex = [ pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16)), pad2(convertDecimalToHex(a)) ];
                    return allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1) ? hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0) : hex.join("");
                }(this._r, this._g, this._b, this._a, allow4Char);
            },
            toHex8String: function(allow4Char) {
                return "#" + this.toHex8(allow4Char);
            },
            toRgb: function() {
                return {
                    r: mathRound(this._r),
                    g: mathRound(this._g),
                    b: mathRound(this._b),
                    a: this._a
                };
            },
            toRgbString: function() {
                return 1 == this._a ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
            },
            toPercentageRgb: function() {
                return {
                    r: mathRound(100 * bound01(this._r, 255)) + "%",
                    g: mathRound(100 * bound01(this._g, 255)) + "%",
                    b: mathRound(100 * bound01(this._b, 255)) + "%",
                    a: this._a
                };
            },
            toPercentageRgbString: function() {
                return 1 == this._a ? "rgb(" + mathRound(100 * bound01(this._r, 255)) + "%, " + mathRound(100 * bound01(this._g, 255)) + "%, " + mathRound(100 * bound01(this._b, 255)) + "%)" : "rgba(" + mathRound(100 * bound01(this._r, 255)) + "%, " + mathRound(100 * bound01(this._g, 255)) + "%, " + mathRound(100 * bound01(this._b, 255)) + "%, " + this._roundA + ")";
            },
            toName: function() {
                return 0 === this._a ? "transparent" : !(this._a < 1) && (hexNames[rgbToHex(this._r, this._g, this._b, !0)] || !1);
            },
            toFilter: function(secondColor) {
                var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a), secondHex8String = hex8String, gradientType = this._gradientType ? "GradientType = 1, " : "";
                if (secondColor) {
                    var s = tinycolor(secondColor);
                    secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
                }
                return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
            },
            toString: function(format) {
                var formatSet = !!format;
                format = format || this._format;
                var formattedString = !1, hasAlpha = this._a < 1 && this._a >= 0;
                return formatSet || !hasAlpha || "hex" !== format && "hex6" !== format && "hex3" !== format && "hex4" !== format && "hex8" !== format && "name" !== format ? ("rgb" === format && (formattedString = this.toRgbString()), 
                "prgb" === format && (formattedString = this.toPercentageRgbString()), "hex" !== format && "hex6" !== format || (formattedString = this.toHexString()), 
                "hex3" === format && (formattedString = this.toHexString(!0)), "hex4" === format && (formattedString = this.toHex8String(!0)), 
                "hex8" === format && (formattedString = this.toHex8String()), "name" === format && (formattedString = this.toName()), 
                "hsl" === format && (formattedString = this.toHslString()), "hsv" === format && (formattedString = this.toHsvString()), 
                formattedString || this.toHexString()) : "name" === format && 0 === this._a ? this.toName() : this.toRgbString();
            },
            clone: function() {
                return tinycolor(this.toString());
            },
            _applyModification: function(fn, args) {
                var color = fn.apply(null, [ this ].concat([].slice.call(args)));
                return this._r = color._r, this._g = color._g, this._b = color._b, this.setAlpha(color._a), 
                this;
            },
            lighten: function() {
                return this._applyModification(lighten, arguments);
            },
            brighten: function() {
                return this._applyModification(brighten, arguments);
            },
            darken: function() {
                return this._applyModification(darken, arguments);
            },
            desaturate: function() {
                return this._applyModification(desaturate, arguments);
            },
            saturate: function() {
                return this._applyModification(saturate, arguments);
            },
            greyscale: function() {
                return this._applyModification(greyscale, arguments);
            },
            spin: function() {
                return this._applyModification(spin, arguments);
            },
            _applyCombination: function(fn, args) {
                return fn.apply(null, [ this ].concat([].slice.call(args)));
            },
            analogous: function() {
                return this._applyCombination(analogous, arguments);
            },
            complement: function() {
                return this._applyCombination(complement, arguments);
            },
            monochromatic: function() {
                return this._applyCombination(monochromatic, arguments);
            },
            splitcomplement: function() {
                return this._applyCombination(splitcomplement, arguments);
            },
            triad: function() {
                return this._applyCombination(triad, arguments);
            },
            tetrad: function() {
                return this._applyCombination(tetrad, arguments);
            }
        }, tinycolor.fromRatio = function(color, opts) {
            if ("object" == typeof color) {
                var newColor = {};
                for (var i in color) color.hasOwnProperty(i) && (newColor[i] = "a" === i ? color[i] : convertToPercentage(color[i]));
                color = newColor;
            }
            return tinycolor(color, opts);
        }, tinycolor.equals = function(color1, color2) {
            return !(!color1 || !color2) && tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
        }, tinycolor.random = function() {
            return tinycolor.fromRatio({
                r: mathRandom(),
                g: mathRandom(),
                b: mathRandom()
            });
        }, tinycolor.mix = function(color1, color2, amount) {
            amount = 0 === amount ? 0 : amount || 50;
            var rgb1 = tinycolor(color1).toRgb(), rgb2 = tinycolor(color2).toRgb(), p = amount / 100;
            return tinycolor({
                r: (rgb2.r - rgb1.r) * p + rgb1.r,
                g: (rgb2.g - rgb1.g) * p + rgb1.g,
                b: (rgb2.b - rgb1.b) * p + rgb1.b,
                a: (rgb2.a - rgb1.a) * p + rgb1.a
            });
        }, tinycolor.readability = function(color1, color2) {
            var c1 = tinycolor(color1), c2 = tinycolor(color2);
            return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
        }, tinycolor.isReadable = function(color1, color2, wcag2) {
            var wcag2Parms, out, readability = tinycolor.readability(color1, color2);
            switch (out = !1, (wcag2Parms = function validateWCAG2Parms(parms) {
                var level, size;
                return "AA" !== (level = ((parms = parms || {
                    level: "AA",
                    size: "small"
                }).level || "AA").toUpperCase()) && "AAA" !== level && (level = "AA"), "small" !== (size = (parms.size || "small").toLowerCase()) && "large" !== size && (size = "small"), 
                {
                    level,
                    size
                };
            }(wcag2)).level + wcag2Parms.size) {
              case "AAsmall":
              case "AAAlarge":
                out = readability >= 4.5;
                break;

              case "AAlarge":
                out = readability >= 3;
                break;

              case "AAAsmall":
                out = readability >= 7;
            }
            return out;
        }, tinycolor.mostReadable = function(baseColor, colorList, args) {
            var readability, includeFallbackColors, level, size, bestColor = null, bestScore = 0;
            includeFallbackColors = (args = args || {}).includeFallbackColors, level = args.level, 
            size = args.size;
            for (var i = 0; i < colorList.length; i++) (readability = tinycolor.readability(baseColor, colorList[i])) > bestScore && (bestScore = readability, 
            bestColor = tinycolor(colorList[i]));
            return tinycolor.isReadable(baseColor, bestColor, {
                level,
                size
            }) || !includeFallbackColors ? bestColor : (args.includeFallbackColors = !1, tinycolor.mostReadable(baseColor, [ "#fff", "#000" ], args));
        };
        var names = tinycolor.names = {
            aliceblue: "f0f8ff",
            antiquewhite: "faebd7",
            aqua: "0ff",
            aquamarine: "7fffd4",
            azure: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "000",
            blanchedalmond: "ffebcd",
            blue: "00f",
            blueviolet: "8a2be2",
            brown: "a52a2a",
            burlywood: "deb887",
            burntsienna: "ea7e5d",
            cadetblue: "5f9ea0",
            chartreuse: "7fff00",
            chocolate: "d2691e",
            coral: "ff7f50",
            cornflowerblue: "6495ed",
            cornsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "0ff",
            darkblue: "00008b",
            darkcyan: "008b8b",
            darkgoldenrod: "b8860b",
            darkgray: "a9a9a9",
            darkgreen: "006400",
            darkgrey: "a9a9a9",
            darkkhaki: "bdb76b",
            darkmagenta: "8b008b",
            darkolivegreen: "556b2f",
            darkorange: "ff8c00",
            darkorchid: "9932cc",
            darkred: "8b0000",
            darksalmon: "e9967a",
            darkseagreen: "8fbc8f",
            darkslateblue: "483d8b",
            darkslategray: "2f4f4f",
            darkslategrey: "2f4f4f",
            darkturquoise: "00ced1",
            darkviolet: "9400d3",
            deeppink: "ff1493",
            deepskyblue: "00bfff",
            dimgray: "696969",
            dimgrey: "696969",
            dodgerblue: "1e90ff",
            firebrick: "b22222",
            floralwhite: "fffaf0",
            forestgreen: "228b22",
            fuchsia: "f0f",
            gainsboro: "dcdcdc",
            ghostwhite: "f8f8ff",
            gold: "ffd700",
            goldenrod: "daa520",
            gray: "808080",
            green: "008000",
            greenyellow: "adff2f",
            grey: "808080",
            honeydew: "f0fff0",
            hotpink: "ff69b4",
            indianred: "cd5c5c",
            indigo: "4b0082",
            ivory: "fffff0",
            khaki: "f0e68c",
            lavender: "e6e6fa",
            lavenderblush: "fff0f5",
            lawngreen: "7cfc00",
            lemonchiffon: "fffacd",
            lightblue: "add8e6",
            lightcoral: "f08080",
            lightcyan: "e0ffff",
            lightgoldenrodyellow: "fafad2",
            lightgray: "d3d3d3",
            lightgreen: "90ee90",
            lightgrey: "d3d3d3",
            lightpink: "ffb6c1",
            lightsalmon: "ffa07a",
            lightseagreen: "20b2aa",
            lightskyblue: "87cefa",
            lightslategray: "789",
            lightslategrey: "789",
            lightsteelblue: "b0c4de",
            lightyellow: "ffffe0",
            lime: "0f0",
            limegreen: "32cd32",
            linen: "faf0e6",
            magenta: "f0f",
            maroon: "800000",
            mediumaquamarine: "66cdaa",
            mediumblue: "0000cd",
            mediumorchid: "ba55d3",
            mediumpurple: "9370db",
            mediumseagreen: "3cb371",
            mediumslateblue: "7b68ee",
            mediumspringgreen: "00fa9a",
            mediumturquoise: "48d1cc",
            mediumvioletred: "c71585",
            midnightblue: "191970",
            mintcream: "f5fffa",
            mistyrose: "ffe4e1",
            moccasin: "ffe4b5",
            navajowhite: "ffdead",
            navy: "000080",
            oldlace: "fdf5e6",
            olive: "808000",
            olivedrab: "6b8e23",
            orange: "ffa500",
            orangered: "ff4500",
            orchid: "da70d6",
            palegoldenrod: "eee8aa",
            palegreen: "98fb98",
            paleturquoise: "afeeee",
            palevioletred: "db7093",
            papayawhip: "ffefd5",
            peachpuff: "ffdab9",
            peru: "cd853f",
            pink: "ffc0cb",
            plum: "dda0dd",
            powderblue: "b0e0e6",
            purple: "800080",
            rebeccapurple: "663399",
            red: "f00",
            rosybrown: "bc8f8f",
            royalblue: "4169e1",
            saddlebrown: "8b4513",
            salmon: "fa8072",
            sandybrown: "f4a460",
            seagreen: "2e8b57",
            seashell: "fff5ee",
            sienna: "a0522d",
            silver: "c0c0c0",
            skyblue: "87ceeb",
            slateblue: "6a5acd",
            slategray: "708090",
            slategrey: "708090",
            snow: "fffafa",
            springgreen: "00ff7f",
            steelblue: "4682b4",
            tan: "d2b48c",
            teal: "008080",
            thistle: "d8bfd8",
            tomato: "ff6347",
            turquoise: "40e0d0",
            violet: "ee82ee",
            wheat: "f5deb3",
            white: "fff",
            whitesmoke: "f5f5f5",
            yellow: "ff0",
            yellowgreen: "9acd32"
        }, hexNames = tinycolor.hexNames = function flip(o) {
            var flipped = {};
            for (var i in o) o.hasOwnProperty(i) && (flipped[o[i]] = i);
            return flipped;
        }(names);
        function boundAlpha(a) {
            return a = parseFloat(a), (isNaN(a) || a < 0 || a > 1) && (a = 1), a;
        }
        function bound01(n, max) {
            (function isOnePointZero(n) {
                return "string" == typeof n && -1 != n.indexOf(".") && 1 === parseFloat(n);
            })(n) && (n = "100%");
            var processPercent = function isPercentage(n) {
                return "string" == typeof n && -1 != n.indexOf("%");
            }(n);
            return n = mathMin(max, mathMax(0, parseFloat(n))), processPercent && (n = parseInt(n * max, 10) / 100), 
            Math.abs(n - max) < 0.000001 ? 1 : n % max / parseFloat(max);
        }
        function clamp01(val) {
            return mathMin(1, mathMax(0, val));
        }
        function parseIntFromHex(val) {
            return parseInt(val, 16);
        }
        function pad2(c) {
            return 1 == c.length ? "0" + c : "" + c;
        }
        function convertToPercentage(n) {
            return n <= 1 && (n = 100 * n + "%"), n;
        }
        function convertDecimalToHex(d) {
            return Math.round(255 * parseFloat(d)).toString(16);
        }
        function convertHexToDecimal(h) {
            return parseIntFromHex(h) / 255;
        }
        var CSS_UNIT, PERMISSIVE_MATCH3, PERMISSIVE_MATCH4, matchers = (PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + (CSS_UNIT = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)") + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", 
        PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", 
        {
            CSS_UNIT: new RegExp(CSS_UNIT),
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        });
        function isValidCSSUnit(color) {
            return !!matchers.CSS_UNIT.exec(color);
        }
        module.exports ? module.exports = tinycolor : window.tinycolor = tinycolor;
    }(Math);
}(tinycolor), ImagePHash.prototype.size = 32, ImagePHash.prototype.smallerSize = 8, 
ImagePHash.prototype.distance = function(s1, s2) {
    for (var counter = 0, k = 0; k < s1.length; k++) s1[k] !== s2[k] && counter++;
    return counter / s1.length;
}, ImagePHash.prototype.getHash = function(img) {
    (img = img.clone().resize(this.size, this.size)).grayscale();
    for (var vals = [], x = 0; x < img.bitmap.width; x++) {
        vals[x] = [];
        for (var y = 0; y < img.bitmap.height; y++) vals[x][y] = (i = img.getPixelColor(x, y), 
        rgba = void 0, rgba = {}, rgba.r = Math.floor(i / Math.pow(256, 3)), rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2)), 
        rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1)), 
        rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0)), 
        rgba).b;
    }
    for (var i, rgba, dctVals = function applyDCT(f, size) {
        for (var N = size, F = [], u = 0; u < N; u++) {
            F[u] = [];
            for (var v = 0; v < N; v++) {
                for (var sum = 0, i = 0; i < N; i++) for (var j = 0; j < N; j++) sum += Math.cos((2 * i + 1) / (2.0 * N) * u * Math.PI) * Math.cos((2 * j + 1) / (2.0 * N) * v * Math.PI) * f[i][j];
                sum *= c$1[u] * c$1[v] / 4, F[u][v] = sum;
            }
        }
        return F;
    }(vals, this.size), total = 0, _x = 0; _x < this.smallerSize; _x++) for (var _y = 0; _y < this.smallerSize; _y++) total += dctVals[_x][_y];
    for (var avg = total / (this.smallerSize * this.smallerSize), hash = "", _x2 = 0; _x2 < this.smallerSize; _x2++) for (var _y2 = 0; _y2 < this.smallerSize; _y2++) hash += dctVals[_x2][_y2] > avg ? "1" : "0";
    return hash;
};

var c$1 = [], phash = ImagePHash, request$1 = {
    exports: {}
}, _extends = {
    exports: {}
};

!function(module) {
    function _extends() {
        return module.exports = _extends = Object.assign ? Object.assign.bind() : function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, module.exports.__esModule = !0, module.exports.default = module.exports, _extends.apply(this, arguments);
    }
    module.exports = _extends, module.exports.__esModule = !0, module.exports.default = module.exports;
}(_extends);

var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
    return typeof obj;
} : function(obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
}, http = require$$0__default$2.default, https = https__default.default, url$1 = require$$2__default.default, qs = require$$3__default.default, zlib$4 = require$$4__default.default, util$5 = require$$0__default$1.default, phin = function phin(opts, cb) {
    if ("string" != typeof opts && !opts.hasOwnProperty("url")) throw new Error("Missing url option from options for request method.");
    var addr = "object" === (void 0 === opts ? "undefined" : _typeof(opts)) ? url$1.parse(opts.url) : url$1.parse(opts), options = {
        hostname: addr.hostname,
        port: addr.port || ("http:" === addr.protocol.toLowerCase() ? 80 : 443),
        path: addr.path,
        method: "GET",
        headers: {},
        auth: addr.auth || null,
        parse: "none",
        stream: !1
    };
    if ("object" === (void 0 === opts ? "undefined" : _typeof(opts)) && (options = Object.assign(options, opts)), 
    options.port = Number(options.port), options.hasOwnProperty("timeout") && delete options.timeout, 
    !0 === options.compressed && (options.headers["accept-encoding"] = "gzip, deflate"), 
    opts.hasOwnProperty("form")) {
        if ("object" !== _typeof(opts.form)) throw new Error("phin 'form' option must be of type Object if present.");
        var formDataString = qs.stringify(opts.form);
        options.headers["Content-Type"] = "application/x-www-form-urlencoded", options.headers["Content-Length"] = Buffer.byteLength(formDataString), 
        opts.data = formDataString;
    }
    var req = void 0, resHandler = function resHandler(res) {
        var stream = res;
        !0 === options.compressed && ("gzip" === res.headers["content-encoding"] ? stream = res.pipe(zlib$4.createGunzip()) : "deflate" === res.headers["content-encoding"] && (stream = res.pipe(zlib$4.createInflate()))), 
        !0 === options.stream ? (res.stream = stream, cb && cb(null, res)) : (res.body = new Buffer([]), 
        stream.on("data", (function(chunk) {
            res.body = Buffer.concat([ res.body, chunk ]);
        })), stream.on("end", (function() {
            if (cb) {
                if ("json" === options.parse) try {
                    res.body = JSON.parse(res.body.toString());
                } catch (err) {
                    return void cb("Invalid JSON received.", res);
                }
                cb(null, res);
            }
        })));
    };
    switch (addr.protocol.toLowerCase()) {
      case "http:":
        req = http.request(options, resHandler);
        break;

      case "https:":
        req = https.request(options, resHandler);
        break;

      default:
        return void (cb && cb(new Error("Invalid / unknown URL protocol. Expected HTTP or HTTPS."), null));
    }
    if ("number" == typeof opts.timeout && req.setTimeout(opts.timeout, (function() {
        req.abort(), cb && cb(new Error("Timeout has been reached."), null), cb = null;
    })), req.on("error", (function(err) {
        cb && cb(err, null);
    })), opts.hasOwnProperty("data")) {
        var postData = opts.data;
        if (!(opts.data instanceof Buffer) && "object" === _typeof(opts.data)) if ("application/x-www-form-urlencoded" === (options.headers["content-type"] || options.headers["Content-Type"])) postData = qs.stringify(opts.data); else try {
            postData = JSON.stringify(opts.data);
        } catch (err) {
            cb && cb(new Error("Couldn't stringify object. (Likely due to a circular reference.)"), null);
        }
        req.write(postData);
    }
    req.end();
};

phin.promisified = function(opts, http) {
    return new Promise((function(resolve, reject) {
        phin(opts, (function(err, res) {
            err ? reject(err) : resolve(res);
        }));
    }));
}, util$5.promisify && (phin[util$5.promisify.custom] = phin.promisified);

var phin_compiled = phin, _interopRequireDefault$1 = interopRequireDefault.exports, _defineProperty2 = _interopRequireDefault$1(defineProperty.exports), _extends2 = _interopRequireDefault$1(_extends.exports);

function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter((function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        }))), keys.push.apply(keys, symbols);
    }
    return keys;
}

process.browser || "BROWSER" === process.env.ENVIRONMENT || void 0 !== process.versions.electron && "renderer" === process.type && "function" == typeof XMLHttpRequest ? request$1.exports = function(options, cb) {
    var xhr = new XMLHttpRequest;
    xhr.open("GET", options.url, !0), xhr.responseType = "arraybuffer", xhr.addEventListener("load", (function() {
        if (xhr.status < 400) try {
            var data = Buffer.from(this.response);
            cb(null, xhr, data);
        } catch (error) {
            return cb(new Error("Response is not a buffer for url " + options.url + ". Error: " + error.message));
        } else cb(new Error("HTTP Status " + xhr.status + " for url " + options.url));
    })), xhr.addEventListener("error", (function(e) {
        cb(e);
    })), xhr.send();
} : request$1.exports = function(_ref, cb) {
    var options = (0, _extends2.default)({}, _ref);
    phin_compiled(function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys(source, !0).forEach((function(key) {
                (0, _defineProperty2.default)(target, key, source[key]);
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(source).forEach((function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            }));
        }
        return target;
    }({
        compression: !0
    }, options), (function(err, res) {
        null === err ? cb(null, res, res.body) : cb(err);
    }));
};

var composite = {}, constants$9 = {};

Object.defineProperty(constants$9, "__esModule", {
    value: !0
}), constants$9.EDGE_CROP = constants$9.EDGE_WRAP = constants$9.EDGE_EXTEND = constants$9.BLEND_EXCLUSION = constants$9.BLEND_DIFFERENCE = constants$9.BLEND_HARDLIGHT = constants$9.BLEND_LIGHTEN = constants$9.BLEND_DARKEN = constants$9.BLEND_OVERLAY = constants$9.BLEND_SCREEN = constants$9.BLEND_ADD = constants$9.BLEND_MULTIPLY = constants$9.BLEND_DESTINATION_OVER = constants$9.BLEND_SOURCE_OVER = constants$9.VERTICAL_ALIGN_BOTTOM = constants$9.VERTICAL_ALIGN_MIDDLE = constants$9.VERTICAL_ALIGN_TOP = constants$9.HORIZONTAL_ALIGN_RIGHT = constants$9.HORIZONTAL_ALIGN_CENTER = constants$9.HORIZONTAL_ALIGN_LEFT = constants$9.AUTO = void 0, 
constants$9.AUTO = -1, constants$9.HORIZONTAL_ALIGN_LEFT = 1, constants$9.HORIZONTAL_ALIGN_CENTER = 2, 
constants$9.HORIZONTAL_ALIGN_RIGHT = 4, constants$9.VERTICAL_ALIGN_TOP = 8, constants$9.VERTICAL_ALIGN_MIDDLE = 16, 
constants$9.VERTICAL_ALIGN_BOTTOM = 32, constants$9.BLEND_SOURCE_OVER = "srcOver", 
constants$9.BLEND_DESTINATION_OVER = "dstOver", constants$9.BLEND_MULTIPLY = "multiply", 
constants$9.BLEND_ADD = "add", constants$9.BLEND_SCREEN = "screen", constants$9.BLEND_OVERLAY = "overlay", 
constants$9.BLEND_DARKEN = "darken", constants$9.BLEND_LIGHTEN = "lighten", constants$9.BLEND_HARDLIGHT = "hardLight", 
constants$9.BLEND_DIFFERENCE = "difference", constants$9.BLEND_EXCLUSION = "exclusion", 
constants$9.EDGE_EXTEND = 1, constants$9.EDGE_WRAP = 2, constants$9.EDGE_CROP = 3;

var compositeModes = {};

Object.defineProperty(compositeModes, "__esModule", {
    value: !0
}), compositeModes.srcOver = function srcOver(src, dst) {
    var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a, r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a, g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a, b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a;
    return {
        r,
        g,
        b,
        a
    };
}, compositeModes.dstOver = function dstOver(src, dst) {
    var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a, r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a, g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a, b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a;
    return {
        r,
        g,
        b,
        a
    };
}, compositeModes.multiply = function multiply(src, dst) {
    var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a, r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a, g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a, b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
    return {
        r,
        g,
        b,
        a
    };
}, compositeModes.add = function add(src, dst) {
    var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a, r = (sra + dra) / a, g = (sga + dga) / a, b = (sba + dba) / a;
    return {
        r,
        g,
        b,
        a
    };
}, compositeModes.screen = function screen(src, dst) {
    var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a, r = (sra * dst.a + dra * src.a - sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a, g = (sga * dst.a + dga * src.a - sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a, b = (sba * dst.a + dba * src.a - sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
    return {
        r,
        g,
        b,
        a
    };
}, compositeModes.overlay = function overlay(src, dst) {
    var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a, r = (2 * dra <= dst.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a, g = (2 * dga <= dst.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a, b = (2 * dba <= dst.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
    return {
        r,
        g,
        b,
        a
    };
}, compositeModes.darken = function darken(src, dst) {
    var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a, r = (Math.min(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a, g = (Math.min(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a, b = (Math.min(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
    return {
        r,
        g,
        b,
        a
    };
}, compositeModes.lighten = function lighten(src, dst) {
    var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a, r = (Math.max(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a, g = (Math.max(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a, b = (Math.max(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
    return {
        r,
        g,
        b,
        a
    };
}, compositeModes.hardLight = function hardLight(src, dst) {
    var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a, r = (2 * sra <= src.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a, g = (2 * sga <= src.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a, b = (2 * sba <= src.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
    return {
        r,
        g,
        b,
        a
    };
}, compositeModes.difference = function difference(src, dst) {
    var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a, r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a, g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a, b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a;
    return {
        r,
        g,
        b,
        a
    };
}, compositeModes.exclusion = function exclusion(src, dst) {
    var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
    src.a *= ops;
    var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a, r = (sra * dst.a + dra * src.a - 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a, g = (sga * dst.a + dga * src.a - 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a, b = (sba * dst.a + dba * src.a - 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
    return {
        r,
        g,
        b,
        a
    };
}, function(exports) {
    var _interopRequireWildcard = interopRequireWildcard.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = function composite(src, x, y) {
        var options = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, cb = arguments.length > 4 ? arguments[4] : void 0;
        if ("function" == typeof options && (cb = options, options = {}), !(src instanceof this.constructor)) return _utils.throwError.call(this, "The source must be a Jimp image", cb);
        if ("number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
        var _options = options, mode = _options.mode, opacitySource = _options.opacitySource, opacityDest = _options.opacityDest;
        mode || (mode = constants.BLEND_SOURCE_OVER), ("number" != typeof opacitySource || opacitySource < 0 || opacitySource > 1) && (opacitySource = 1.0), 
        ("number" != typeof opacityDest || opacityDest < 0 || opacityDest > 1) && (opacityDest = 1.0);
        var blendmode = compositeModes$1[mode];
        x = Math.round(x), y = Math.round(y);
        var baseImage = this;
        return 1.0 !== opacityDest && baseImage.opacity(opacityDest), src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, (function(sx, sy, idx) {
            var dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP), blended = blendmode({
                r: this.bitmap.data[idx + 0] / 255,
                g: this.bitmap.data[idx + 1] / 255,
                b: this.bitmap.data[idx + 2] / 255,
                a: this.bitmap.data[idx + 3] / 255
            }, {
                r: baseImage.bitmap.data[dstIdx + 0] / 255,
                g: baseImage.bitmap.data[dstIdx + 1] / 255,
                b: baseImage.bitmap.data[dstIdx + 2] / 255,
                a: baseImage.bitmap.data[dstIdx + 3] / 255
            }, opacitySource);
            baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(255 * blended.r), 
            baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(255 * blended.g), 
            baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(255 * blended.b), 
            baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(255 * blended.a);
        })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
    };
    var _utils = es$s, constants = _interopRequireWildcard(constants$9), compositeModes$1 = _interopRequireWildcard(compositeModes);
}(composite);

var promisify = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0, exports.default = function promisify(fun, ctx) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];
        return new Promise((function(resolve, reject) {
            args.push((function(err, data) {
                err && reject(err), resolve(data);
            })), fun.bind(ctx).apply(void 0, args);
        }));
    };
}(promisify);

var mime$2 = {};

Object.defineProperty(mime$2, "__esModule", {
    value: !0
}), mime$2.getExtension = mime$2.getType = mime$2.addType = void 0;

var mimeTypes = {};

mime$2.addType = function addType(mime, extensions) {
    mimeTypes[mime] = extensions;
}, mime$2.getType = function getType(path) {
    var pathParts = path.split("/").slice(-1);
    return function findType(extension) {
        return Object.entries(mimeTypes).find((function(type) {
            return type[1].includes(extension);
        })) || [];
    }(pathParts[pathParts.length - 1].split(".").pop())[0];
}, mime$2.getExtension = function getExtension(type) {
    return (mimeTypes[type.toLowerCase()] || [])[0];
};

var imageBitmap = {};

const toBytes = s => [ ...s ].map((c => c.charCodeAt(0))), xpiZipFilename = toBytes("META-INF/mozilla.rsa"), oxmlContentTypes = toBytes("[Content_Types].xml"), oxmlRels = toBytes("_rels/.rels");

var jpeg$1 = {
    parseSections: function(stream, iterator) {
        var len, markerType;
        for (stream.setBigEndian(!0); stream.remainingLength() > 0 && 0xDA !== markerType; ) {
            if (0xFF !== stream.nextUInt8()) throw new Error("Invalid JPEG section offset");
            len = (markerType = stream.nextUInt8()) >= 0xD0 && markerType <= 0xD9 || 0xDA === markerType ? 0 : stream.nextUInt16() - 2, 
            iterator(markerType, stream.branch(0, len)), stream.skip(len);
        }
    },
    getSizeFromSOFSection: function(stream) {
        return stream.skip(1), {
            height: stream.nextUInt16(),
            width: stream.nextUInt16()
        };
    },
    getSectionName: function(markerType) {
        var name, index;
        switch (markerType) {
          case 0xD8:
            name = "SOI";
            break;

          case 0xC4:
            name = "DHT";
            break;

          case 0xDB:
            name = "DQT";
            break;

          case 0xDD:
            name = "DRI";
            break;

          case 0xDA:
            name = "SOS";
            break;

          case 0xFE:
            name = "COM";
            break;

          case 0xD9:
            name = "EOI";
            break;

          default:
            markerType >= 0xE0 && markerType <= 0xEF ? (name = "APP", index = markerType - 0xE0) : markerType >= 0xC0 && markerType <= 0xCF && 0xC4 !== markerType && 0xC8 !== markerType && 0xCC !== markerType ? (name = "SOF", 
            index = markerType - 0xC0) : markerType >= 0xD0 && markerType <= 0xD7 && (name = "RST", 
            index = markerType - 0xD0);
        }
        var nameStruct = {
            name
        };
        return "number" == typeof index && (nameStruct.index = index), nameStruct;
    }
};

function readExifValue(format, stream) {
    switch (format) {
      case 1:
        return stream.nextUInt8();

      case 3:
      case 8:
        return stream.nextUInt16();

      case 4:
      case 9:
        return stream.nextUInt32();

      case 5:
        return [ stream.nextUInt32(), stream.nextUInt32() ];

      case 6:
        return stream.nextInt8();

      case 10:
        return [ stream.nextInt32(), stream.nextInt32() ];

      case 11:
        return stream.nextFloat();

      case 12:
        return stream.nextDouble();

      default:
        throw new Error("Invalid format while decoding: " + format);
    }
}

function readExifTag(tiffMarker, stream) {
    var values, c, tagType = stream.nextUInt16(), format = stream.nextUInt16(), bytesPerComponent = function getBytesPerComponent(format) {
        switch (format) {
          case 1:
          case 2:
          case 6:
          case 7:
            return 1;

          case 3:
          case 8:
            return 2;

          case 4:
          case 9:
          case 11:
            return 4;

          case 5:
          case 10:
          case 12:
            return 8;

          default:
            return 0;
        }
    }(format), components = stream.nextUInt32(), valueBytes = bytesPerComponent * components;
    if (valueBytes > 4 && (stream = tiffMarker.openWithOffset(stream.nextUInt32())), 
    2 === format) {
        var lastNull = (values = stream.nextString(components)).indexOf("\0");
        -1 !== lastNull && (values = values.substr(0, lastNull));
    } else if (7 === format) values = stream.nextBuffer(components); else if (0 !== format) for (values = [], 
    c = 0; c < components; ++c) values.push(readExifValue(format, stream));
    return valueBytes < 4 && stream.skip(4 - valueBytes), [ tagType, values, format ];
}

function readIFDSection(tiffMarker, stream, iterator) {
    var tag, i, numberOfEntries = stream.nextUInt16();
    for (i = 0; i < numberOfEntries; ++i) iterator((tag = readExifTag(tiffMarker, stream))[0], tag[1], tag[2]);
}

var exif$2 = {
    IFD0: 1,
    IFD1: 2,
    GPSIFD: 3,
    SubIFD: 4,
    InteropIFD: 5,
    parseTags: function(stream, iterator) {
        var tiffMarker, subIfdOffset, gpsOffset, interopOffset;
        try {
            tiffMarker = function readHeader(stream) {
                if ("Exif\0\0" !== stream.nextString(6)) throw new Error("Invalid EXIF header");
                var tiffMarker = stream.mark(), tiffHeader = stream.nextUInt16();
                if (0x4949 === tiffHeader) stream.setBigEndian(!1); else {
                    if (0x4D4D !== tiffHeader) throw new Error("Invalid TIFF header");
                    stream.setBigEndian(!0);
                }
                if (0x002A !== stream.nextUInt16()) throw new Error("Invalid TIFF data");
                return tiffMarker;
            }(stream);
        } catch (e) {
            return !1;
        }
        var ifd0Stream = tiffMarker.openWithOffset(stream.nextUInt32()), IFD0 = this.IFD0;
        readIFDSection(tiffMarker, ifd0Stream, (function(tagType, value, format) {
            switch (tagType) {
              case 0x8825:
                gpsOffset = value[0];
                break;

              case 0x8769:
                subIfdOffset = value[0];
                break;

              default:
                iterator(IFD0, tagType, value, format);
            }
        }));
        var ifd1Offset = ifd0Stream.nextUInt32();
        if (0 !== ifd1Offset) {
            var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);
            readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));
        }
        if (gpsOffset) {
            var gpsStream = tiffMarker.openWithOffset(gpsOffset);
            readIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));
        }
        if (subIfdOffset) {
            var subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD = this.InteropIFD;
            readIFDSection(tiffMarker, subIfdStream, (function(tagType, value, format) {
                0xA005 === tagType ? interopOffset = value[0] : iterator(InteropIFD, tagType, value, format);
            }));
        }
        if (interopOffset) {
            var interopStream = tiffMarker.openWithOffset(interopOffset);
            readIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));
        }
        return !0;
    }
};

function parseNumber(s) {
    return parseInt(s, 10);
}

function parseDateTimeParts(dateParts, timeParts) {
    dateParts = dateParts.map(parseNumber), timeParts = timeParts.map(parseNumber);
    var year = dateParts[0], month = dateParts[1] - 1, day = dateParts[2], hours = timeParts[0], minutes = timeParts[1], seconds = timeParts[2];
    return Date.UTC(year, month, day, hours, minutes, seconds, 0) / 1000;
}

var date_parseExifDate = function parseExifDate(dateTimeStr) {
    var isSpecFormat = 19 === dateTimeStr.length && ":" === dateTimeStr.charAt(4);
    return 25 === dateTimeStr.length && "T" === dateTimeStr.charAt(10) ? function parseDateWithTimezoneFormat(dateTimeStr) {
        var dateParts = dateTimeStr.substr(0, 10).split("-"), timeParts = dateTimeStr.substr(11, 8).split(":"), timezoneParts = dateTimeStr.substr(19, 6).split(":").map(parseNumber), timezoneOffset = 3600 * timezoneParts[0] + 60 * timezoneParts[1], timestamp = parseDateTimeParts(dateParts, timeParts);
        if ("number" == typeof (timestamp -= timezoneOffset) && !isNaN(timestamp)) return timestamp;
    }(dateTimeStr) : isSpecFormat ? function parseDateWithSpecFormat(dateTimeStr) {
        var parts = dateTimeStr.split(" "), timestamp = parseDateTimeParts(parts[0].split(":"), parts[1].split(":"));
        if ("number" == typeof timestamp && !isNaN(timestamp)) return timestamp;
    }(dateTimeStr) : void 0;
}, degreeTags = [ {
    section: exif$2.GPSIFD,
    type: 0x0002,
    name: "GPSLatitude",
    refType: 0x0001,
    refName: "GPSLatitudeRef",
    posVal: "N"
}, {
    section: exif$2.GPSIFD,
    type: 0x0004,
    name: "GPSLongitude",
    refType: 0x0003,
    refName: "GPSLongitudeRef",
    posVal: "E"
} ], dateTags = [ {
    section: exif$2.SubIFD,
    type: 0x0132,
    name: "ModifyDate"
}, {
    section: exif$2.SubIFD,
    type: 0x9003,
    name: "DateTimeOriginal"
}, {
    section: exif$2.SubIFD,
    type: 0x9004,
    name: "CreateDate"
}, {
    section: exif$2.SubIFD,
    type: 0x0132,
    name: "ModifyDate"
} ], simplify$1 = {
    castDegreeValues: function(getTagValue, setTagValue) {
        degreeTags.forEach((function(t) {
            var degreeVal = getTagValue(t);
            if (degreeVal) {
                var degreeNumRef = getTagValue({
                    section: t.section,
                    type: t.refType,
                    name: t.refName
                }) === t.posVal ? 1 : -1, degree = (degreeVal[0] + degreeVal[1] / 60 + degreeVal[2] / 3600) * degreeNumRef;
                setTagValue(t, degree);
            }
        }));
    },
    castDateValues: function(getTagValue, setTagValue) {
        dateTags.forEach((function(t) {
            var dateStrVal = getTagValue(t);
            if (dateStrVal) {
                var timestamp = date_parseExifDate(dateStrVal);
                void 0 !== timestamp && setTagValue(t, timestamp);
            }
        }));
    },
    simplifyValue: function(values, format) {
        return Array.isArray(values) && 1 === (values = values.map((function(value) {
            return 10 === format || 5 === format ? value[0] / value[1] : value;
        }))).length && (values = values[0]), values;
    }
}, exifTags = {
    exif: {
        1: "InteropIndex",
        2: "InteropVersion",
        11: "ProcessingSoftware",
        254: "SubfileType",
        255: "OldSubfileType",
        256: "ImageWidth",
        257: "ImageHeight",
        258: "BitsPerSample",
        259: "Compression",
        262: "PhotometricInterpretation",
        263: "Thresholding",
        264: "CellWidth",
        265: "CellLength",
        266: "FillOrder",
        269: "DocumentName",
        270: "ImageDescription",
        271: "Make",
        272: "Model",
        273: "StripOffsets",
        274: "Orientation",
        277: "SamplesPerPixel",
        278: "RowsPerStrip",
        279: "StripByteCounts",
        280: "MinSampleValue",
        281: "MaxSampleValue",
        282: "XResolution",
        283: "YResolution",
        284: "PlanarConfiguration",
        285: "PageName",
        286: "XPosition",
        287: "YPosition",
        288: "FreeOffsets",
        289: "FreeByteCounts",
        290: "GrayResponseUnit",
        291: "GrayResponseCurve",
        292: "T4Options",
        293: "T6Options",
        296: "ResolutionUnit",
        297: "PageNumber",
        300: "ColorResponseUnit",
        301: "TransferFunction",
        305: "Software",
        306: "ModifyDate",
        315: "Artist",
        316: "HostComputer",
        317: "Predictor",
        318: "WhitePoint",
        319: "PrimaryChromaticities",
        320: "ColorMap",
        321: "HalftoneHints",
        322: "TileWidth",
        323: "TileLength",
        324: "TileOffsets",
        325: "TileByteCounts",
        326: "BadFaxLines",
        327: "CleanFaxData",
        328: "ConsecutiveBadFaxLines",
        330: "SubIFD",
        332: "InkSet",
        333: "InkNames",
        334: "NumberofInks",
        336: "DotRange",
        337: "TargetPrinter",
        338: "ExtraSamples",
        339: "SampleFormat",
        340: "SMinSampleValue",
        341: "SMaxSampleValue",
        342: "TransferRange",
        343: "ClipPath",
        344: "XClipPathUnits",
        345: "YClipPathUnits",
        346: "Indexed",
        347: "JPEGTables",
        351: "OPIProxy",
        400: "GlobalParametersIFD",
        401: "ProfileType",
        402: "FaxProfile",
        403: "CodingMethods",
        404: "VersionYear",
        405: "ModeNumber",
        433: "Decode",
        434: "DefaultImageColor",
        435: "T82Options",
        437: "JPEGTables",
        512: "JPEGProc",
        513: "ThumbnailOffset",
        514: "ThumbnailLength",
        515: "JPEGRestartInterval",
        517: "JPEGLosslessPredictors",
        518: "JPEGPointTransforms",
        519: "JPEGQTables",
        520: "JPEGDCTables",
        521: "JPEGACTables",
        529: "YCbCrCoefficients",
        530: "YCbCrSubSampling",
        531: "YCbCrPositioning",
        532: "ReferenceBlackWhite",
        559: "StripRowCounts",
        700: "ApplicationNotes",
        999: "USPTOMiscellaneous",
        4096: "RelatedImageFileFormat",
        4097: "RelatedImageWidth",
        4098: "RelatedImageHeight",
        18246: "Rating",
        18247: "XP_DIP_XML",
        18248: "StitchInfo",
        18249: "RatingPercent",
        32781: "ImageID",
        32931: "WangTag1",
        32932: "WangAnnotation",
        32933: "WangTag3",
        32934: "WangTag4",
        32995: "Matteing",
        32996: "DataType",
        32997: "ImageDepth",
        32998: "TileDepth",
        33405: "Model2",
        33421: "CFARepeatPatternDim",
        33422: "CFAPattern2",
        33423: "BatteryLevel",
        33424: "KodakIFD",
        33432: "Copyright",
        33434: "ExposureTime",
        33437: "FNumber",
        33445: "MDFileTag",
        33446: "MDScalePixel",
        33447: "MDColorTable",
        33448: "MDLabName",
        33449: "MDSampleInfo",
        33450: "MDPrepDate",
        33451: "MDPrepTime",
        33452: "MDFileUnits",
        33550: "PixelScale",
        33589: "AdventScale",
        33590: "AdventRevision",
        33628: "UIC1Tag",
        33629: "UIC2Tag",
        33630: "UIC3Tag",
        33631: "UIC4Tag",
        33723: "IPTC-NAA",
        33918: "IntergraphPacketData",
        33919: "IntergraphFlagRegisters",
        33920: "IntergraphMatrix",
        33921: "INGRReserved",
        33922: "ModelTiePoint",
        34016: "Site",
        34017: "ColorSequence",
        34018: "IT8Header",
        34019: "RasterPadding",
        34020: "BitsPerRunLength",
        34021: "BitsPerExtendedRunLength",
        34022: "ColorTable",
        34023: "ImageColorIndicator",
        34024: "BackgroundColorIndicator",
        34025: "ImageColorValue",
        34026: "BackgroundColorValue",
        34027: "PixelIntensityRange",
        34028: "TransparencyIndicator",
        34029: "ColorCharacterization",
        34030: "HCUsage",
        34031: "TrapIndicator",
        34032: "CMYKEquivalent",
        34118: "SEMInfo",
        34152: "AFCP_IPTC",
        34232: "PixelMagicJBIGOptions",
        34264: "ModelTransform",
        34306: "WB_GRGBLevels",
        34310: "LeafData",
        34377: "PhotoshopSettings",
        34665: "ExifOffset",
        34675: "ICC_Profile",
        34687: "TIFF_FXExtensions",
        34688: "MultiProfiles",
        34689: "SharedData",
        34690: "T88Options",
        34732: "ImageLayer",
        34735: "GeoTiffDirectory",
        34736: "GeoTiffDoubleParams",
        34737: "GeoTiffAsciiParams",
        34850: "ExposureProgram",
        34852: "SpectralSensitivity",
        34853: "GPSInfo",
        34855: "ISO",
        34856: "Opto-ElectricConvFactor",
        34857: "Interlace",
        34858: "TimeZoneOffset",
        34859: "SelfTimerMode",
        34864: "SensitivityType",
        34865: "StandardOutputSensitivity",
        34866: "RecommendedExposureIndex",
        34867: "ISOSpeed",
        34868: "ISOSpeedLatitudeyyy",
        34869: "ISOSpeedLatitudezzz",
        34908: "FaxRecvParams",
        34909: "FaxSubAddress",
        34910: "FaxRecvTime",
        34954: "LeafSubIFD",
        36864: "ExifVersion",
        36867: "DateTimeOriginal",
        36868: "CreateDate",
        37121: "ComponentsConfiguration",
        37122: "CompressedBitsPerPixel",
        37377: "ShutterSpeedValue",
        37378: "ApertureValue",
        37379: "BrightnessValue",
        37380: "ExposureCompensation",
        37381: "MaxApertureValue",
        37382: "SubjectDistance",
        37383: "MeteringMode",
        37384: "LightSource",
        37385: "Flash",
        37386: "FocalLength",
        37387: "FlashEnergy",
        37388: "SpatialFrequencyResponse",
        37389: "Noise",
        37390: "FocalPlaneXResolution",
        37391: "FocalPlaneYResolution",
        37392: "FocalPlaneResolutionUnit",
        37393: "ImageNumber",
        37394: "SecurityClassification",
        37395: "ImageHistory",
        37396: "SubjectArea",
        37397: "ExposureIndex",
        37398: "TIFF-EPStandardID",
        37399: "SensingMethod",
        37434: "CIP3DataFile",
        37435: "CIP3Sheet",
        37436: "CIP3Side",
        37439: "StoNits",
        37500: "MakerNote",
        37510: "UserComment",
        37520: "SubSecTime",
        37521: "SubSecTimeOriginal",
        37522: "SubSecTimeDigitized",
        37679: "MSDocumentText",
        37680: "MSPropertySetStorage",
        37681: "MSDocumentTextPosition",
        37724: "ImageSourceData",
        40091: "XPTitle",
        40092: "XPComment",
        40093: "XPAuthor",
        40094: "XPKeywords",
        40095: "XPSubject",
        40960: "FlashpixVersion",
        40961: "ColorSpace",
        40962: "ExifImageWidth",
        40963: "ExifImageHeight",
        40964: "RelatedSoundFile",
        40965: "InteropOffset",
        41483: "FlashEnergy",
        41484: "SpatialFrequencyResponse",
        41485: "Noise",
        41486: "FocalPlaneXResolution",
        41487: "FocalPlaneYResolution",
        41488: "FocalPlaneResolutionUnit",
        41489: "ImageNumber",
        41490: "SecurityClassification",
        41491: "ImageHistory",
        41492: "SubjectLocation",
        41493: "ExposureIndex",
        41494: "TIFF-EPStandardID",
        41495: "SensingMethod",
        41728: "FileSource",
        41729: "SceneType",
        41730: "CFAPattern",
        41985: "CustomRendered",
        41986: "ExposureMode",
        41987: "WhiteBalance",
        41988: "DigitalZoomRatio",
        41989: "FocalLengthIn35mmFormat",
        41990: "SceneCaptureType",
        41991: "GainControl",
        41992: "Contrast",
        41993: "Saturation",
        41994: "Sharpness",
        41995: "DeviceSettingDescription",
        41996: "SubjectDistanceRange",
        42016: "ImageUniqueID",
        42032: "OwnerName",
        42033: "SerialNumber",
        42034: "LensInfo",
        42035: "LensMake",
        42036: "LensModel",
        42037: "LensSerialNumber",
        42112: "GDALMetadata",
        42113: "GDALNoData",
        42240: "Gamma",
        44992: "ExpandSoftware",
        44993: "ExpandLens",
        44994: "ExpandFilm",
        44995: "ExpandFilterLens",
        44996: "ExpandScanner",
        44997: "ExpandFlashLamp",
        48129: "PixelFormat",
        48130: "Transformation",
        48131: "Uncompressed",
        48132: "ImageType",
        48256: "ImageWidth",
        48257: "ImageHeight",
        48258: "WidthResolution",
        48259: "HeightResolution",
        48320: "ImageOffset",
        48321: "ImageByteCount",
        48322: "AlphaOffset",
        48323: "AlphaByteCount",
        48324: "ImageDataDiscard",
        48325: "AlphaDataDiscard",
        50215: "OceScanjobDesc",
        50216: "OceApplicationSelector",
        50217: "OceIDNumber",
        50218: "OceImageLogic",
        50255: "Annotations",
        50341: "PrintIM",
        50560: "USPTOOriginalContentType",
        50706: "DNGVersion",
        50707: "DNGBackwardVersion",
        50708: "UniqueCameraModel",
        50709: "LocalizedCameraModel",
        50710: "CFAPlaneColor",
        50711: "CFALayout",
        50712: "LinearizationTable",
        50713: "BlackLevelRepeatDim",
        50714: "BlackLevel",
        50715: "BlackLevelDeltaH",
        50716: "BlackLevelDeltaV",
        50717: "WhiteLevel",
        50718: "DefaultScale",
        50719: "DefaultCropOrigin",
        50720: "DefaultCropSize",
        50721: "ColorMatrix1",
        50722: "ColorMatrix2",
        50723: "CameraCalibration1",
        50724: "CameraCalibration2",
        50725: "ReductionMatrix1",
        50726: "ReductionMatrix2",
        50727: "AnalogBalance",
        50728: "AsShotNeutral",
        50729: "AsShotWhiteXY",
        50730: "BaselineExposure",
        50731: "BaselineNoise",
        50732: "BaselineSharpness",
        50733: "BayerGreenSplit",
        50734: "LinearResponseLimit",
        50735: "CameraSerialNumber",
        50736: "DNGLensInfo",
        50737: "ChromaBlurRadius",
        50738: "AntiAliasStrength",
        50739: "ShadowScale",
        50740: "DNGPrivateData",
        50741: "MakerNoteSafety",
        50752: "RawImageSegmentation",
        50778: "CalibrationIlluminant1",
        50779: "CalibrationIlluminant2",
        50780: "BestQualityScale",
        50781: "RawDataUniqueID",
        50784: "AliasLayerMetadata",
        50827: "OriginalRawFileName",
        50828: "OriginalRawFileData",
        50829: "ActiveArea",
        50830: "MaskedAreas",
        50831: "AsShotICCProfile",
        50832: "AsShotPreProfileMatrix",
        50833: "CurrentICCProfile",
        50834: "CurrentPreProfileMatrix",
        50879: "ColorimetricReference",
        50898: "PanasonicTitle",
        50899: "PanasonicTitle2",
        50931: "CameraCalibrationSig",
        50932: "ProfileCalibrationSig",
        50933: "ProfileIFD",
        50934: "AsShotProfileName",
        50935: "NoiseReductionApplied",
        50936: "ProfileName",
        50937: "ProfileHueSatMapDims",
        50938: "ProfileHueSatMapData1",
        50939: "ProfileHueSatMapData2",
        50940: "ProfileToneCurve",
        50941: "ProfileEmbedPolicy",
        50942: "ProfileCopyright",
        50964: "ForwardMatrix1",
        50965: "ForwardMatrix2",
        50966: "PreviewApplicationName",
        50967: "PreviewApplicationVersion",
        50968: "PreviewSettingsName",
        50969: "PreviewSettingsDigest",
        50970: "PreviewColorSpace",
        50971: "PreviewDateTime",
        50972: "RawImageDigest",
        50973: "OriginalRawFileDigest",
        50974: "SubTileBlockSize",
        50975: "RowInterleaveFactor",
        50981: "ProfileLookTableDims",
        50982: "ProfileLookTableData",
        51008: "OpcodeList1",
        51009: "OpcodeList2",
        51022: "OpcodeList3",
        51041: "NoiseProfile",
        51043: "TimeCodes",
        51044: "FrameRate",
        51058: "TStop",
        51081: "ReelName",
        51089: "OriginalDefaultFinalSize",
        51090: "OriginalBestQualitySize",
        51091: "OriginalDefaultCropSize",
        51105: "CameraLabel",
        51107: "ProfileHueSatMapEncoding",
        51108: "ProfileLookTableEncoding",
        51109: "BaselineExposureOffset",
        51110: "DefaultBlackRender",
        51111: "NewRawImageDigest",
        51112: "RawToPreviewGain",
        51125: "DefaultUserCrop",
        59932: "Padding",
        59933: "OffsetSchema",
        65000: "OwnerName",
        65001: "SerialNumber",
        65002: "Lens",
        65024: "KDC_IFD",
        65100: "RawFile",
        65101: "Converter",
        65102: "WhiteBalance",
        65105: "Exposure",
        65106: "Shadows",
        65107: "Brightness",
        65108: "Contrast",
        65109: "Saturation",
        65110: "Sharpness",
        65111: "Smoothness",
        65112: "MoireFilter"
    },
    gps: {
        0: "GPSVersionID",
        1: "GPSLatitudeRef",
        2: "GPSLatitude",
        3: "GPSLongitudeRef",
        4: "GPSLongitude",
        5: "GPSAltitudeRef",
        6: "GPSAltitude",
        7: "GPSTimeStamp",
        8: "GPSSatellites",
        9: "GPSStatus",
        10: "GPSMeasureMode",
        11: "GPSDOP",
        12: "GPSSpeedRef",
        13: "GPSSpeed",
        14: "GPSTrackRef",
        15: "GPSTrack",
        16: "GPSImgDirectionRef",
        17: "GPSImgDirection",
        18: "GPSMapDatum",
        19: "GPSDestLatitudeRef",
        20: "GPSDestLatitude",
        21: "GPSDestLongitudeRef",
        22: "GPSDestLongitude",
        23: "GPSDestBearingRef",
        24: "GPSDestBearing",
        25: "GPSDestDistanceRef",
        26: "GPSDestDistance",
        27: "GPSProcessingMethod",
        28: "GPSAreaInformation",
        29: "GPSDateStamp",
        30: "GPSDifferential",
        31: "GPSHPositioningError"
    }
}, jpeg = jpeg$1, exif = exif$2, simplify = simplify$1;

function ExifResult(startMarker, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset) {
    this.startMarker = startMarker, this.tags = tags, this.imageSize = imageSize, this.thumbnailOffset = thumbnailOffset, 
    this.thumbnailLength = thumbnailLength, this.thumbnailType = thumbnailType, this.app1Offset = app1Offset;
}

function Parser$5(stream) {
    this.stream = stream, this.flags = {
        readBinaryTags: !1,
        resolveTagNames: !0,
        simplifyValues: !0,
        imageSize: !0,
        hidePointers: !0,
        returnTags: !0
    };
}

ExifResult.prototype = {
    hasThumbnail: function(mime) {
        return !(!this.thumbnailOffset || !this.thumbnailLength || "string" == typeof mime && ("image/jpeg" === mime.toLowerCase().trim() ? 6 !== this.thumbnailType : "image/tiff" !== mime.toLowerCase().trim() || 1 !== this.thumbnailType));
    },
    getThumbnailOffset: function() {
        return this.app1Offset + 6 + this.thumbnailOffset;
    },
    getThumbnailLength: function() {
        return this.thumbnailLength;
    },
    getThumbnailBuffer: function() {
        return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
    },
    _getThumbnailStream: function() {
        return this.startMarker.openWithOffset(this.getThumbnailOffset());
    },
    getImageSize: function() {
        return this.imageSize;
    },
    getThumbnailSize: function() {
        var size, stream = this._getThumbnailStream();
        return jpeg.parseSections(stream, (function(sectionType, sectionStream) {
            "SOF" === jpeg.getSectionName(sectionType).name && (size = jpeg.getSizeFromSOFSection(sectionStream));
        })), size;
    }
}, Parser$5.prototype = {
    enableBinaryFields: function(enable) {
        return this.flags.readBinaryTags = !!enable, this;
    },
    enablePointers: function(enable) {
        return this.flags.hidePointers = !enable, this;
    },
    enableTagNames: function(enable) {
        return this.flags.resolveTagNames = !!enable, this;
    },
    enableImageSize: function(enable) {
        return this.flags.imageSize = !!enable, this;
    },
    enableReturnTags: function(enable) {
        return this.flags.returnTags = !!enable, this;
    },
    enableSimpleValues: function(enable) {
        return this.flags.simplifyValues = !!enable, this;
    },
    parse: function() {
        var tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset, tagNames, getTagValue, setTagValue, start = this.stream.mark(), stream = start.openWithOffset(0), flags = this.flags;
        return flags.resolveTagNames && (tagNames = exifTags), flags.resolveTagNames ? (tags = {}, 
        getTagValue = function(t) {
            return tags[t.name];
        }, setTagValue = function(t, value) {
            tags[t.name] = value;
        }) : (tags = [], getTagValue = function(t) {
            var i;
            for (i = 0; i < tags.length; ++i) if (tags[i].type === t.type && tags[i].section === t.section) return tags.value;
        }, setTagValue = function(t, value) {
            var i;
            for (i = 0; i < tags.length; ++i) if (tags[i].type === t.type && tags[i].section === t.section) return void (tags.value = value);
        }), jpeg.parseSections(stream, (function(sectionType, sectionStream) {
            var sectionOffset = sectionStream.offsetFrom(start);
            0xE1 === sectionType ? exif.parseTags(sectionStream, (function(ifdSection, tagType, value, format) {
                if (flags.readBinaryTags || 7 !== format) {
                    if (0x0201 === tagType) {
                        if (thumbnailOffset = value[0], flags.hidePointers) return;
                    } else if (0x0202 === tagType) {
                        if (thumbnailLength = value[0], flags.hidePointers) return;
                    } else if (0x0103 === tagType && (thumbnailType = value[0], flags.hidePointers)) return;
                    if (flags.returnTags) if (flags.simplifyValues && (value = simplify.simplifyValue(value, format)), 
                    flags.resolveTagNames) {
                        var name = (ifdSection === exif.GPSIFD ? tagNames.gps : tagNames.exif)[tagType];
                        name || (name = tagNames.exif[tagType]), tags.hasOwnProperty(name) || (tags[name] = value);
                    } else tags.push({
                        section: ifdSection,
                        type: tagType,
                        value
                    });
                }
            })) && (app1Offset = sectionOffset) : flags.imageSize && "SOF" === jpeg.getSectionName(sectionType).name && (imageSize = jpeg.getSizeFromSOFSection(sectionStream));
        })), flags.simplifyValues && (simplify.castDegreeValues(getTagValue, setTagValue), 
        simplify.castDateValues(getTagValue, setTagValue)), new ExifResult(start, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset);
    }
};

var parser$2 = Parser$5;

function DOMBufferStream(arrayBuffer, offset, length, bigEndian, global, parentOffset) {
    this.global = global, offset = offset || 0, length = length || arrayBuffer.byteLength - offset, 
    this.arrayBuffer = arrayBuffer.slice(offset, offset + length), this.view = new global.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength), 
    this.setBigEndian(bigEndian), this.offset = 0, this.parentOffset = (parentOffset || 0) + offset;
}

DOMBufferStream.prototype = {
    setBigEndian: function(bigEndian) {
        this.littleEndian = !bigEndian;
    },
    nextUInt8: function() {
        var value = this.view.getUint8(this.offset);
        return this.offset += 1, value;
    },
    nextInt8: function() {
        var value = this.view.getInt8(this.offset);
        return this.offset += 1, value;
    },
    nextUInt16: function() {
        var value = this.view.getUint16(this.offset, this.littleEndian);
        return this.offset += 2, value;
    },
    nextUInt32: function() {
        var value = this.view.getUint32(this.offset, this.littleEndian);
        return this.offset += 4, value;
    },
    nextInt16: function() {
        var value = this.view.getInt16(this.offset, this.littleEndian);
        return this.offset += 2, value;
    },
    nextInt32: function() {
        var value = this.view.getInt32(this.offset, this.littleEndian);
        return this.offset += 4, value;
    },
    nextFloat: function() {
        var value = this.view.getFloat32(this.offset, this.littleEndian);
        return this.offset += 4, value;
    },
    nextDouble: function() {
        var value = this.view.getFloat64(this.offset, this.littleEndian);
        return this.offset += 8, value;
    },
    nextBuffer: function(length) {
        var value = this.arrayBuffer.slice(this.offset, this.offset + length);
        return this.offset += length, value;
    },
    remainingLength: function() {
        return this.arrayBuffer.byteLength - this.offset;
    },
    nextString: function(length) {
        var value = this.arrayBuffer.slice(this.offset, this.offset + length);
        return value = String.fromCharCode.apply(null, new this.global.Uint8Array(value)), 
        this.offset += length, value;
    },
    mark: function() {
        var self = this;
        return {
            openWithOffset: function(offset) {
                return offset = (offset || 0) + this.offset, new DOMBufferStream(self.arrayBuffer, offset, self.arrayBuffer.byteLength - offset, !self.littleEndian, self.global, self.parentOffset);
            },
            offset: this.offset,
            getParentOffset: function() {
                return self.parentOffset;
            }
        };
    },
    offsetFrom: function(marker) {
        return this.parentOffset + this.offset - (marker.offset + marker.getParentOffset());
    },
    skip: function(amount) {
        this.offset += amount;
    },
    branch: function(offset, length) {
        return length = "number" == typeof length ? length : this.arrayBuffer.byteLength - (this.offset + offset), 
        new DOMBufferStream(this.arrayBuffer, this.offset + offset, length, !this.littleEndian, this.global, this.parentOffset);
    }
};

var domBufferstream = DOMBufferStream;

function BufferStream(buffer, offset, length, bigEndian) {
    this.buffer = buffer, this.offset = offset || 0, length = "number" == typeof length ? length : buffer.length, 
    this.endPosition = this.offset + length, this.setBigEndian(bigEndian);
}

BufferStream.prototype = {
    setBigEndian: function(bigEndian) {
        this.bigEndian = !!bigEndian;
    },
    nextUInt8: function() {
        var value = this.buffer.readUInt8(this.offset);
        return this.offset += 1, value;
    },
    nextInt8: function() {
        var value = this.buffer.readInt8(this.offset);
        return this.offset += 1, value;
    },
    nextUInt16: function() {
        var value = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
        return this.offset += 2, value;
    },
    nextUInt32: function() {
        var value = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
        return this.offset += 4, value;
    },
    nextInt16: function() {
        var value = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
        return this.offset += 2, value;
    },
    nextInt32: function() {
        var value = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
        return this.offset += 4, value;
    },
    nextFloat: function() {
        var value = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
        return this.offset += 4, value;
    },
    nextDouble: function() {
        var value = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
        return this.offset += 8, value;
    },
    nextBuffer: function(length) {
        var value = this.buffer.slice(this.offset, this.offset + length);
        return this.offset += length, value;
    },
    remainingLength: function() {
        return this.endPosition - this.offset;
    },
    nextString: function(length) {
        var value = this.buffer.toString("utf8", this.offset, this.offset + length);
        return this.offset += length, value;
    },
    mark: function() {
        var self = this;
        return {
            openWithOffset: function(offset) {
                return offset = (offset || 0) + this.offset, new BufferStream(self.buffer, offset, self.endPosition - offset, self.bigEndian);
            },
            offset: this.offset
        };
    },
    offsetFrom: function(marker) {
        return this.offset - marker.offset;
    },
    skip: function(amount) {
        this.offset += amount;
    },
    branch: function(offset, length) {
        return length = "number" == typeof length ? length : this.endPosition - (this.offset + offset), 
        new BufferStream(this.buffer, this.offset + offset, length, this.bigEndian);
    }
};

var bufferstream = BufferStream, Parser$4 = parser$2, exifParser = {
    create: function(buffer, global) {
        return buffer instanceof (global = global || function getGlobal() {
            return (0, eval)("this");
        }()).ArrayBuffer ? new Parser$4(new domBufferstream(buffer, 0, buffer.byteLength, !0, global)) : new Parser$4(new bufferstream(buffer, 0, buffer.length, !0));
    }
}, _interopRequireWildcard = interopRequireWildcard.exports, _interopRequireDefault = interopRequireDefault.exports;

Object.defineProperty(imageBitmap, "__esModule", {
    value: !0
}), imageBitmap.parseBitmap = function parseBitmap(data, path, cb) {
    var mime = function getMIMEFromBuffer(buffer, path) {
        var fileTypeFromBuffer = (0, _fileType.default)(buffer);
        return fileTypeFromBuffer ? fileTypeFromBuffer.mime : path ? MIME.getType(path) : null;
    }(data, path);
    if ("string" != typeof mime) return cb(new Error("Could not find MIME for Buffer <" + path + ">"));
    this._originalMime = mime.toLowerCase();
    try {
        var _mime = this.getMIME();
        if (!this.constructor.decoders[_mime]) return _utils.throwError.call(this, "Unsupported MIME type: " + _mime, cb);
        this.bitmap = this.constructor.decoders[_mime](data);
    } catch (error) {
        return cb.call(this, error, this);
    }
    try {
        this._exif = _exifParser.default.create(data).parse(), function exifRotate(img) {
            if (!(getExifOrientation(img) < 2)) {
                var transformation = function getExifOrientationTransformation(img) {
                    var w = img.getWidth(), h = img.getHeight();
                    switch (getExifOrientation(img)) {
                      case 1:
                      default:
                        return null;

                      case 2:
                        return function(x, y) {
                            return [ w - x - 1, y ];
                        };

                      case 3:
                        return function(x, y) {
                            return [ w - x - 1, h - y - 1 ];
                        };

                      case 4:
                        return function(x, y) {
                            return [ x, h - y - 1 ];
                        };

                      case 5:
                        return function(x, y) {
                            return [ y, x ];
                        };

                      case 6:
                        return function(x, y) {
                            return [ y, h - x - 1 ];
                        };

                      case 7:
                        return function(x, y) {
                            return [ w - y - 1, h - x - 1 ];
                        };

                      case 8:
                        return function(x, y) {
                            return [ w - y - 1, x ];
                        };
                    }
                }(img), swapDimensions = getExifOrientation(img) > 4;
                !function transformBitmap(img, width, height, transformation) {
                    for (var _data = img.bitmap.data, _width = img.bitmap.width, data = Buffer.alloc(_data.length), x = 0; x < width; x++) for (var y = 0; y < height; y++) {
                        var _transformation = transformation(x, y), _transformation2 = (0, _slicedToArray2.default)(_transformation, 2), _x = _transformation2[0], idx = width * y + x << 2, _idx = _width * _transformation2[1] + _x << 2, pixel = _data.readUInt32BE(_idx);
                        data.writeUInt32BE(pixel, idx);
                    }
                    img.bitmap.data = data, img.bitmap.width = width, img.bitmap.height = height;
                }(img, swapDimensions ? img.bitmap.height : img.bitmap.width, swapDimensions ? img.bitmap.width : img.bitmap.height, transformation);
            }
        }(this);
    } catch (error) {}
    return cb.call(this, null, this), this;
}, imageBitmap.getBuffer = getBuffer$1, imageBitmap.getBufferAsync = function getBufferAsync(mime) {
    return (0, _promisify.default)(getBuffer$1, this, mime);
};

var _slicedToArray2 = _interopRequireDefault(slicedToArray.exports), _fileType = _interopRequireDefault((input => {
    const buf = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buf && buf.length > 1)) return null;
    const check = (header, options) => {
        options = Object.assign({
            offset: 0
        }, options);
        for (let i = 0; i < header.length; i++) if (options.mask) {
            if (header[i] !== (options.mask[i] & buf[i + options.offset])) return !1;
        } else if (header[i] !== buf[i + options.offset]) return !1;
        return !0;
    }, checkString = (header, options) => check(toBytes(header), options);
    if (check([ 0xFF, 0xD8, 0xFF ])) return {
        ext: "jpg",
        mime: "image/jpeg"
    };
    if (check([ 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A ])) return {
        ext: "png",
        mime: "image/png"
    };
    if (check([ 0x47, 0x49, 0x46 ])) return {
        ext: "gif",
        mime: "image/gif"
    };
    if (check([ 0x57, 0x45, 0x42, 0x50 ], {
        offset: 8
    })) return {
        ext: "webp",
        mime: "image/webp"
    };
    if (check([ 0x46, 0x4C, 0x49, 0x46 ])) return {
        ext: "flif",
        mime: "image/flif"
    };
    if ((check([ 0x49, 0x49, 0x2A, 0x0 ]) || check([ 0x4D, 0x4D, 0x0, 0x2A ])) && check([ 0x43, 0x52 ], {
        offset: 8
    })) return {
        ext: "cr2",
        mime: "image/x-canon-cr2"
    };
    if (check([ 0x49, 0x49, 0x2A, 0x0 ]) || check([ 0x4D, 0x4D, 0x0, 0x2A ])) return {
        ext: "tif",
        mime: "image/tiff"
    };
    if (check([ 0x42, 0x4D ])) return {
        ext: "bmp",
        mime: "image/bmp"
    };
    if (check([ 0x49, 0x49, 0xBC ])) return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
    };
    if (check([ 0x38, 0x42, 0x50, 0x53 ])) return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
    };
    if (check([ 0x50, 0x4B, 0x3, 0x4 ])) {
        if (check([ 0x6D, 0x69, 0x6D, 0x65, 0x74, 0x79, 0x70, 0x65, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x65, 0x70, 0x75, 0x62, 0x2B, 0x7A, 0x69, 0x70 ], {
            offset: 30
        })) return {
            ext: "epub",
            mime: "application/epub+zip"
        };
        if (check(xpiZipFilename, {
            offset: 30
        })) return {
            ext: "xpi",
            mime: "application/x-xpinstall"
        };
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.text", {
            offset: 30
        })) return {
            ext: "odt",
            mime: "application/vnd.oasis.opendocument.text"
        };
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", {
            offset: 30
        })) return {
            ext: "ods",
            mime: "application/vnd.oasis.opendocument.spreadsheet"
        };
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.presentation", {
            offset: 30
        })) return {
            ext: "odp",
            mime: "application/vnd.oasis.opendocument.presentation"
        };
        const findNextZipHeaderIndex = (arr, startAt = 0) => arr.findIndex(((el, i, arr) => i >= startAt && 0x50 === arr[i] && 0x4B === arr[i + 1] && 0x3 === arr[i + 2] && 0x4 === arr[i + 3]));
        let zipHeaderIndex = 0, oxmlFound = !1, type = null;
        do {
            const offset = zipHeaderIndex + 30;
            if (oxmlFound || (oxmlFound = check(oxmlContentTypes, {
                offset
            }) || check(oxmlRels, {
                offset
            })), type || (checkString("word/", {
                offset
            }) ? type = {
                ext: "docx",
                mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            } : checkString("ppt/", {
                offset
            }) ? type = {
                ext: "pptx",
                mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
            } : checkString("xl/", {
                offset
            }) && (type = {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            })), oxmlFound && type) return type;
            zipHeaderIndex = findNextZipHeaderIndex(buf, offset);
        } while (zipHeaderIndex >= 0);
        if (type) return type;
    }
    if (check([ 0x50, 0x4B ]) && (0x3 === buf[2] || 0x5 === buf[2] || 0x7 === buf[2]) && (0x4 === buf[3] || 0x6 === buf[3] || 0x8 === buf[3])) return {
        ext: "zip",
        mime: "application/zip"
    };
    if (check([ 0x75, 0x73, 0x74, 0x61, 0x72 ], {
        offset: 257
    })) return {
        ext: "tar",
        mime: "application/x-tar"
    };
    if (check([ 0x52, 0x61, 0x72, 0x21, 0x1A, 0x7 ]) && (0x0 === buf[6] || 0x1 === buf[6])) return {
        ext: "rar",
        mime: "application/x-rar-compressed"
    };
    if (check([ 0x1F, 0x8B, 0x8 ])) return {
        ext: "gz",
        mime: "application/gzip"
    };
    if (check([ 0x42, 0x5A, 0x68 ])) return {
        ext: "bz2",
        mime: "application/x-bzip2"
    };
    if (check([ 0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C ])) return {
        ext: "7z",
        mime: "application/x-7z-compressed"
    };
    if (check([ 0x78, 0x01 ])) return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
    };
    if (check([ 0x33, 0x67, 0x70, 0x35 ]) || check([ 0x0, 0x0, 0x0 ]) && check([ 0x66, 0x74, 0x79, 0x70 ], {
        offset: 4
    }) && (check([ 0x6D, 0x70, 0x34, 0x31 ], {
        offset: 8
    }) || check([ 0x6D, 0x70, 0x34, 0x32 ], {
        offset: 8
    }) || check([ 0x69, 0x73, 0x6F, 0x6D ], {
        offset: 8
    }) || check([ 0x69, 0x73, 0x6F, 0x32 ], {
        offset: 8
    }) || check([ 0x6D, 0x6D, 0x70, 0x34 ], {
        offset: 8
    }) || check([ 0x4D, 0x34, 0x56 ], {
        offset: 8
    }) || check([ 0x64, 0x61, 0x73, 0x68 ], {
        offset: 8
    }))) return {
        ext: "mp4",
        mime: "video/mp4"
    };
    if (check([ 0x4D, 0x54, 0x68, 0x64 ])) return {
        ext: "mid",
        mime: "audio/midi"
    };
    if (check([ 0x1A, 0x45, 0xDF, 0xA3 ])) {
        const sliced = buf.subarray(4, 4100), idPos = sliced.findIndex(((el, i, arr) => 0x42 === arr[i] && 0x82 === arr[i + 1]));
        if (-1 !== idPos) {
            const docTypePos = idPos + 3, findDocType = type => [ ...type ].every(((c, i) => sliced[docTypePos + i] === c.charCodeAt(0)));
            if (findDocType("matroska")) return {
                ext: "mkv",
                mime: "video/x-matroska"
            };
            if (findDocType("webm")) return {
                ext: "webm",
                mime: "video/webm"
            };
        }
    }
    if (check([ 0x0, 0x0, 0x0, 0x14, 0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20 ]) || check([ 0x66, 0x72, 0x65, 0x65 ], {
        offset: 4
    }) || check([ 0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20 ], {
        offset: 4
    }) || check([ 0x6D, 0x64, 0x61, 0x74 ], {
        offset: 4
    }) || check([ 0x77, 0x69, 0x64, 0x65 ], {
        offset: 4
    })) return {
        ext: "mov",
        mime: "video/quicktime"
    };
    if (check([ 0x52, 0x49, 0x46, 0x46 ])) {
        if (check([ 0x41, 0x56, 0x49 ], {
            offset: 8
        })) return {
            ext: "avi",
            mime: "video/vnd.avi"
        };
        if (check([ 0x57, 0x41, 0x56, 0x45 ], {
            offset: 8
        })) return {
            ext: "wav",
            mime: "audio/vnd.wave"
        };
        if (check([ 0x51, 0x4C, 0x43, 0x4D ], {
            offset: 8
        })) return {
            ext: "qcp",
            mime: "audio/qcelp"
        };
    }
    if (check([ 0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9 ])) return {
        ext: "wmv",
        mime: "video/x-ms-wmv"
    };
    if (check([ 0x0, 0x0, 0x1, 0xBA ]) || check([ 0x0, 0x0, 0x1, 0xB3 ])) return {
        ext: "mpg",
        mime: "video/mpeg"
    };
    if (check([ 0x66, 0x74, 0x79, 0x70, 0x33, 0x67 ], {
        offset: 4
    })) return {
        ext: "3gp",
        mime: "video/3gpp"
    };
    for (let start = 0; start < 2 && start < buf.length - 16; start++) {
        if (check([ 0x49, 0x44, 0x33 ], {
            offset: start
        }) || check([ 0xFF, 0xE2 ], {
            offset: start,
            mask: [ 0xFF, 0xE2 ]
        })) return {
            ext: "mp3",
            mime: "audio/mpeg"
        };
        if (check([ 0xFF, 0xE4 ], {
            offset: start,
            mask: [ 0xFF, 0xE4 ]
        })) return {
            ext: "mp2",
            mime: "audio/mpeg"
        };
        if (check([ 0xFF, 0xF8 ], {
            offset: start,
            mask: [ 0xFF, 0xFC ]
        })) return {
            ext: "mp2",
            mime: "audio/mpeg"
        };
        if (check([ 0xFF, 0xF0 ], {
            offset: start,
            mask: [ 0xFF, 0xFC ]
        })) return {
            ext: "mp4",
            mime: "audio/mpeg"
        };
    }
    if (check([ 0x66, 0x74, 0x79, 0x70, 0x4D, 0x34, 0x41 ], {
        offset: 4
    }) || check([ 0x4D, 0x34, 0x41, 0x20 ])) return {
        ext: "m4a",
        mime: "audio/mp4"
    };
    if (check([ 0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64 ], {
        offset: 28
    })) return {
        ext: "opus",
        mime: "audio/opus"
    };
    if (check([ 0x4F, 0x67, 0x67, 0x53 ])) return check([ 0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61 ], {
        offset: 28
    }) ? {
        ext: "ogv",
        mime: "video/ogg"
    } : check([ 0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00 ], {
        offset: 28
    }) ? {
        ext: "ogm",
        mime: "video/ogg"
    } : check([ 0x7F, 0x46, 0x4C, 0x41, 0x43 ], {
        offset: 28
    }) ? {
        ext: "oga",
        mime: "audio/ogg"
    } : check([ 0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20 ], {
        offset: 28
    }) ? {
        ext: "spx",
        mime: "audio/ogg"
    } : check([ 0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73 ], {
        offset: 28
    }) ? {
        ext: "ogg",
        mime: "audio/ogg"
    } : {
        ext: "ogx",
        mime: "application/ogg"
    };
    if (check([ 0x66, 0x4C, 0x61, 0x43 ])) return {
        ext: "flac",
        mime: "audio/x-flac"
    };
    if (check([ 0x4D, 0x41, 0x43, 0x20 ])) return {
        ext: "ape",
        mime: "audio/ape"
    };
    if (check([ 0x77, 0x76, 0x70, 0x6B ])) return {
        ext: "wv",
        mime: "audio/wavpack"
    };
    if (check([ 0x23, 0x21, 0x41, 0x4D, 0x52, 0x0A ])) return {
        ext: "amr",
        mime: "audio/amr"
    };
    if (check([ 0x25, 0x50, 0x44, 0x46 ])) return {
        ext: "pdf",
        mime: "application/pdf"
    };
    if (check([ 0x4D, 0x5A ])) return {
        ext: "exe",
        mime: "application/x-msdownload"
    };
    if ((0x43 === buf[0] || 0x46 === buf[0]) && check([ 0x57, 0x53 ], {
        offset: 1
    })) return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
    };
    if (check([ 0x7B, 0x5C, 0x72, 0x74, 0x66 ])) return {
        ext: "rtf",
        mime: "application/rtf"
    };
    if (check([ 0x00, 0x61, 0x73, 0x6D ])) return {
        ext: "wasm",
        mime: "application/wasm"
    };
    if (check([ 0x77, 0x4F, 0x46, 0x46 ]) && (check([ 0x00, 0x01, 0x00, 0x00 ], {
        offset: 4
    }) || check([ 0x4F, 0x54, 0x54, 0x4F ], {
        offset: 4
    }))) return {
        ext: "woff",
        mime: "font/woff"
    };
    if (check([ 0x77, 0x4F, 0x46, 0x32 ]) && (check([ 0x00, 0x01, 0x00, 0x00 ], {
        offset: 4
    }) || check([ 0x4F, 0x54, 0x54, 0x4F ], {
        offset: 4
    }))) return {
        ext: "woff2",
        mime: "font/woff2"
    };
    if (check([ 0x4C, 0x50 ], {
        offset: 34
    }) && (check([ 0x00, 0x00, 0x01 ], {
        offset: 8
    }) || check([ 0x01, 0x00, 0x02 ], {
        offset: 8
    }) || check([ 0x02, 0x00, 0x02 ], {
        offset: 8
    }))) return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
    };
    if (check([ 0x00, 0x01, 0x00, 0x00, 0x00 ])) return {
        ext: "ttf",
        mime: "font/ttf"
    };
    if (check([ 0x4F, 0x54, 0x54, 0x4F, 0x00 ])) return {
        ext: "otf",
        mime: "font/otf"
    };
    if (check([ 0x00, 0x00, 0x01, 0x00 ])) return {
        ext: "ico",
        mime: "image/x-icon"
    };
    if (check([ 0x00, 0x00, 0x02, 0x00 ])) return {
        ext: "cur",
        mime: "image/x-icon"
    };
    if (check([ 0x46, 0x4C, 0x56, 0x01 ])) return {
        ext: "flv",
        mime: "video/x-flv"
    };
    if (check([ 0x25, 0x21 ])) return {
        ext: "ps",
        mime: "application/postscript"
    };
    if (check([ 0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00 ])) return {
        ext: "xz",
        mime: "application/x-xz"
    };
    if (check([ 0x53, 0x51, 0x4C, 0x69 ])) return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
    };
    if (check([ 0x4E, 0x45, 0x53, 0x1A ])) return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
    };
    if (check([ 0x43, 0x72, 0x32, 0x34 ])) return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
    };
    if (check([ 0x4D, 0x53, 0x43, 0x46 ]) || check([ 0x49, 0x53, 0x63, 0x28 ])) return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
    };
    if (check([ 0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E, 0x0A, 0x64, 0x65, 0x62, 0x69, 0x61, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x61, 0x72, 0x79 ])) return {
        ext: "deb",
        mime: "application/x-deb"
    };
    if (check([ 0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E ])) return {
        ext: "ar",
        mime: "application/x-unix-archive"
    };
    if (check([ 0xED, 0xAB, 0xEE, 0xDB ])) return {
        ext: "rpm",
        mime: "application/x-rpm"
    };
    if (check([ 0x1F, 0xA0 ]) || check([ 0x1F, 0x9D ])) return {
        ext: "Z",
        mime: "application/x-compress"
    };
    if (check([ 0x4C, 0x5A, 0x49, 0x50 ])) return {
        ext: "lz",
        mime: "application/x-lzip"
    };
    if (check([ 0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1 ])) return {
        ext: "msi",
        mime: "application/x-msi"
    };
    if (check([ 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02 ])) return {
        ext: "mxf",
        mime: "application/mxf"
    };
    if (check([ 0x47 ], {
        offset: 4
    }) && (check([ 0x47 ], {
        offset: 192
    }) || check([ 0x47 ], {
        offset: 196
    }))) return {
        ext: "mts",
        mime: "video/mp2t"
    };
    if (check([ 0x42, 0x4C, 0x45, 0x4E, 0x44, 0x45, 0x52 ])) return {
        ext: "blend",
        mime: "application/x-blender"
    };
    if (check([ 0x42, 0x50, 0x47, 0xFB ])) return {
        ext: "bpg",
        mime: "image/bpg"
    };
    if (check([ 0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A ])) {
        if (check([ 0x6A, 0x70, 0x32, 0x20 ], {
            offset: 20
        })) return {
            ext: "jp2",
            mime: "image/jp2"
        };
        if (check([ 0x6A, 0x70, 0x78, 0x20 ], {
            offset: 20
        })) return {
            ext: "jpx",
            mime: "image/jpx"
        };
        if (check([ 0x6A, 0x70, 0x6D, 0x20 ], {
            offset: 20
        })) return {
            ext: "jpm",
            mime: "image/jpm"
        };
        if (check([ 0x6D, 0x6A, 0x70, 0x32 ], {
            offset: 20
        })) return {
            ext: "mj2",
            mime: "image/mj2"
        };
    }
    if (check([ 0x46, 0x4F, 0x52, 0x4D, 0x00 ])) return {
        ext: "aif",
        mime: "audio/aiff"
    };
    if (checkString("<?xml ")) return {
        ext: "xml",
        mime: "application/xml"
    };
    if (check([ 0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49 ], {
        offset: 60
    })) return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
    };
    if (check([ 0x66, 0x74, 0x79, 0x70 ], {
        offset: 4
    })) {
        if (check([ 0x6D, 0x69, 0x66, 0x31 ], {
            offset: 8
        })) return {
            ext: "heic",
            mime: "image/heif"
        };
        if (check([ 0x6D, 0x73, 0x66, 0x31 ], {
            offset: 8
        })) return {
            ext: "heic",
            mime: "image/heif-sequence"
        };
        if (check([ 0x68, 0x65, 0x69, 0x63 ], {
            offset: 8
        }) || check([ 0x68, 0x65, 0x69, 0x78 ], {
            offset: 8
        })) return {
            ext: "heic",
            mime: "image/heic"
        };
        if (check([ 0x68, 0x65, 0x76, 0x63 ], {
            offset: 8
        }) || check([ 0x68, 0x65, 0x76, 0x78 ], {
            offset: 8
        })) return {
            ext: "heic",
            mime: "image/heic-sequence"
        };
    }
    return check([ 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A ]) ? {
        ext: "ktx",
        mime: "image/ktx"
    } : null;
})), _exifParser = _interopRequireDefault(exifParser), _utils = es$s, constants$8 = _interopRequireWildcard(constants$9), MIME = _interopRequireWildcard(mime$2), _promisify = _interopRequireDefault(promisify);

function getExifOrientation(img) {
    return img._exif && img._exif.tags && img._exif.tags.Orientation || 1;
}

function getBuffer$1(mime, cb) {
    if (mime === constants$8.AUTO && (mime = this.getMIME()), "string" != typeof mime) return _utils.throwError.call(this, "mime must be a string", cb);
    if ("function" != typeof cb) return _utils.throwError.call(this, "cb must be a function", cb);
    if (mime = mime.toLowerCase(), this._rgba && this.constructor.hasAlpha[mime] ? this.bitmap.data = Buffer.from(this.bitmap.data) : this.bitmap.data = function compositeBitmapOverBackground(Jimp, image) {
        return new Jimp(image.bitmap.width, image.bitmap.height, image._background).composite(image, 0, 0).bitmap;
    }(this.constructor, this).data, this.constructor.encoders[mime]) {
        var buffer = this.constructor.encoders[mime](this);
        cb.call(this, null, buffer);
    } else cb.call(this, "Unsupported MIME type: " + mime);
    return this;
}

!function(exports) {
    var _interopRequireWildcard = interopRequireWildcard.exports, _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.addConstants = addConstants, exports.addJimpMethods = addJimpMethods, 
    exports.jimpEvMethod = jimpEvMethod, exports.jimpEvChange = jimpEvChange, Object.defineProperty(exports, "addType", {
        enumerable: !0,
        get: function get() {
            return MIME.addType;
        }
    }), exports.default = void 0;
    for (var _construct2 = _interopRequireDefault(construct.exports), _slicedToArray2 = _interopRequireDefault(slicedToArray.exports), _classCallCheck2 = _interopRequireDefault(classCallCheck.exports), _createClass2 = _interopRequireDefault(createClass.exports), _possibleConstructorReturn2 = _interopRequireDefault(possibleConstructorReturn.exports), _getPrototypeOf2 = _interopRequireDefault(getPrototypeOf.exports), _assertThisInitialized2 = _interopRequireDefault(assertThisInitialized.exports), _inherits2 = _interopRequireDefault(inherits.exports), _defineProperty2 = _interopRequireDefault(defineProperty.exports), _typeof2 = _interopRequireDefault(_typeof$1.exports), _fs = _interopRequireDefault(require$$1__default.default), _path = _interopRequireDefault(require$$0__default.default), _events = _interopRequireDefault(require$$14__default.default), _utils = es$s, _anyBase = _interopRequireDefault(anyBase_1), _mkdirp = _interopRequireDefault(mkdirp), _pixelmatch = _interopRequireDefault(pixelmatch_1), _tinycolor = _interopRequireDefault(tinycolor.exports), _phash = _interopRequireDefault(phash), _request = _interopRequireDefault(request$1.exports), _composite = _interopRequireDefault(composite), _promisify = _interopRequireDefault(promisify), MIME = _interopRequireWildcard(mime$2), _imageBitmap = imageBitmap, constants = _interopRequireWildcard(constants$9), alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_", maxHashLength = [ NaN, NaN ], i = 2; i < 65; i++) {
        var maxHash = (0, _anyBase.default)(_anyBase.default.BIN, alphabet.slice(0, i))(new Array(65).join("1"));
        maxHashLength.push(maxHash.length);
    }
    function noop() {}
    function isArrayBuffer(test) {
        return Object.prototype.toString.call(test).toLowerCase().indexOf("arraybuffer") > -1;
    }
    function bufferFromArrayBuffer(arrayBuffer) {
        for (var buffer = Buffer.alloc(arrayBuffer.byteLength), view = new Uint8Array(arrayBuffer), _i = 0; _i < buffer.length; ++_i) buffer[_i] = view[_i];
        return buffer;
    }
    function loadFromURL(options, cb) {
        (0, _request.default)(options, (function(err, response, data) {
            if (err) return cb(err);
            if ("headers" in response && "location" in response.headers) return options.url = response.headers.location, 
            loadFromURL(options, cb);
            if ("object" === (0, _typeof2.default)(data) && Buffer.isBuffer(data)) return cb(null, data);
            var msg = "Could not load Buffer from <" + options.url + "> (HTTP: " + response.statusCode + ")";
            return new Error(msg);
        }));
    }
    function loadBufferFromPath(src, cb) {
        _fs.default && "function" == typeof _fs.default.readFile && !src.match(/^(http|ftp)s?:\/\/./) ? _fs.default.readFile(src, cb) : loadFromURL({
            url: src
        }, cb);
    }
    function isRawRGBAData(obj) {
        return obj && "object" === (0, _typeof2.default)(obj) && "number" == typeof obj.width && "number" == typeof obj.height && (Buffer.isBuffer(obj.data) || obj.data instanceof Uint8Array || "function" == typeof Uint8ClampedArray && obj.data instanceof Uint8ClampedArray) && (obj.data.length === obj.width * obj.height * 4 || obj.data.length === obj.width * obj.height * 3);
    }
    function makeRGBABufferFromRGB(buffer) {
        if (buffer.length % 3 != 0) throw new Error("Buffer length is incorrect");
        for (var rgbaBuffer = Buffer.allocUnsafe(buffer.length / 3 * 4), j = 0, _i2 = 0; _i2 < buffer.length; _i2++) rgbaBuffer[j] = buffer[_i2], 
        (_i2 + 1) % 3 == 0 && (rgbaBuffer[++j] = 255), j++;
        return rgbaBuffer;
    }
    var gl, emptyBitmap = {
        data: null,
        width: null,
        height: null
    }, Jimp = function(_EventEmitter) {
        function Jimp() {
            for (var _this, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            (0, _classCallCheck2.default)(this, Jimp), _this = (0, _possibleConstructorReturn2.default)(this, (0, 
            _getPrototypeOf2.default)(Jimp).call(this)), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "bitmap", emptyBitmap), 
            (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_background", 0x00000000), 
            (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_originalMime", Jimp.MIME_PNG), 
            (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_exif", null), 
            (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_rgba", !0), 
            (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "writeAsync", (function(path) {
                return (0, _promisify.default)(_this.write, (0, _assertThisInitialized2.default)(_this), path);
            })), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getBase64Async", (function(mime) {
                return (0, _promisify.default)(_this.getBase64, (0, _assertThisInitialized2.default)(_this), mime);
            })), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getBuffer", _imageBitmap.getBuffer), 
            (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getBufferAsync", _imageBitmap.getBufferAsync), 
            (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getPixelColour", _this.getPixelColor), 
            (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setPixelColour", _this.setPixelColor);
            var jimpInstance = (0, _assertThisInitialized2.default)(_this), cb = noop;
            function finish() {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                var err = args[0], evData = err || {};
                evData.methodName = "constructor", setTimeout((function() {
                    var _cb;
                    err && cb === noop ? jimpInstance.emitError("constructor", err) : err || jimpInstance.emitMulti("constructor", "initialized"), 
                    (_cb = cb).call.apply(_cb, [ jimpInstance ].concat(args));
                }), 1);
            }
            if (isArrayBuffer(args[0]) && (args[0] = bufferFromArrayBuffer(args[0])), "number" == typeof args[0] && "number" == typeof args[1] || parseInt(args[0], 10) && parseInt(args[1], 10)) {
                var w = parseInt(args[0], 10), h = parseInt(args[1], 10);
                if (cb = args[2], "number" == typeof args[2] && (_this._background = args[2], cb = args[3]), 
                "string" == typeof args[2] && (_this._background = Jimp.cssColorToHex(args[2]), 
                cb = args[3]), void 0 === cb && (cb = noop), "function" != typeof cb) return (0, 
                _possibleConstructorReturn2.default)(_this, _utils.throwError.call((0, _assertThisInitialized2.default)(_this), "cb must be a function", finish));
                _this.bitmap = {
                    data: Buffer.alloc(w * h * 4),
                    width: w,
                    height: h
                };
                for (var _i3 = 0; _i3 < _this.bitmap.data.length; _i3 += 4) _this.bitmap.data.writeUInt32BE(_this._background, _i3);
                finish(null, (0, _assertThisInitialized2.default)(_this));
            } else if ("object" === (0, _typeof2.default)(args[0]) && args[0].url) {
                if ("function" != typeof (cb = args[1] || noop)) return (0, _possibleConstructorReturn2.default)(_this, _utils.throwError.call((0, 
                _assertThisInitialized2.default)(_this), "cb must be a function", finish));
                loadFromURL(args[0], (function(err, data) {
                    if (err) return _utils.throwError.call((0, _assertThisInitialized2.default)(_this), err, finish);
                    _this.parseBitmap(data, args[0].url, finish);
                }));
            } else if (args[0] instanceof Jimp) {
                var original = args[0];
                if (void 0 === (cb = args[1]) && (cb = noop), "function" != typeof cb) return (0, 
                _possibleConstructorReturn2.default)(_this, _utils.throwError.call((0, _assertThisInitialized2.default)(_this), "cb must be a function", finish));
                _this.bitmap = {
                    data: Buffer.from(original.bitmap.data),
                    width: original.bitmap.width,
                    height: original.bitmap.height
                }, _this._quality = original._quality, _this._deflateLevel = original._deflateLevel, 
                _this._deflateStrategy = original._deflateStrategy, _this._filterType = original._filterType, 
                _this._rgba = original._rgba, _this._background = original._background, _this._originalMime = original._originalMime, 
                finish(null, (0, _assertThisInitialized2.default)(_this));
            } else if (isRawRGBAData(args[0])) {
                var imageData = args[0];
                cb = args[1] || noop;
                var isRGBA = imageData.width * imageData.height * 4 === imageData.data.length, buffer = isRGBA ? Buffer.from(imageData.data) : makeRGBABufferFromRGB(imageData.data);
                _this.bitmap = {
                    data: buffer,
                    width: imageData.width,
                    height: imageData.height
                }, finish(null, (0, _assertThisInitialized2.default)(_this));
            } else if ("string" == typeof args[0]) {
                var path = args[0];
                if (void 0 === (cb = args[1]) && (cb = noop), "function" != typeof cb) return (0, 
                _possibleConstructorReturn2.default)(_this, _utils.throwError.call((0, _assertThisInitialized2.default)(_this), "cb must be a function", finish));
                loadBufferFromPath(path, (function(err, data) {
                    if (err) return _utils.throwError.call((0, _assertThisInitialized2.default)(_this), err, finish);
                    _this.parseBitmap(data, path, finish);
                }));
            } else if ("object" === (0, _typeof2.default)(args[0]) && Buffer.isBuffer(args[0])) {
                var data = args[0];
                if ("function" != typeof (cb = args[1])) return (0, _possibleConstructorReturn2.default)(_this, _utils.throwError.call((0, 
                _assertThisInitialized2.default)(_this), "cb must be a function", finish));
                _this.parseBitmap(data, null, finish);
            } else {
                "function" != typeof (cb = args[args.length - 1]) && "function" != typeof (cb = args[args.length - 2]) && (cb = noop);
                var extraConstructor = Jimp.__extraConstructors.find((function(c) {
                    return c.test.apply(c, args);
                }));
                if (!extraConstructor) return (0, _possibleConstructorReturn2.default)(_this, _utils.throwError.call((0, 
                _assertThisInitialized2.default)(_this), "No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.", finish));
                new Promise((function(resolve, reject) {
                    var _extraConstructor$run;
                    return (_extraConstructor$run = extraConstructor.run).call.apply(_extraConstructor$run, [ (0, 
                    _assertThisInitialized2.default)(_this), resolve, reject ].concat(args));
                })).then((function() {
                    return finish(null, (0, _assertThisInitialized2.default)(_this));
                })).catch(finish);
            }
            return _this;
        }
        return (0, _inherits2.default)(Jimp, _EventEmitter), (0, _createClass2.default)(Jimp, [ {
            key: "parseBitmap",
            value: function parseBitmap(data, path, finish) {
                _imageBitmap.parseBitmap.call(this, data, null, finish);
            }
        }, {
            key: "rgba",
            value: function rgba(bool, cb) {
                return "boolean" != typeof bool ? _utils.throwError.call(this, "bool must be a boolean, true for RGBA or false for RGB", cb) : (this._rgba = bool, 
                (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
            }
        }, {
            key: "emitMulti",
            value: function emitMulti(methodName, eventName) {
                var data = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                data = Object.assign(data, {
                    methodName,
                    eventName
                }), this.emit("any", data), methodName && this.emit(methodName, data), this.emit(eventName, data);
            }
        }, {
            key: "emitError",
            value: function emitError(methodName, err) {
                this.emitMulti(methodName, "error", err);
            }
        }, {
            key: "getHeight",
            value: function getHeight() {
                return this.bitmap.height;
            }
        }, {
            key: "getWidth",
            value: function getWidth() {
                return this.bitmap.width;
            }
        }, {
            key: "inspect",
            value: function inspect() {
                return "<Jimp " + (this.bitmap === emptyBitmap ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
            }
        }, {
            key: "toString",
            value: function toString() {
                return "[object Jimp]";
            }
        }, {
            key: "getMIME",
            value: function getMIME() {
                return this._originalMime || Jimp.MIME_PNG;
            }
        }, {
            key: "getExtension",
            value: function getExtension() {
                var mime = this.getMIME();
                return MIME.getExtension(mime);
            }
        }, {
            key: "write",
            value: function write(path, cb) {
                var _this2 = this;
                if (!_fs.default || !_fs.default.createWriteStream) throw new Error("Cant access the filesystem. You can use the getBase64 method.");
                if ("string" != typeof path) return _utils.throwError.call(this, "path must be a string", cb);
                if (void 0 === cb && (cb = noop), "function" != typeof cb) return _utils.throwError.call(this, "cb must be a function", cb);
                var mime = MIME.getType(path) || this.getMIME(), pathObj = _path.default.parse(path);
                return pathObj.dir && _mkdirp.default.sync(pathObj.dir), this.getBuffer(mime, (function(err, buffer) {
                    if (err) return _utils.throwError.call(_this2, err, cb);
                    var stream = _fs.default.createWriteStream(path);
                    stream.on("open", (function() {
                        stream.write(buffer), stream.end();
                    })).on("error", (function(err) {
                        return _utils.throwError.call(_this2, err, cb);
                    })), stream.on("finish", (function() {
                        cb.call(_this2, null, _this2);
                    }));
                })), this;
            }
        }, {
            key: "getBase64",
            value: function getBase64(mime, cb) {
                return mime === Jimp.AUTO && (mime = this.getMIME()), "string" != typeof mime ? _utils.throwError.call(this, "mime must be a string", cb) : "function" != typeof cb ? _utils.throwError.call(this, "cb must be a function", cb) : (this.getBuffer(mime, (function(err, data) {
                    if (err) return _utils.throwError.call(this, err, cb);
                    var src = "data:" + mime + ";base64," + data.toString("base64");
                    cb.call(this, null, src);
                })), this);
            }
        }, {
            key: "hash",
            value: function hash(base, cb) {
                if ("function" == typeof (base = base || 64) && (cb = base, base = 64), "number" != typeof base) return _utils.throwError.call(this, "base must be a number", cb);
                if (base < 2 || base > 64) return _utils.throwError.call(this, "base must be a number between 2 and 64", cb);
                var hash = this.pHash();
                for (hash = (0, _anyBase.default)(_anyBase.default.BIN, alphabet.slice(0, base))(hash); hash.length < maxHashLength[base]; ) hash = "0" + hash;
                return (0, _utils.isNodePattern)(cb) && cb.call(this, null, hash), hash;
            }
        }, {
            key: "pHash",
            value: function pHash() {
                var pHash = new _phash.default;
                return pHash.getHash(this);
            }
        }, {
            key: "distanceFromHash",
            value: function distanceFromHash(compareHash) {
                var pHash = new _phash.default, currentHash = pHash.getHash(this);
                return pHash.distance(currentHash, compareHash);
            }
        }, {
            key: "getPixelIndex",
            value: function getPixelIndex(x, y, edgeHandling, cb) {
                var xi, yi;
                if ("function" == typeof edgeHandling && void 0 === cb && (cb = edgeHandling, edgeHandling = null), 
                edgeHandling || (edgeHandling = Jimp.EDGE_EXTEND), "number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
                xi = x = Math.round(x), yi = y = Math.round(y), edgeHandling === Jimp.EDGE_EXTEND && (x < 0 && (xi = 0), 
                x >= this.bitmap.width && (xi = this.bitmap.width - 1), y < 0 && (yi = 0), y >= this.bitmap.height && (yi = this.bitmap.height - 1)), 
                edgeHandling === Jimp.EDGE_WRAP && (x < 0 && (xi = this.bitmap.width + x), x >= this.bitmap.width && (xi = x % this.bitmap.width), 
                y < 0 && (xi = this.bitmap.height + y), y >= this.bitmap.height && (yi = y % this.bitmap.height));
                var i = this.bitmap.width * yi + xi << 2;
                return (xi < 0 || xi >= this.bitmap.width) && (i = -1), (yi < 0 || yi >= this.bitmap.height) && (i = -1), 
                (0, _utils.isNodePattern)(cb) && cb.call(this, null, i), i;
            }
        }, {
            key: "getPixelColor",
            value: function getPixelColor(x, y, cb) {
                if ("number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
                x = Math.round(x), y = Math.round(y);
                var idx = this.getPixelIndex(x, y), hex = this.bitmap.data.readUInt32BE(idx);
                return (0, _utils.isNodePattern)(cb) && cb.call(this, null, hex), hex;
            }
        }, {
            key: "setPixelColor",
            value: function setPixelColor(hex, x, y, cb) {
                if ("number" != typeof hex || "number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "hex, x and y must be numbers", cb);
                x = Math.round(x), y = Math.round(y);
                var idx = this.getPixelIndex(x, y);
                return this.bitmap.data.writeUInt32BE(hex, idx), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
                this;
            }
        }, {
            key: "hasAlpha",
            value: function hasAlpha() {
                for (var yIndex = 0; yIndex < this.bitmap.height; yIndex++) for (var xIndex = 0; xIndex < this.bitmap.width; xIndex++) {
                    var idx = this.bitmap.width * yIndex + xIndex << 2;
                    if (0xff !== this.bitmap.data[idx + 3]) return !0;
                }
                return !1;
            }
        }, {
            key: "scanIterator",
            value: function scanIterator(x, y, w, h) {
                return "number" != typeof x || "number" != typeof y ? _utils.throwError.call(this, "x and y must be numbers") : "number" != typeof w || "number" != typeof h ? _utils.throwError.call(this, "w and h must be numbers") : (0, 
                _utils.scanIterator)(this, x, y, w, h);
            }
        } ]), Jimp;
    }(_events.default);
    function addConstants(constants) {
        var jimpInstance = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Jimp;
        Object.entries(constants).forEach((function(_ref) {
            var _ref2 = (0, _slicedToArray2.default)(_ref, 2), name = _ref2[0], value = _ref2[1];
            jimpInstance[name] = value;
        }));
    }
    function addJimpMethods(methods) {
        var jimpInstance = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Jimp;
        Object.entries(methods).forEach((function(_ref3) {
            var _ref4 = (0, _slicedToArray2.default)(_ref3, 2), name = _ref4[0], value = _ref4[1];
            jimpInstance.prototype[name] = value;
        }));
    }
    function jimpEvMethod(methodName, evName, method) {
        var evNameBefore = "before-" + evName, evNameAfter = evName.replace(/e$/, "") + "ed";
        Jimp.prototype[methodName] = function() {
            for (var wrappedCb, _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
            var result, cb = args[method.length - 1], jimpInstance = this;
            "function" == typeof cb ? (wrappedCb = function wrappedCb() {
                for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) args[_key5] = arguments[_key5];
                var err = args[0], data = args[1];
                err ? jimpInstance.emitError(methodName, err) : jimpInstance.emitMulti(methodName, evNameAfter, (0, 
                _defineProperty2.default)({}, methodName, data)), cb.apply(this, args);
            }, args[args.length - 1] = wrappedCb) : wrappedCb = !1, this.emitMulti(methodName, evNameBefore);
            try {
                result = method.apply(this, args), wrappedCb || this.emitMulti(methodName, evNameAfter, (0, 
                _defineProperty2.default)({}, methodName, result));
            } catch (error) {
                error.methodName = methodName, this.emitError(methodName, error);
            }
            return result;
        }, Jimp.prototype[methodName + "Quiet"] = method;
    }
    function jimpEvChange(methodName, method) {
        jimpEvMethod(methodName, "change", method);
    }
    addConstants(constants), addJimpMethods({
        composite: _composite.default
    }), Jimp.__extraConstructors = [], Jimp.appendConstructorOption = function(name, test, run) {
        Jimp.__extraConstructors.push({
            name,
            test,
            run
        });
    }, Jimp.read = function() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
        return new Promise((function(resolve, reject) {
            (0, _construct2.default)(Jimp, args.concat([ function(err, image) {
                err ? reject(err) : resolve(image);
            } ]));
        }));
    }, Jimp.create = Jimp.read, Jimp.rgbaToInt = function(r, g, b, a, cb) {
        if ("number" != typeof r || "number" != typeof g || "number" != typeof b || "number" != typeof a) return _utils.throwError.call(this, "r, g, b and a must be numbers", cb);
        if (r < 0 || r > 255) return _utils.throwError.call(this, "r must be between 0 and 255", cb);
        if ((g < 0 || g > 255) && _utils.throwError.call(this, "g must be between 0 and 255", cb), 
        b < 0 || b > 255) return _utils.throwError.call(this, "b must be between 0 and 255", cb);
        if (a < 0 || a > 255) return _utils.throwError.call(this, "a must be between 0 and 255", cb);
        r = Math.round(r), b = Math.round(b), g = Math.round(g), a = Math.round(a);
        var i = r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a * Math.pow(256, 0);
        return (0, _utils.isNodePattern)(cb) && cb.call(this, null, i), i;
    }, Jimp.intToRGBA = function(i, cb) {
        if ("number" != typeof i) return _utils.throwError.call(this, "i must be a number", cb);
        var rgba = {};
        return rgba.r = Math.floor(i / Math.pow(256, 3)), rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2)), 
        rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1)), 
        rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0)), 
        (0, _utils.isNodePattern)(cb) && cb.call(this, null, rgba), rgba;
    }, Jimp.cssColorToHex = function(cssColor) {
        return "number" == typeof (cssColor = cssColor || 0) ? Number(cssColor) : parseInt((0, 
        _tinycolor.default)(cssColor).toHex8(), 16);
    }, Jimp.limit255 = function(n) {
        return n = Math.max(n, 0), Math.min(n, 255);
    }, Jimp.diff = function(img1, img2) {
        var threshold = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0.1;
        if (!(img1 instanceof Jimp && img2 instanceof Jimp)) return _utils.throwError.call(this, "img1 and img2 must be an Jimp images");
        var bmp1 = img1.bitmap, bmp2 = img2.bitmap;
        if (bmp1.width === bmp2.width && bmp1.height === bmp2.height || (bmp1.width * bmp1.height > bmp2.width * bmp2.height ? img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height) : img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height)), 
        "number" != typeof threshold || threshold < 0 || threshold > 1) return _utils.throwError.call(this, "threshold must be a number between 0 and 1");
        var diff = new Jimp(bmp1.width, bmp1.height, 0xffffffff), numDiffPixels = (0, _pixelmatch.default)(bmp1.data, bmp2.data, diff.bitmap.data, diff.bitmap.width, diff.bitmap.height, {
            threshold
        });
        return {
            percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),
            image: diff
        };
    }, Jimp.distance = function(img1, img2) {
        var phash = new _phash.default, hash1 = phash.getHash(img1), hash2 = phash.getHash(img2);
        return phash.distance(hash1, hash2);
    }, Jimp.compareHashes = function(hash1, hash2) {
        return (new _phash.default).distance(hash1, hash2);
    }, Jimp.colorDiff = function(rgba1, rgba2) {
        var pow = function pow(n) {
            return Math.pow(n, 2);
        }, max = Math.max;
        return 0 === rgba1.a || rgba1.a || (rgba1.a = 255), 0 === rgba2.a || rgba2.a || (rgba2.a = 255), 
        (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) + max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) + max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) / 195075;
    }, jimpEvMethod("clone", "clone", (function(cb) {
        var clone = new Jimp(this);
        return (0, _utils.isNodePattern)(cb) && cb.call(clone, null, clone), clone;
    })), jimpEvChange("background", (function(hex, cb) {
        return "number" != typeof hex ? _utils.throwError.call(this, "hex must be a hexadecimal rgba value", cb) : (this._background = hex, 
        (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
    })), jimpEvChange("scan", (function(x, y, w, h, f, cb) {
        if ("number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
        if ("number" != typeof w || "number" != typeof h) return _utils.throwError.call(this, "w and h must be numbers", cb);
        if ("function" != typeof f) return _utils.throwError.call(this, "f must be a function", cb);
        var result = (0, _utils.scan)(this, x, y, w, h, f);
        return (0, _utils.isNodePattern)(cb) && cb.call(this, null, result), result;
    })), "BROWSER" === process.env.ENVIRONMENT && ("undefined" != typeof window && "object" === ("undefined" == typeof window ? "undefined" : (0, 
    _typeof2.default)(window)) && (gl = window), "undefined" != typeof self && "object" === ("undefined" == typeof self ? "undefined" : (0, 
    _typeof2.default)(self)) && (gl = self), gl.Jimp = Jimp, gl.Buffer = Buffer);
    var _default = Jimp;
    exports.default = _default;
}(es$t), function(exports) {
    var _interopRequireWildcard = interopRequireWildcard.exports, _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = function configure(configuration) {
        var jimpInstance = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : _core.default, jimpConfig = {
            hasAlpha: {},
            encoders: {},
            decoders: {},
            class: {},
            constants: {}
        };
        function addToConfig(newConfig) {
            Object.entries(newConfig).forEach((function(_ref) {
                var _ref2 = (0, _slicedToArray2.default)(_ref, 2), key = _ref2[0], value = _ref2[1];
                jimpConfig[key] = _objectSpread({}, jimpConfig[key], {}, value);
            }));
        }
        function addImageType(typeModule) {
            var type = typeModule();
            Array.isArray(type.mime) ? _core.addType.apply(void 0, (0, _toConsumableArray2.default)(type.mime)) : Object.entries(type.mime).forEach((function(mimeType) {
                return _core.addType.apply(void 0, (0, _toConsumableArray2.default)(mimeType));
            })), delete type.mime, addToConfig(type);
        }
        function addPlugin(pluginModule) {
            var plugin = pluginModule(_core.jimpEvChange) || {};
            plugin.class || plugin.constants ? addToConfig(plugin) : addToConfig({
                class: plugin
            });
        }
        return configuration.types && (configuration.types.forEach(addImageType), jimpInstance.decoders = _objectSpread({}, jimpInstance.decoders, {}, jimpConfig.decoders), 
        jimpInstance.encoders = _objectSpread({}, jimpInstance.encoders, {}, jimpConfig.encoders), 
        jimpInstance.hasAlpha = _objectSpread({}, jimpInstance.hasAlpha, {}, jimpConfig.hasAlpha)), 
        configuration.plugins && configuration.plugins.forEach(addPlugin), (0, _core.addJimpMethods)(jimpConfig.class, jimpInstance), 
        (0, _core.addConstants)(jimpConfig.constants, jimpInstance), _core.default;
    };
    var _toConsumableArray2 = _interopRequireDefault(toConsumableArray.exports), _defineProperty2 = _interopRequireDefault(defineProperty.exports), _slicedToArray2 = _interopRequireDefault(slicedToArray.exports), _core = _interopRequireWildcard(es$t);
    function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter((function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            }))), keys.push.apply(keys, symbols);
        }
        return keys;
    }
    function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys(source, !0).forEach((function(key) {
                (0, _defineProperty2.default)(target, key, source[key]);
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(source).forEach((function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            }));
        }
        return target;
    }
}(es$u);

var es$r = {}, timm$1 = {};

Object.defineProperty(timm$1, "__esModule", {
    value: !0
}), timm$1.clone = clone, timm$1.addLast = addLast, timm$1.addFirst = addFirst, 
timm$1.removeLast = removeLast, timm$1.removeFirst = removeFirst, timm$1.insert = insert, 
timm$1.removeAt = removeAt, timm$1.replaceAt = replaceAt, timm$1.getIn = getIn, 
timm$1.set = set, timm$1.setIn = setIn, timm$1.update = update, timm$1.updateIn = updateIn, 
timm$1.merge = merge, timm$1.mergeDeep = mergeDeep, timm$1.mergeIn = mergeIn, timm$1.omit = omit, 
timm$1.addDefaults = addDefaults, timm$1.default = void 0;

/*!
 * Timm
 *
 * Immutability helpers with fast reads and acceptable writes.
 *
 * @copyright Guillermo Grau Panea 2016
 * @license MIT
 */
const IS_DEV = "production" !== process.env.NODE_ENV;

function throwStr(msg) {
    throw new Error(msg);
}

function getKeysAndSymbols(obj) {
    const keys = Object.keys(obj);
    return Object.getOwnPropertySymbols ? keys.concat(Object.getOwnPropertySymbols(obj)) : keys;
}

const hasOwnProperty$1 = {}.hasOwnProperty;

function clone(obj0) {
    if (Array.isArray(obj0)) return obj0.slice();
    const obj = obj0, keys = getKeysAndSymbols(obj), out = {};
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        out[key] = obj[key];
    }
    return out;
}

function isObject(o) {
    return null != o && "object" == typeof o;
}

function addLast(array, val) {
    return Array.isArray(val) ? array.concat(val) : array.concat([ val ]);
}

function addFirst(array, val) {
    return Array.isArray(val) ? val.concat(array) : [ val ].concat(array);
}

function removeLast(array) {
    return array.length ? array.slice(0, array.length - 1) : array;
}

function removeFirst(array) {
    return array.length ? array.slice(1) : array;
}

function insert(array, idx, val) {
    return array.slice(0, idx).concat(Array.isArray(val) ? val : [ val ]).concat(array.slice(idx));
}

function removeAt(array, idx) {
    return idx >= array.length || idx < 0 ? array : array.slice(0, idx).concat(array.slice(idx + 1));
}

function replaceAt(array, idx, newItem) {
    if (array[idx] === newItem) return array;
    const len = array.length, result = Array(len);
    for (let i = 0; i < len; i++) result[i] = array[i];
    return result[idx] = newItem, result;
}

function getIn(obj, path) {
    if (Array.isArray(path) || throwStr(IS_DEV ? "A path array should be provided when calling getIn()" : "INVALID_ARGS"), 
    null == obj) return;
    let ptr = obj;
    for (let i = 0; i < path.length; i++) {
        const key = path[i];
        if (ptr = null != ptr ? ptr[key] : void 0, void 0 === ptr) return ptr;
    }
    return ptr;
}

function set(obj0, key, val) {
    let obj = obj0;
    if (null == obj && (obj = "number" == typeof key ? [] : {}), obj[key] === val) return obj;
    const obj2 = clone(obj);
    return obj2[key] = val, obj2;
}

function setIn(obj, path, val) {
    return path.length ? doSetIn(obj, path, val, 0) : val;
}

function doSetIn(obj, path, val, idx) {
    let newValue;
    const key = path[idx];
    return newValue = idx === path.length - 1 ? val : doSetIn(isObject(obj) && isObject(obj[key]) ? obj[key] : "number" == typeof path[idx + 1] ? [] : {}, path, val, idx + 1), 
    set(obj, key, newValue);
}

function update(obj, key, fnUpdate) {
    return set(obj, key, fnUpdate(null == obj ? void 0 : obj[key]));
}

function updateIn(obj, path, fnUpdate) {
    return setIn(obj, path, fnUpdate(getIn(obj, path)));
}

function merge(a, b, c, d, e, f, ...rest) {
    return rest.length ? doMerge.call(null, !1, !1, a, b, c, d, e, f, ...rest) : doMerge(!1, !1, a, b, c, d, e, f);
}

function mergeDeep(a, b, c, d, e, f, ...rest) {
    return rest.length ? doMerge.call(null, !1, !0, a, b, c, d, e, f, ...rest) : doMerge(!1, !0, a, b, c, d, e, f);
}

function mergeIn(a, path, b, c, d, e, f, ...rest) {
    let nextVal, prevVal = getIn(a, path);
    return null == prevVal && (prevVal = {}), nextVal = rest.length ? doMerge.call(null, !1, !1, prevVal, b, c, d, e, f, ...rest) : doMerge(!1, !1, prevVal, b, c, d, e, f), 
    setIn(a, path, nextVal);
}

function omit(obj, attrs) {
    const omitList = Array.isArray(attrs) ? attrs : [ attrs ];
    let fDoSomething = !1;
    for (let i = 0; i < omitList.length; i++) if (hasOwnProperty$1.call(obj, omitList[i])) {
        fDoSomething = !0;
        break;
    }
    if (!fDoSomething) return obj;
    const out = {}, keys = getKeysAndSymbols(obj);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        omitList.indexOf(key) >= 0 || (out[key] = obj[key]);
    }
    return out;
}

function addDefaults(a, b, c, d, e, f, ...rest) {
    return rest.length ? doMerge.call(null, !0, !1, a, b, c, d, e, f, ...rest) : doMerge(!0, !1, a, b, c, d, e, f);
}

function doMerge(fAddDefaults, fDeep, first, ...rest) {
    let out = first;
    null == out && throwStr(IS_DEV ? "At least one object should be provided to merge()" : "INVALID_ARGS");
    let fChanged = !1;
    for (let idx = 0; idx < rest.length; idx++) {
        const obj = rest[idx];
        if (null == obj) continue;
        const keys = getKeysAndSymbols(obj);
        if (keys.length) for (let j = 0; j <= keys.length; j++) {
            const key = keys[j];
            if (fAddDefaults && void 0 !== out[key]) continue;
            let nextVal = obj[key];
            fDeep && isObject(out[key]) && isObject(nextVal) && (nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal)), 
            void 0 !== nextVal && nextVal !== out[key] && (fChanged || (fChanged = !0, out = clone(out)), 
            out[key] = nextVal);
        }
    }
    return out;
}

var _default = {
    clone,
    addLast,
    addFirst,
    removeLast,
    removeFirst,
    insert,
    removeAt,
    replaceAt,
    getIn,
    set,
    setIn,
    update,
    updateIn,
    merge,
    mergeDeep,
    mergeIn,
    omit,
    addDefaults
};

timm$1.default = _default;

var es$q = {}, encoder$1 = {
    exports: {}
};

!function(module) {
    function JPEGEncoder(quality) {
        var YDC_HT, UVDC_HT, YAC_HT, UVAC_HT, currentQuality, ffloor = Math.floor, YTable = new Array(64), UVTable = new Array(64), fdtbl_Y = new Array(64), fdtbl_UV = new Array(64), bitcode = new Array(65535), category = new Array(65535), outputfDCTQuant = new Array(64), DU = new Array(64), byteout = [], bytenew = 0, bytepos = 7, YDU = new Array(64), UDU = new Array(64), VDU = new Array(64), clt = new Array(256), RGB_YUV_TABLE = new Array(2048), ZigZag = [ 0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63 ], std_dc_luminance_nrcodes = [ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 ], std_dc_luminance_values = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ], std_ac_luminance_nrcodes = [ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d ], std_ac_luminance_values = [ 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa ], std_dc_chrominance_nrcodes = [ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 ], std_dc_chrominance_values = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ], std_ac_chrominance_nrcodes = [ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 ], std_ac_chrominance_values = [ 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa ];
        function computeHuffmanTbl(nrcodes, std_table) {
            for (var codevalue = 0, pos_in_table = 0, HT = new Array, k = 1; k <= 16; k++) {
                for (var j = 1; j <= nrcodes[k]; j++) HT[std_table[pos_in_table]] = [], HT[std_table[pos_in_table]][0] = codevalue, 
                HT[std_table[pos_in_table]][1] = k, pos_in_table++, codevalue++;
                codevalue *= 2;
            }
            return HT;
        }
        function writeBits(bs) {
            for (var value = bs[0], posval = bs[1] - 1; posval >= 0; ) value & 1 << posval && (bytenew |= 1 << bytepos), 
            posval--, --bytepos < 0 && (0xFF == bytenew ? (writeByte(0xFF), writeByte(0)) : writeByte(bytenew), 
            bytepos = 7, bytenew = 0);
        }
        function writeByte(value) {
            byteout.push(value);
        }
        function writeWord(value) {
            writeByte(value >> 8 & 0xFF), writeByte(0xFF & value);
        }
        function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
            for (var pos, EOB = HTAC[0x00], M16zeroes = HTAC[0xF0], DU_DCT = function fDCTQuant(data, fdtbl) {
                var d0, d1, d2, d3, d4, d5, d6, d7, i, fDCTQuant, dataOff = 0;
                for (i = 0; i < 8; ++i) {
                    d0 = data[dataOff], d1 = data[dataOff + 1], d2 = data[dataOff + 2], d3 = data[dataOff + 3], 
                    d4 = data[dataOff + 4], d5 = data[dataOff + 5], d6 = data[dataOff + 6];
                    var tmp0 = d0 + (d7 = data[dataOff + 7]), tmp7 = d0 - d7, tmp1 = d1 + d6, tmp6 = d1 - d6, tmp2 = d2 + d5, tmp5 = d2 - d5, tmp3 = d3 + d4, tmp4 = d3 - d4, tmp10 = tmp0 + tmp3, tmp13 = tmp0 - tmp3, tmp11 = tmp1 + tmp2, tmp12 = tmp1 - tmp2;
                    data[dataOff] = tmp10 + tmp11, data[dataOff + 4] = tmp10 - tmp11;
                    var z1 = 0.707106781 * (tmp12 + tmp13);
                    data[dataOff + 2] = tmp13 + z1, data[dataOff + 6] = tmp13 - z1;
                    var z5 = 0.382683433 * ((tmp10 = tmp4 + tmp5) - (tmp12 = tmp6 + tmp7)), z2 = 0.541196100 * tmp10 + z5, z4 = 1.306562965 * tmp12 + z5, z3 = 0.707106781 * (tmp11 = tmp5 + tmp6), z11 = tmp7 + z3, z13 = tmp7 - z3;
                    data[dataOff + 5] = z13 + z2, data[dataOff + 3] = z13 - z2, data[dataOff + 1] = z11 + z4, 
                    data[dataOff + 7] = z11 - z4, dataOff += 8;
                }
                for (dataOff = 0, i = 0; i < 8; ++i) {
                    d0 = data[dataOff], d1 = data[dataOff + 8], d2 = data[dataOff + 16], d3 = data[dataOff + 24], 
                    d4 = data[dataOff + 32], d5 = data[dataOff + 40], d6 = data[dataOff + 48];
                    var tmp0p2 = d0 + (d7 = data[dataOff + 56]), tmp7p2 = d0 - d7, tmp1p2 = d1 + d6, tmp6p2 = d1 - d6, tmp2p2 = d2 + d5, tmp5p2 = d2 - d5, tmp3p2 = d3 + d4, tmp4p2 = d3 - d4, tmp10p2 = tmp0p2 + tmp3p2, tmp13p2 = tmp0p2 - tmp3p2, tmp11p2 = tmp1p2 + tmp2p2, tmp12p2 = tmp1p2 - tmp2p2;
                    data[dataOff] = tmp10p2 + tmp11p2, data[dataOff + 32] = tmp10p2 - tmp11p2;
                    var z1p2 = 0.707106781 * (tmp12p2 + tmp13p2);
                    data[dataOff + 16] = tmp13p2 + z1p2, data[dataOff + 48] = tmp13p2 - z1p2;
                    var z5p2 = 0.382683433 * ((tmp10p2 = tmp4p2 + tmp5p2) - (tmp12p2 = tmp6p2 + tmp7p2)), z2p2 = 0.541196100 * tmp10p2 + z5p2, z4p2 = 1.306562965 * tmp12p2 + z5p2, z3p2 = 0.707106781 * (tmp11p2 = tmp5p2 + tmp6p2), z11p2 = tmp7p2 + z3p2, z13p2 = tmp7p2 - z3p2;
                    data[dataOff + 40] = z13p2 + z2p2, data[dataOff + 24] = z13p2 - z2p2, data[dataOff + 8] = z11p2 + z4p2, 
                    data[dataOff + 56] = z11p2 - z4p2, dataOff++;
                }
                for (i = 0; i < 64; ++i) fDCTQuant = data[i] * fdtbl[i], outputfDCTQuant[i] = fDCTQuant > 0.0 ? fDCTQuant + 0.5 | 0 : fDCTQuant - 0.5 | 0;
                return outputfDCTQuant;
            }(CDU, fdtbl), j = 0; j < 64; ++j) DU[ZigZag[j]] = DU_DCT[j];
            var Diff = DU[0] - DC;
            DC = DU[0], 0 == Diff ? writeBits(HTDC[0]) : (writeBits(HTDC[category[pos = 32767 + Diff]]), 
            writeBits(bitcode[pos]));
            for (var end0pos = 63; end0pos > 0 && 0 == DU[end0pos]; end0pos--) ;
            if (0 == end0pos) return writeBits(EOB), DC;
            for (var lng, i = 1; i <= end0pos; ) {
                for (var startpos = i; 0 == DU[i] && i <= end0pos; ++i) ;
                var nrzeroes = i - startpos;
                if (nrzeroes >= 16) {
                    lng = nrzeroes >> 4;
                    for (var nrmarker = 1; nrmarker <= lng; ++nrmarker) writeBits(M16zeroes);
                    nrzeroes &= 0xF;
                }
                pos = 32767 + DU[i], writeBits(HTAC[(nrzeroes << 4) + category[pos]]), writeBits(bitcode[pos]), 
                i++;
            }
            return 63 != end0pos && writeBits(EOB), DC;
        }
        function setQuality(quality) {
            quality <= 0 && (quality = 1), quality > 100 && (quality = 100), currentQuality != quality && (function initQuantTables(sf) {
                for (var YQT = [ 16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99 ], i = 0; i < 64; i++) {
                    var t = ffloor((YQT[i] * sf + 50) / 100);
                    t < 1 ? t = 1 : t > 255 && (t = 255), YTable[ZigZag[i]] = t;
                }
                for (var UVQT = [ 17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99 ], j = 0; j < 64; j++) {
                    var u = ffloor((UVQT[j] * sf + 50) / 100);
                    u < 1 ? u = 1 : u > 255 && (u = 255), UVTable[ZigZag[j]] = u;
                }
                for (var aasf = [ 1.0, 1.387039845, 1.306562965, 1.175875602, 1.0, 0.785694958, 0.541196100, 0.275899379 ], k = 0, row = 0; row < 8; row++) for (var col = 0; col < 8; col++) fdtbl_Y[k] = 1.0 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0), 
                fdtbl_UV[k] = 1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0), k++;
            }(quality < 50 ? Math.floor(5000 / quality) : Math.floor(200 - 2 * quality)), currentQuality = quality);
        }
        this.encode = function(image, quality) {
            (new Date).getTime(), quality && setQuality(quality), byteout = new Array, bytenew = 0, 
            bytepos = 7, writeWord(0xFFD8), function writeAPP0() {
                writeWord(0xFFE0), writeWord(16), writeByte(0x4A), writeByte(0x46), writeByte(0x49), 
                writeByte(0x46), writeByte(0), writeByte(1), writeByte(1), writeByte(0), writeWord(1), 
                writeWord(1), writeByte(0), writeByte(0);
            }(), function writeAPP1(exifBuffer) {
                if (exifBuffer) {
                    writeWord(0xFFE1), 0x45 === exifBuffer[0] && 0x78 === exifBuffer[1] && 0x69 === exifBuffer[2] && 0x66 === exifBuffer[3] ? writeWord(exifBuffer.length + 2) : (writeWord(exifBuffer.length + 5 + 2), 
                    writeByte(0x45), writeByte(0x78), writeByte(0x69), writeByte(0x66), writeByte(0));
                    for (var i = 0; i < exifBuffer.length; i++) writeByte(exifBuffer[i]);
                }
            }(image.exifBuffer), function writeDQT() {
                writeWord(0xFFDB), writeWord(132), writeByte(0);
                for (var i = 0; i < 64; i++) writeByte(YTable[i]);
                writeByte(1);
                for (var j = 0; j < 64; j++) writeByte(UVTable[j]);
            }(), function writeSOF0(width, height) {
                writeWord(0xFFC0), writeWord(17), writeByte(8), writeWord(height), writeWord(width), 
                writeByte(3), writeByte(1), writeByte(0x11), writeByte(0), writeByte(2), writeByte(0x11), 
                writeByte(1), writeByte(3), writeByte(0x11), writeByte(1);
            }(image.width, image.height), function writeDHT() {
                writeWord(0xFFC4), writeWord(0x01A2), writeByte(0);
                for (var i = 0; i < 16; i++) writeByte(std_dc_luminance_nrcodes[i + 1]);
                for (var j = 0; j <= 11; j++) writeByte(std_dc_luminance_values[j]);
                writeByte(0x10);
                for (var k = 0; k < 16; k++) writeByte(std_ac_luminance_nrcodes[k + 1]);
                for (var l = 0; l <= 161; l++) writeByte(std_ac_luminance_values[l]);
                writeByte(1);
                for (var m = 0; m < 16; m++) writeByte(std_dc_chrominance_nrcodes[m + 1]);
                for (var n = 0; n <= 11; n++) writeByte(std_dc_chrominance_values[n]);
                writeByte(0x11);
                for (var o = 0; o < 16; o++) writeByte(std_ac_chrominance_nrcodes[o + 1]);
                for (var p = 0; p <= 161; p++) writeByte(std_ac_chrominance_values[p]);
            }(), function writeSOS() {
                writeWord(0xFFDA), writeWord(12), writeByte(3), writeByte(1), writeByte(0), writeByte(2), 
                writeByte(0x11), writeByte(3), writeByte(0x11), writeByte(0), writeByte(0x3f), writeByte(0);
            }();
            var DCY = 0, DCU = 0, DCV = 0;
            bytenew = 0, bytepos = 7, this.encode.displayName = "_encode_";
            for (var x, r, g, b, start, p, col, row, pos, imageData = image.data, width = image.width, height = image.height, quadWidth = 4 * width, y = 0; y < height; ) {
                for (x = 0; x < quadWidth; ) {
                    for (p = start = quadWidth * y + x, col = -1, row = 0, pos = 0; pos < 64; pos++) p = start + (row = pos >> 3) * quadWidth + (col = 4 * (7 & pos)), 
                    y + row >= height && (p -= quadWidth * (y + 1 + row - height)), x + col >= quadWidth && (p -= x + col - quadWidth + 4), 
                    r = imageData[p++], g = imageData[p++], b = imageData[p++], YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128, 
                    UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128, 
                    VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
                    DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT), DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT), 
                    DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT), x += 32;
                }
                y += 8;
            }
            if (bytepos >= 0) {
                var fillbits = [];
                fillbits[1] = bytepos + 1, fillbits[0] = (1 << bytepos + 1) - 1, writeBits(fillbits);
            }
            return writeWord(0xFFD9), Buffer.from(byteout);
        }, function init() {
            (new Date).getTime(), quality || (quality = 50), function initCharLookupTable() {
                for (var sfcc = String.fromCharCode, i = 0; i < 256; i++) clt[i] = sfcc(i);
            }(), function initHuffmanTbl() {
                YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values), UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values), 
                YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values), UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
            }(), function initCategoryNumber() {
                for (var nrlower = 1, nrupper = 2, cat = 1; cat <= 15; cat++) {
                    for (var nr = nrlower; nr < nrupper; nr++) category[32767 + nr] = cat, bitcode[32767 + nr] = [], 
                    bitcode[32767 + nr][1] = cat, bitcode[32767 + nr][0] = nr;
                    for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) category[32767 + nrneg] = cat, 
                    bitcode[32767 + nrneg] = [], bitcode[32767 + nrneg][1] = cat, bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
                    nrlower <<= 1, nrupper <<= 1;
                }
            }(), function initRGBYUVTable() {
                for (var i = 0; i < 256; i++) RGB_YUV_TABLE[i] = 19595 * i, RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i, 
                RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 0x8000, RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i, 
                RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i, RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 0x807FFF, 
                RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i, RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
            }(), setQuality(quality), (new Date).getTime();
        }();
    }
    encoder$1.exports = function encode(imgData, qu) {
        return void 0 === qu && (qu = 50), {
            data: new JPEGEncoder(qu).encode(imgData, qu),
            width: imgData.width,
            height: imgData.height
        };
    };
}();

var decoder$1 = {
    exports: {}
};

!function(module) {
    var JpegImage = function jpegImage() {
        var dctZigZag = new Int32Array([ 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 ]);
        function constructor() {}
        function buildHuffmanTable(codeLengths, values) {
            for (var i, j, k = 0, code = [], length = 16; length > 0 && !codeLengths[length - 1]; ) length--;
            code.push({
                children: [],
                index: 0
            });
            var q, p = code[0];
            for (i = 0; i < length; i++) {
                for (j = 0; j < codeLengths[i]; j++) {
                    for ((p = code.pop()).children[p.index] = values[k]; p.index > 0; ) {
                        if (0 === code.length) throw new Error("Could not recreate Huffman Table");
                        p = code.pop();
                    }
                    for (p.index++, code.push(p); code.length <= i; ) code.push(q = {
                        children: [],
                        index: 0
                    }), p.children[p.index] = q.children, p = q;
                    k++;
                }
                i + 1 < length && (code.push(q = {
                    children: [],
                    index: 0
                }), p.children[p.index] = q.children, p = q);
            }
            return code[0].children;
        }
        function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
            frame.precision, frame.samplesPerLine, frame.scanLines;
            var mcusPerLine = frame.mcusPerLine, progressive = frame.progressive;
            frame.maxH, frame.maxV;
            var startOffset = offset, bitsData = 0, bitsCount = 0;
            function readBit() {
                if (bitsCount > 0) return bitsCount--, bitsData >> bitsCount & 1;
                if (0xFF == (bitsData = data[offset++])) {
                    var nextByte = data[offset++];
                    if (nextByte) throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
                }
                return bitsCount = 7, bitsData >>> 7;
            }
            function decodeHuffman(tree) {
                for (var bit, node = tree; null !== (bit = readBit()); ) {
                    if ("number" == typeof (node = node[bit])) return node;
                    if ("object" != typeof node) throw new Error("invalid huffman sequence");
                }
                return null;
            }
            function receive(length) {
                for (var n = 0; length > 0; ) {
                    var bit = readBit();
                    if (null === bit) return;
                    n = n << 1 | bit, length--;
                }
                return n;
            }
            function receiveAndExtend(length) {
                var n = receive(length);
                return n >= 1 << length - 1 ? n : n + (-1 << length) + 1;
            }
            var successiveACNextValue, eobrun = 0, successiveACState = 0;
            function decodeMcu(component, decode, mcu, row, col) {
                var mcuCol = mcu % mcusPerLine, blockRow = (mcu / mcusPerLine | 0) * component.v + row, blockCol = mcuCol * component.h + col;
                void 0 === component.blocks[blockRow] && opts.tolerantDecoding || decode(component, component.blocks[blockRow][blockCol]);
            }
            function decodeBlock(component, decode, mcu) {
                var blockRow = mcu / component.blocksPerLine | 0, blockCol = mcu % component.blocksPerLine;
                void 0 === component.blocks[blockRow] && opts.tolerantDecoding || decode(component, component.blocks[blockRow][blockCol]);
            }
            var component, i, j, k, n, decodeFn, componentsLength = components.length;
            decodeFn = progressive ? 0 === spectralStart ? 0 === successivePrev ? function decodeDCFirst(component, zz) {
                var t = decodeHuffman(component.huffmanTableDC), diff = 0 === t ? 0 : receiveAndExtend(t) << successive;
                zz[0] = component.pred += diff;
            } : function decodeDCSuccessive(component, zz) {
                zz[0] |= readBit() << successive;
            } : 0 === successivePrev ? function decodeACFirst(component, zz) {
                if (eobrun > 0) eobrun--; else for (var k = spectralStart, e = spectralEnd; k <= e; ) {
                    var rs = decodeHuffman(component.huffmanTableAC), s = 15 & rs, r = rs >> 4;
                    if (0 !== s) zz[dctZigZag[k += r]] = receiveAndExtend(s) * (1 << successive), k++; else {
                        if (r < 15) {
                            eobrun = receive(r) + (1 << r) - 1;
                            break;
                        }
                        k += 16;
                    }
                }
            } : function decodeACSuccessive(component, zz) {
                for (var k = spectralStart, e = spectralEnd, r = 0; k <= e; ) {
                    var z = dctZigZag[k], direction = zz[z] < 0 ? -1 : 1;
                    switch (successiveACState) {
                      case 0:
                        var rs = decodeHuffman(component.huffmanTableAC), s = 15 & rs;
                        if (r = rs >> 4, 0 === s) r < 15 ? (eobrun = receive(r) + (1 << r), successiveACState = 4) : (r = 16, 
                        successiveACState = 1); else {
                            if (1 !== s) throw new Error("invalid ACn encoding");
                            successiveACNextValue = receiveAndExtend(s), successiveACState = r ? 2 : 3;
                        }
                        continue;

                      case 1:
                      case 2:
                        zz[z] ? zz[z] += (readBit() << successive) * direction : 0 == --r && (successiveACState = 2 == successiveACState ? 3 : 0);
                        break;

                      case 3:
                        zz[z] ? zz[z] += (readBit() << successive) * direction : (zz[z] = successiveACNextValue << successive, 
                        successiveACState = 0);
                        break;

                      case 4:
                        zz[z] && (zz[z] += (readBit() << successive) * direction);
                    }
                    k++;
                }
                4 === successiveACState && 0 == --eobrun && (successiveACState = 0);
            } : function decodeBaseline(component, zz) {
                var t = decodeHuffman(component.huffmanTableDC), diff = 0 === t ? 0 : receiveAndExtend(t);
                zz[0] = component.pred += diff;
                for (var k = 1; k < 64; ) {
                    var rs = decodeHuffman(component.huffmanTableAC), s = 15 & rs, r = rs >> 4;
                    if (0 !== s) zz[dctZigZag[k += r]] = receiveAndExtend(s), k++; else {
                        if (r < 15) break;
                        k += 16;
                    }
                }
            };
            var marker, mcuExpected, h, v, mcu = 0;
            for (mcuExpected = 1 == componentsLength ? components[0].blocksPerLine * components[0].blocksPerColumn : mcusPerLine * frame.mcusPerColumn, 
            resetInterval || (resetInterval = mcuExpected); mcu < mcuExpected; ) {
                for (i = 0; i < componentsLength; i++) components[i].pred = 0;
                if (eobrun = 0, 1 == componentsLength) for (component = components[0], n = 0; n < resetInterval; n++) decodeBlock(component, decodeFn, mcu), 
                mcu++; else for (n = 0; n < resetInterval; n++) {
                    for (i = 0; i < componentsLength; i++) for (h = (component = components[i]).h, v = component.v, 
                    j = 0; j < v; j++) for (k = 0; k < h; k++) decodeMcu(component, decodeFn, mcu, j, k);
                    if (++mcu === mcuExpected) break;
                }
                if (mcu === mcuExpected) do {
                    if (0xFF === data[offset] && 0x00 !== data[offset + 1]) break;
                    offset += 1;
                } while (offset < data.length - 2);
                if (bitsCount = 0, (marker = data[offset] << 8 | data[offset + 1]) < 0xFF00) throw new Error("marker was not found");
                if (!(marker >= 0xFFD0 && marker <= 0xFFD7)) break;
                offset += 2;
            }
            return offset - startOffset;
        }
        function buildComponentData(frame, component) {
            var i, j, lines = [], blocksPerLine = component.blocksPerLine, blocksPerColumn = component.blocksPerColumn, samplesPerLine = blocksPerLine << 3, R = new Int32Array(64), r = new Uint8Array(64);
            function quantizeAndInverse(zz, dataOut, dataIn) {
                var v0, v1, v2, v3, v4, v5, v6, v7, t, i, qt = component.quantizationTable, p = dataIn;
                for (i = 0; i < 64; i++) p[i] = zz[i] * qt[i];
                for (i = 0; i < 8; ++i) {
                    var row = 8 * i;
                    0 != p[1 + row] || 0 != p[2 + row] || 0 != p[3 + row] || 0 != p[4 + row] || 0 != p[5 + row] || 0 != p[6 + row] || 0 != p[7 + row] ? (v0 = 5793 * p[0 + row] + 128 >> 8, 
                    v1 = 5793 * p[4 + row] + 128 >> 8, v2 = p[2 + row], v3 = p[6 + row], v4 = 2896 * (p[1 + row] - p[7 + row]) + 128 >> 8, 
                    v7 = 2896 * (p[1 + row] + p[7 + row]) + 128 >> 8, v5 = p[3 + row] << 4, t = v0 - v1 + 1 >> 1, 
                    v0 = v0 + v1 + 1 >> 1, v1 = t, t = 3784 * v2 + 1567 * v3 + 128 >> 8, v2 = 1567 * v2 - 3784 * v3 + 128 >> 8, 
                    v3 = t, t = v4 - (v6 = p[5 + row] << 4) + 1 >> 1, v4 = v4 + v6 + 1 >> 1, v6 = t, 
                    t = v7 + v5 + 1 >> 1, v5 = v7 - v5 + 1 >> 1, v7 = t, t = v0 - v3 + 1 >> 1, v0 = v0 + v3 + 1 >> 1, 
                    v3 = t, t = v1 - v2 + 1 >> 1, v1 = v1 + v2 + 1 >> 1, v2 = t, t = 2276 * v4 + 3406 * v7 + 2048 >> 12, 
                    v4 = 3406 * v4 - 2276 * v7 + 2048 >> 12, v7 = t, t = 799 * v5 + 4017 * v6 + 2048 >> 12, 
                    v5 = 4017 * v5 - 799 * v6 + 2048 >> 12, v6 = t, p[0 + row] = v0 + v7, p[7 + row] = v0 - v7, 
                    p[1 + row] = v1 + v6, p[6 + row] = v1 - v6, p[2 + row] = v2 + v5, p[5 + row] = v2 - v5, 
                    p[3 + row] = v3 + v4, p[4 + row] = v3 - v4) : (t = 5793 * p[0 + row] + 512 >> 10, 
                    p[0 + row] = t, p[1 + row] = t, p[2 + row] = t, p[3 + row] = t, p[4 + row] = t, 
                    p[5 + row] = t, p[6 + row] = t, p[7 + row] = t);
                }
                for (i = 0; i < 8; ++i) {
                    var col = i;
                    0 != p[8 + col] || 0 != p[16 + col] || 0 != p[24 + col] || 0 != p[32 + col] || 0 != p[40 + col] || 0 != p[48 + col] || 0 != p[56 + col] ? (v0 = 5793 * p[0 + col] + 2048 >> 12, 
                    v1 = 5793 * p[32 + col] + 2048 >> 12, v2 = p[16 + col], v3 = p[48 + col], v4 = 2896 * (p[8 + col] - p[56 + col]) + 2048 >> 12, 
                    v7 = 2896 * (p[8 + col] + p[56 + col]) + 2048 >> 12, v5 = p[24 + col], t = v0 - v1 + 1 >> 1, 
                    v0 = v0 + v1 + 1 >> 1, v1 = t, t = 3784 * v2 + 1567 * v3 + 2048 >> 12, v2 = 1567 * v2 - 3784 * v3 + 2048 >> 12, 
                    v3 = t, t = v4 - (v6 = p[40 + col]) + 1 >> 1, v4 = v4 + v6 + 1 >> 1, v6 = t, t = v7 + v5 + 1 >> 1, 
                    v5 = v7 - v5 + 1 >> 1, v7 = t, t = v0 - v3 + 1 >> 1, v0 = v0 + v3 + 1 >> 1, v3 = t, 
                    t = v1 - v2 + 1 >> 1, v1 = v1 + v2 + 1 >> 1, v2 = t, t = 2276 * v4 + 3406 * v7 + 2048 >> 12, 
                    v4 = 3406 * v4 - 2276 * v7 + 2048 >> 12, v7 = t, t = 799 * v5 + 4017 * v6 + 2048 >> 12, 
                    v5 = 4017 * v5 - 799 * v6 + 2048 >> 12, v6 = t, p[0 + col] = v0 + v7, p[56 + col] = v0 - v7, 
                    p[8 + col] = v1 + v6, p[48 + col] = v1 - v6, p[16 + col] = v2 + v5, p[40 + col] = v2 - v5, 
                    p[24 + col] = v3 + v4, p[32 + col] = v3 - v4) : (t = 5793 * dataIn[i + 0] + 8192 >> 14, 
                    p[0 + col] = t, p[8 + col] = t, p[16 + col] = t, p[24 + col] = t, p[32 + col] = t, 
                    p[40 + col] = t, p[48 + col] = t, p[56 + col] = t);
                }
                for (i = 0; i < 64; ++i) {
                    var sample = 128 + (p[i] + 8 >> 4);
                    dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;
                }
            }
            requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
            for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
                var scanLine = blockRow << 3;
                for (i = 0; i < 8; i++) lines.push(new Uint8Array(samplesPerLine));
                for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
                    quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
                    var offset = 0, sample = blockCol << 3;
                    for (j = 0; j < 8; j++) {
                        var line = lines[scanLine + j];
                        for (i = 0; i < 8; i++) line[sample + i] = r[offset++];
                    }
                }
            }
            return lines;
        }
        function clampTo8bit(a) {
            return a < 0 ? 0 : a > 255 ? 255 : a;
        }
        constructor.prototype = {
            load: function load(path) {
                var xhr = new XMLHttpRequest;
                xhr.open("GET", path, !0), xhr.responseType = "arraybuffer", xhr.onload = function() {
                    var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
                    this.parse(data), this.onload && this.onload();
                }.bind(this), xhr.send(null);
            },
            parse: function parse(data) {
                var maxResolutionInPixels = 1000 * this.opts.maxResolutionInMP * 1000, offset = 0;
                function readUint16() {
                    var value = data[offset] << 8 | data[offset + 1];
                    return offset += 2, value;
                }
                function prepareComponents(frame) {
                    var component, componentId, maxH = 0, maxV = 0;
                    for (componentId in frame.components) frame.components.hasOwnProperty(componentId) && (maxH < (component = frame.components[componentId]).h && (maxH = component.h), 
                    maxV < component.v && (maxV = component.v));
                    var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH), mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
                    for (componentId in frame.components) if (frame.components.hasOwnProperty(componentId)) {
                        component = frame.components[componentId];
                        var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH), blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV), blocksPerLineForMcu = mcusPerLine * component.h, blocksPerColumnForMcu = mcusPerColumn * component.v, blocks = [];
                        requestMemoryAllocation(blocksPerColumnForMcu * blocksPerLineForMcu * 256);
                        for (var i = 0; i < blocksPerColumnForMcu; i++) {
                            for (var row = [], j = 0; j < blocksPerLineForMcu; j++) row.push(new Int32Array(64));
                            blocks.push(row);
                        }
                        component.blocksPerLine = blocksPerLine, component.blocksPerColumn = blocksPerColumn, 
                        component.blocks = blocks;
                    }
                    frame.maxH = maxH, frame.maxV = maxV, frame.mcusPerLine = mcusPerLine, frame.mcusPerColumn = mcusPerColumn;
                }
                data.length;
                var frame, resetInterval, length, array, jfif = null, adobe = null, quantizationTables = [], frames = [], huffmanTablesAC = [], huffmanTablesDC = [], fileMarker = readUint16();
                if (this.comments = [], 0xFFD8 != fileMarker) throw new Error("SOI not found");
                for (fileMarker = readUint16(); 0xFFD9 != fileMarker; ) {
                    switch (fileMarker) {
                      case 0xFF00:
                        break;

                      case 0xFFE0:
                      case 0xFFE1:
                      case 0xFFE2:
                      case 0xFFE3:
                      case 0xFFE4:
                      case 0xFFE5:
                      case 0xFFE6:
                      case 0xFFE7:
                      case 0xFFE8:
                      case 0xFFE9:
                      case 0xFFEA:
                      case 0xFFEB:
                      case 0xFFEC:
                      case 0xFFED:
                      case 0xFFEE:
                      case 0xFFEF:
                      case 0xFFFE:
                        var appData = (length = readUint16(), array = data.subarray(offset, offset + length - 2), 
                        offset += array.length, array);
                        if (0xFFFE === fileMarker) {
                            var comment = String.fromCharCode.apply(null, appData);
                            this.comments.push(comment);
                        }
                        0xFFE0 === fileMarker && 0x4A === appData[0] && 0x46 === appData[1] && 0x49 === appData[2] && 0x46 === appData[3] && 0 === appData[4] && (jfif = {
                            version: {
                                major: appData[5],
                                minor: appData[6]
                            },
                            densityUnits: appData[7],
                            xDensity: appData[8] << 8 | appData[9],
                            yDensity: appData[10] << 8 | appData[11],
                            thumbWidth: appData[12],
                            thumbHeight: appData[13],
                            thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                        }), 0xFFE1 === fileMarker && 0x45 === appData[0] && 0x78 === appData[1] && 0x69 === appData[2] && 0x66 === appData[3] && 0 === appData[4] && (this.exifBuffer = appData.subarray(5, appData.length)), 
                        0xFFEE === fileMarker && 0x41 === appData[0] && 0x64 === appData[1] && 0x6F === appData[2] && 0x62 === appData[3] && 0x65 === appData[4] && 0 === appData[5] && (adobe = {
                            version: appData[6],
                            flags0: appData[7] << 8 | appData[8],
                            flags1: appData[9] << 8 | appData[10],
                            transformCode: appData[11]
                        });
                        break;

                      case 0xFFDB:
                        for (var quantizationTablesEnd = readUint16() + offset - 2; offset < quantizationTablesEnd; ) {
                            var quantizationTableSpec = data[offset++];
                            requestMemoryAllocation(256);
                            var tableData = new Int32Array(64);
                            if (quantizationTableSpec >> 4 == 0) for (j = 0; j < 64; j++) tableData[dctZigZag[j]] = data[offset++]; else {
                                if (quantizationTableSpec >> 4 != 1) throw new Error("DQT: invalid table spec");
                                for (j = 0; j < 64; j++) tableData[dctZigZag[j]] = readUint16();
                            }
                            quantizationTables[15 & quantizationTableSpec] = tableData;
                        }
                        break;

                      case 0xFFC0:
                      case 0xFFC1:
                      case 0xFFC2:
                        readUint16(), (frame = {}).extended = 0xFFC1 === fileMarker, frame.progressive = 0xFFC2 === fileMarker, 
                        frame.precision = data[offset++], frame.scanLines = readUint16(), frame.samplesPerLine = readUint16(), 
                        frame.components = {}, frame.componentsOrder = [];
                        var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                        if (pixelsInFrame > maxResolutionInPixels) {
                            var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                            throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                        }
                        var componentId, componentsCount = data[offset++];
                        for (i = 0; i < componentsCount; i++) {
                            componentId = data[offset];
                            var h = data[offset + 1] >> 4, v = 15 & data[offset + 1], qId = data[offset + 2];
                            frame.componentsOrder.push(componentId), frame.components[componentId] = {
                                h,
                                v,
                                quantizationIdx: qId
                            }, offset += 3;
                        }
                        prepareComponents(frame), frames.push(frame);
                        break;

                      case 0xFFC4:
                        var huffmanLength = readUint16();
                        for (i = 2; i < huffmanLength; ) {
                            var huffmanTableSpec = data[offset++], codeLengths = new Uint8Array(16), codeLengthSum = 0;
                            for (j = 0; j < 16; j++, offset++) codeLengthSum += codeLengths[j] = data[offset];
                            requestMemoryAllocation(16 + codeLengthSum);
                            var huffmanValues = new Uint8Array(codeLengthSum);
                            for (j = 0; j < codeLengthSum; j++, offset++) huffmanValues[j] = data[offset];
                            i += 17 + codeLengthSum, (huffmanTableSpec >> 4 == 0 ? huffmanTablesDC : huffmanTablesAC)[15 & huffmanTableSpec] = buildHuffmanTable(codeLengths, huffmanValues);
                        }
                        break;

                      case 0xFFDD:
                        readUint16(), resetInterval = readUint16();
                        break;

                      case 0xFFDC:
                        readUint16(), readUint16();
                        break;

                      case 0xFFDA:
                        readUint16();
                        var selectorsCount = data[offset++], components = [];
                        for (i = 0; i < selectorsCount; i++) {
                            component = frame.components[data[offset++]];
                            var tableSpec = data[offset++];
                            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4], component.huffmanTableAC = huffmanTablesAC[15 & tableSpec], 
                            components.push(component);
                        }
                        var spectralStart = data[offset++], spectralEnd = data[offset++], successiveApproximation = data[offset++], processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, 15 & successiveApproximation, this.opts);
                        offset += processed;
                        break;

                      case 0xFFFF:
                        0xFF !== data[offset] && offset--;
                        break;

                      default:
                        if (0xFF == data[offset - 3] && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
                            offset -= 3;
                            break;
                        }
                        throw new Error("unknown JPEG marker " + fileMarker.toString(16));
                    }
                    fileMarker = readUint16();
                }
                if (1 != frames.length) throw new Error("only single frame JPEGs supported");
                for (var i = 0; i < frames.length; i++) {
                    var cp = frames[i].components;
                    for (var j in cp) cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx], 
                    delete cp[j].quantizationIdx;
                }
                for (this.width = frame.samplesPerLine, this.height = frame.scanLines, this.jfif = jfif, 
                this.adobe = adobe, this.components = [], i = 0; i < frame.componentsOrder.length; i++) {
                    var component = frame.components[frame.componentsOrder[i]];
                    this.components.push({
                        lines: buildComponentData(0, component),
                        scaleX: component.h / frame.maxH,
                        scaleY: component.v / frame.maxV
                    });
                }
            },
            getData: function getData(width, height) {
                var component1, component2, component3, component4, component1Line, component2Line, component3Line, component4Line, x, y, Y, Cb, Cr, K, C, M, Ye, R, G, B, colorTransform, scaleX = this.width / width, scaleY = this.height / height, offset = 0, dataLength = width * height * this.components.length;
                requestMemoryAllocation(dataLength);
                var data = new Uint8Array(dataLength);
                switch (this.components.length) {
                  case 1:
                    for (component1 = this.components[0], y = 0; y < height; y++) for (component1Line = component1.lines[0 | y * component1.scaleY * scaleY], 
                    x = 0; x < width; x++) Y = component1Line[0 | x * component1.scaleX * scaleX], data[offset++] = Y;
                    break;

                  case 2:
                    for (component1 = this.components[0], component2 = this.components[1], y = 0; y < height; y++) for (component1Line = component1.lines[0 | y * component1.scaleY * scaleY], 
                    component2Line = component2.lines[0 | y * component2.scaleY * scaleY], x = 0; x < width; x++) Y = component1Line[0 | x * component1.scaleX * scaleX], 
                    data[offset++] = Y, Y = component2Line[0 | x * component2.scaleX * scaleX], data[offset++] = Y;
                    break;

                  case 3:
                    for (colorTransform = !0, this.adobe && this.adobe.transformCode ? colorTransform = !0 : void 0 !== this.opts.colorTransform && (colorTransform = !!this.opts.colorTransform), 
                    component1 = this.components[0], component2 = this.components[1], component3 = this.components[2], 
                    y = 0; y < height; y++) for (component1Line = component1.lines[0 | y * component1.scaleY * scaleY], 
                    component2Line = component2.lines[0 | y * component2.scaleY * scaleY], component3Line = component3.lines[0 | y * component3.scaleY * scaleY], 
                    x = 0; x < width; x++) colorTransform ? (Y = component1Line[0 | x * component1.scaleX * scaleX], 
                    Cb = component2Line[0 | x * component2.scaleX * scaleX], R = clampTo8bit(Y + 1.402 * ((Cr = component3Line[0 | x * component3.scaleX * scaleX]) - 128)), 
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128)), B = clampTo8bit(Y + 1.772 * (Cb - 128))) : (R = component1Line[0 | x * component1.scaleX * scaleX], 
                    G = component2Line[0 | x * component2.scaleX * scaleX], B = component3Line[0 | x * component3.scaleX * scaleX]), 
                    data[offset++] = R, data[offset++] = G, data[offset++] = B;
                    break;

                  case 4:
                    if (!this.adobe) throw new Error("Unsupported color mode (4 components)");
                    for (colorTransform = !1, this.adobe && this.adobe.transformCode ? colorTransform = !0 : void 0 !== this.opts.colorTransform && (colorTransform = !!this.opts.colorTransform), 
                    component1 = this.components[0], component2 = this.components[1], component3 = this.components[2], 
                    component4 = this.components[3], y = 0; y < height; y++) for (component1Line = component1.lines[0 | y * component1.scaleY * scaleY], 
                    component2Line = component2.lines[0 | y * component2.scaleY * scaleY], component3Line = component3.lines[0 | y * component3.scaleY * scaleY], 
                    component4Line = component4.lines[0 | y * component4.scaleY * scaleY], x = 0; x < width; x++) colorTransform ? (Y = component1Line[0 | x * component1.scaleX * scaleX], 
                    Cb = component2Line[0 | x * component2.scaleX * scaleX], Cr = component3Line[0 | x * component3.scaleX * scaleX], 
                    K = component4Line[0 | x * component4.scaleX * scaleX], C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128)), 
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128)), Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128))) : (C = component1Line[0 | x * component1.scaleX * scaleX], 
                    M = component2Line[0 | x * component2.scaleX * scaleX], Ye = component3Line[0 | x * component3.scaleX * scaleX], 
                    K = component4Line[0 | x * component4.scaleX * scaleX]), data[offset++] = 255 - C, 
                    data[offset++] = 255 - M, data[offset++] = 255 - Ye, data[offset++] = 255 - K;
                    break;

                  default:
                    throw new Error("Unsupported color mode");
                }
                return data;
            },
            copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
                var x, y, Y, K, C, M, R, G, B, width = imageData.width, height = imageData.height, imageDataArray = imageData.data, data = this.getData(width, height), i = 0, j = 0;
                switch (this.components.length) {
                  case 1:
                    for (y = 0; y < height; y++) for (x = 0; x < width; x++) Y = data[i++], imageDataArray[j++] = Y, 
                    imageDataArray[j++] = Y, imageDataArray[j++] = Y, formatAsRGBA && (imageDataArray[j++] = 255);
                    break;

                  case 3:
                    for (y = 0; y < height; y++) for (x = 0; x < width; x++) R = data[i++], G = data[i++], 
                    B = data[i++], imageDataArray[j++] = R, imageDataArray[j++] = G, imageDataArray[j++] = B, 
                    formatAsRGBA && (imageDataArray[j++] = 255);
                    break;

                  case 4:
                    for (y = 0; y < height; y++) for (x = 0; x < width; x++) C = data[i++], M = data[i++], 
                    Y = data[i++], R = 255 - clampTo8bit(C * (1 - (K = data[i++]) / 255) + K), G = 255 - clampTo8bit(M * (1 - K / 255) + K), 
                    B = 255 - clampTo8bit(Y * (1 - K / 255) + K), imageDataArray[j++] = R, imageDataArray[j++] = G, 
                    imageDataArray[j++] = B, formatAsRGBA && (imageDataArray[j++] = 255);
                    break;

                  default:
                    throw new Error("Unsupported color mode");
                }
            }
        };
        var totalBytesAllocated = 0, maxMemoryUsageBytes = 0;
        function requestMemoryAllocation(increaseAmount = 0) {
            var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
            if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
                var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
                throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
            }
            totalBytesAllocated = totalMemoryImpactBytes;
        }
        return constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
            totalBytesAllocated = 0, maxMemoryUsageBytes = maxMemoryUsageBytes_;
        }, constructor.getBytesAllocated = function() {
            return totalBytesAllocated;
        }, constructor.requestMemoryAllocation = requestMemoryAllocation, constructor;
    }();
    module.exports = function decode(jpegData, userOpts = {}) {
        var opts = {
            colorTransform: void 0,
            useTArray: !1,
            formatAsRGBA: !0,
            tolerantDecoding: !0,
            maxResolutionInMP: 100,
            maxMemoryUsageInMB: 512,
            ...userOpts
        }, arr = new Uint8Array(jpegData), decoder = new JpegImage;
        decoder.opts = opts, JpegImage.resetMaxMemoryUsage(1024 * opts.maxMemoryUsageInMB * 1024), 
        decoder.parse(arr);
        var channels = opts.formatAsRGBA ? 4 : 3, bytesNeeded = decoder.width * decoder.height * channels;
        try {
            JpegImage.requestMemoryAllocation(bytesNeeded);
            var image = {
                width: decoder.width,
                height: decoder.height,
                exifBuffer: decoder.exifBuffer,
                data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
            };
            decoder.comments.length > 0 && (image.comments = decoder.comments);
        } catch (err) {
            throw err instanceof RangeError ? new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded) : err;
        }
        return decoder.copyToImageData(image, opts.formatAsRGBA), image;
    };
}(decoder$1);

var jpegJs = {
    encode: encoder$1.exports,
    decode: decoder$1.exports
};

!function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _defineProperty2 = _interopRequireDefault(defineProperty.exports), _jpegJs = _interopRequireDefault(jpegJs), _utils = es$s;
    exports.default = function _default() {
        return {
            mime: (0, _defineProperty2.default)({}, "image/jpeg", [ "jpeg", "jpg", "jpe" ]),
            constants: {
                MIME_JPEG: "image/jpeg"
            },
            decoders: (0, _defineProperty2.default)({}, "image/jpeg", _jpegJs.default.decode),
            encoders: (0, _defineProperty2.default)({}, "image/jpeg", (function(image) {
                return _jpegJs.default.encode(image.bitmap, image._quality).data;
            })),
            class: {
                _quality: 100,
                quality: function quality(n, cb) {
                    return "number" != typeof n ? _utils.throwError.call(this, "n must be a number", cb) : n < 0 || n > 100 ? _utils.throwError.call(this, "n must be a number 0 - 100", cb) : (this._quality = Math.round(n), 
                    (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                }
            }
        };
    };
}(es$q);

var es$p = {}, png = {}, parserAsync = {
    exports: {}
}, chunkstream = {
    exports: {}
}, util$4 = require$$0__default$1.default, Stream$2 = require$$1__default$1.default, ChunkStream$2 = chunkstream.exports = function() {
    Stream$2.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = !1, 
    this._encoding = "utf8", this.writable = !0;
};

util$4.inherits(ChunkStream$2, Stream$2), ChunkStream$2.prototype.read = function(length, callback) {
    this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
    }), process.nextTick(function() {
        this._process(), this._paused && this._reads.length > 0 && (this._paused = !1, this.emit("drain"));
    }.bind(this));
}, ChunkStream$2.prototype.write = function(data, encoding) {
    return this.writable ? (dataBuffer = Buffer.isBuffer(data) ? data : new Buffer(data, encoding || this._encoding), 
    this._buffers.push(dataBuffer), this._buffered += dataBuffer.length, this._process(), 
    this._reads && 0 === this._reads.length && (this._paused = !0), this.writable && !this._paused) : (this.emit("error", new Error("Stream not writable")), 
    !1);
    var dataBuffer;
}, ChunkStream$2.prototype.end = function(data, encoding) {
    data && this.write(data, encoding), this.writable = !1, this._buffers && (0 === this._buffers.length ? this._end() : (this._buffers.push(null), 
    this._process()));
}, ChunkStream$2.prototype.destroySoon = ChunkStream$2.prototype.end, ChunkStream$2.prototype._end = function() {
    this._reads.length > 0 && this.emit("error", new Error("Unexpected end of input")), 
    this.destroy();
}, ChunkStream$2.prototype.destroy = function() {
    this._buffers && (this.writable = !1, this._reads = null, this._buffers = null, 
    this.emit("close"));
}, ChunkStream$2.prototype._processReadAllowingLess = function(read) {
    this._reads.shift();
    var smallerBuf = this._buffers[0];
    smallerBuf.length > read.length ? (this._buffered -= read.length, this._buffers[0] = smallerBuf.slice(read.length), 
    read.func.call(this, smallerBuf.slice(0, read.length))) : (this._buffered -= smallerBuf.length, 
    this._buffers.shift(), read.func.call(this, smallerBuf));
}, ChunkStream$2.prototype._processRead = function(read) {
    this._reads.shift();
    for (var pos = 0, count = 0, data = new Buffer(read.length); pos < read.length; ) {
        var buf = this._buffers[count++], len = Math.min(buf.length, read.length - pos);
        buf.copy(data, pos, 0, len), pos += len, len !== buf.length && (this._buffers[--count] = buf.slice(len));
    }
    count > 0 && this._buffers.splice(0, count), this._buffered -= read.length, read.func.call(this, data);
}, ChunkStream$2.prototype._process = function() {
    try {
        for (;this._buffered > 0 && this._reads && this._reads.length > 0; ) {
            var read = this._reads[0];
            if (read.allowLess) this._processReadAllowingLess(read); else {
                if (!(this._buffered >= read.length)) break;
                this._processRead(read);
            }
        }
        this._buffers && !this.writable && this._end();
    } catch (ex) {
        this.emit("error", ex);
    }
};

var filterParseAsync = {
    exports: {}
}, filterParse = {
    exports: {}
}, interlace = {}, imagePasses = [ {
    x: [ 0 ],
    y: [ 0 ]
}, {
    x: [ 4 ],
    y: [ 0 ]
}, {
    x: [ 0, 4 ],
    y: [ 4 ]
}, {
    x: [ 2, 6 ],
    y: [ 0, 4 ]
}, {
    x: [ 0, 2, 4, 6 ],
    y: [ 2, 6 ]
}, {
    x: [ 1, 3, 5, 7 ],
    y: [ 0, 2, 4, 6 ]
}, {
    x: [ 0, 1, 2, 3, 4, 5, 6, 7 ],
    y: [ 1, 3, 5, 7 ]
} ];

interlace.getImagePasses = function(width, height) {
    for (var images = [], xLeftOver = width % 8, yLeftOver = height % 8, xRepeats = (width - xLeftOver) / 8, yRepeats = (height - yLeftOver) / 8, i = 0; i < imagePasses.length; i++) {
        for (var pass = imagePasses[i], passWidth = xRepeats * pass.x.length, passHeight = yRepeats * pass.y.length, j = 0; j < pass.x.length && pass.x[j] < xLeftOver; j++) passWidth++;
        for (j = 0; j < pass.y.length && pass.y[j] < yLeftOver; j++) passHeight++;
        passWidth > 0 && passHeight > 0 && images.push({
            width: passWidth,
            height: passHeight,
            index: i
        });
    }
    return images;
}, interlace.getInterlaceIterator = function(width) {
    return function(x, y, pass) {
        var outerXLeftOver = x % imagePasses[pass].x.length, outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver], outerYLeftOver = y % imagePasses[pass].y.length;
        return 4 * outerX + ((y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver]) * width * 4;
    };
};

var paethPredictor$2 = function paethPredictor(left, above, upLeft) {
    var paeth = left + above - upLeft, pLeft = Math.abs(paeth - left), pAbove = Math.abs(paeth - above), pUpLeft = Math.abs(paeth - upLeft);
    return pLeft <= pAbove && pLeft <= pUpLeft ? left : pAbove <= pUpLeft ? above : upLeft;
}, interlaceUtils$1 = interlace, paethPredictor$1 = paethPredictor$2;

function getByteWidth(width, bpp, depth) {
    var byteWidth = width * bpp;
    return 8 !== depth && (byteWidth = Math.ceil(byteWidth / (8 / depth))), byteWidth;
}

var Filter$2 = filterParse.exports = function(bitmapInfo, dependencies) {
    var width = bitmapInfo.width, height = bitmapInfo.height, interlace = bitmapInfo.interlace, bpp = bitmapInfo.bpp, depth = bitmapInfo.depth;
    if (this.read = dependencies.read, this.write = dependencies.write, this.complete = dependencies.complete, 
    this._imageIndex = 0, this._images = [], interlace) for (var passes = interlaceUtils$1.getImagePasses(width, height), i = 0; i < passes.length; i++) this._images.push({
        byteWidth: getByteWidth(passes[i].width, bpp, depth),
        height: passes[i].height,
        lineIndex: 0
    }); else this._images.push({
        byteWidth: getByteWidth(width, bpp, depth),
        height,
        lineIndex: 0
    });
    this._xComparison = 8 === depth ? bpp : 16 === depth ? 2 * bpp : 1;
};

Filter$2.prototype.start = function() {
    this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
}, Filter$2.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
    for (var xComparison = this._xComparison, xBiggerThan = xComparison - 1, x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x], f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        unfilteredLine[x] = rawByte + f1Left;
    }
}, Filter$2.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
    for (var lastLine = this._lastLine, x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x], f2Up = lastLine ? lastLine[x] : 0;
        unfilteredLine[x] = rawByte + f2Up;
    }
}, Filter$2.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
    for (var xComparison = this._xComparison, xBiggerThan = xComparison - 1, lastLine = this._lastLine, x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x], f3Up = lastLine ? lastLine[x] : 0, f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0, f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x] = rawByte + f3Add;
    }
}, Filter$2.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
    for (var xComparison = this._xComparison, xBiggerThan = xComparison - 1, lastLine = this._lastLine, x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x], f4Up = lastLine ? lastLine[x] : 0, f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0, f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0, f4Add = paethPredictor$1(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x] = rawByte + f4Add;
    }
}, Filter$2.prototype._reverseFilterLine = function(rawData) {
    var unfilteredLine, filter = rawData[0], currentImage = this._images[this._imageIndex], byteWidth = currentImage.byteWidth;
    if (0 === filter) unfilteredLine = rawData.slice(1, byteWidth + 1); else switch (unfilteredLine = new Buffer(byteWidth), 
    filter) {
      case 1:
        this._unFilterType1(rawData, unfilteredLine, byteWidth);
        break;

      case 2:
        this._unFilterType2(rawData, unfilteredLine, byteWidth);
        break;

      case 3:
        this._unFilterType3(rawData, unfilteredLine, byteWidth);
        break;

      case 4:
        this._unFilterType4(rawData, unfilteredLine, byteWidth);
        break;

      default:
        throw new Error("Unrecognised filter type - " + filter);
    }
    this.write(unfilteredLine), currentImage.lineIndex++, currentImage.lineIndex >= currentImage.height ? (this._lastLine = null, 
    this._imageIndex++, currentImage = this._images[this._imageIndex]) : this._lastLine = unfilteredLine, 
    currentImage ? this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, 
    this.complete());
};

var util$3 = require$$0__default$1.default, ChunkStream$1 = chunkstream.exports, Filter$1 = filterParse.exports, FilterAsync$1 = filterParseAsync.exports = function(bitmapInfo) {
    ChunkStream$1.call(this);
    var buffers = [], that = this;
    this._filter = new Filter$1(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
            buffers.push(buffer);
        },
        complete: function() {
            that.emit("complete", Buffer.concat(buffers));
        }
    }), this._filter.start();
};

util$3.inherits(FilterAsync$1, ChunkStream$1);

var parser$1 = {
    exports: {}
}, constants$7 = {
    PNG_SIGNATURE: [ 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a ],
    TYPE_IHDR: 0x49484452,
    TYPE_IEND: 0x49454e44,
    TYPE_IDAT: 0x49444154,
    TYPE_PLTE: 0x504c5445,
    TYPE_tRNS: 0x74524e53,
    TYPE_gAMA: 0x67414d41,
    COLORTYPE_GRAYSCALE: 0,
    COLORTYPE_PALETTE: 1,
    COLORTYPE_COLOR: 2,
    COLORTYPE_ALPHA: 4,
    COLORTYPE_PALETTE_COLOR: 3,
    COLORTYPE_COLOR_ALPHA: 6,
    COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
    },
    GAMMA_DIVISION: 100000
}, crc = {
    exports: {}
}, crcTable$1 = [];

!function() {
    for (var i = 0; i < 256; i++) {
        for (var currentCrc = i, j = 0; j < 8; j++) 1 & currentCrc ? currentCrc = 0xedb88320 ^ currentCrc >>> 1 : currentCrc >>>= 1;
        crcTable$1[i] = currentCrc;
    }
}();

var CrcCalculator$1 = crc.exports = function() {
    this._crc = -1;
};

CrcCalculator$1.prototype.write = function(data) {
    for (var i = 0; i < data.length; i++) this._crc = crcTable$1[0xff & (this._crc ^ data[i])] ^ this._crc >>> 8;
    return !0;
}, CrcCalculator$1.prototype.crc32 = function() {
    return -1 ^ this._crc;
}, CrcCalculator$1.crc32 = function(buf) {
    for (var crc = -1, i = 0; i < buf.length; i++) crc = crcTable$1[0xff & (crc ^ buf[i])] ^ crc >>> 8;
    return -1 ^ crc;
};

var constants$6 = constants$7, CrcCalculator = crc.exports, Parser$3 = parser$1.exports = function(options, dependencies) {
    this._options = options, options.checkCRC = !1 !== options.checkCRC, this._hasIHDR = !1, 
    this._hasIEND = !1, this._emittedHeadersFinished = !1, this._palette = [], this._colorType = 0, 
    this._chunks = {}, this._chunks[constants$6.TYPE_IHDR] = this._handleIHDR.bind(this), 
    this._chunks[constants$6.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[constants$6.TYPE_IDAT] = this._handleIDAT.bind(this), 
    this._chunks[constants$6.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[constants$6.TYPE_tRNS] = this._handleTRNS.bind(this), 
    this._chunks[constants$6.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = dependencies.read, 
    this.error = dependencies.error, this.metadata = dependencies.metadata, this.gamma = dependencies.gamma, 
    this.transColor = dependencies.transColor, this.palette = dependencies.palette, 
    this.parsed = dependencies.parsed, this.inflateData = dependencies.inflateData, 
    this.finished = dependencies.finished, this.simpleTransparency = dependencies.simpleTransparency, 
    this.headersFinished = dependencies.headersFinished || function() {};
};

Parser$3.prototype.start = function() {
    this.read(constants$6.PNG_SIGNATURE.length, this._parseSignature.bind(this));
}, Parser$3.prototype._parseSignature = function(data) {
    for (var signature = constants$6.PNG_SIGNATURE, i = 0; i < signature.length; i++) if (data[i] !== signature[i]) return void this.error(new Error("Invalid file signature"));
    this.read(8, this._parseChunkBegin.bind(this));
}, Parser$3.prototype._parseChunkBegin = function(data) {
    for (var length = data.readUInt32BE(0), type = data.readUInt32BE(4), name = "", i = 4; i < 8; i++) name += String.fromCharCode(data[i]);
    var ancillary = Boolean(0x20 & data[4]);
    if (this._hasIHDR || type === constants$6.TYPE_IHDR) {
        if (this._crc = new CrcCalculator, this._crc.write(new Buffer(name)), this._chunks[type]) return this._chunks[type](length);
        ancillary ? this.read(length + 4, this._skipChunk.bind(this)) : this.error(new Error("Unsupported critical chunk type " + name));
    } else this.error(new Error("Expected IHDR on beggining"));
}, Parser$3.prototype._skipChunk = function() {
    this.read(8, this._parseChunkBegin.bind(this));
}, Parser$3.prototype._handleChunkEnd = function() {
    this.read(4, this._parseChunkEnd.bind(this));
}, Parser$3.prototype._parseChunkEnd = function(data) {
    var fileCrc = data.readInt32BE(0), calcCrc = this._crc.crc32();
    this._options.checkCRC && calcCrc !== fileCrc ? this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc)) : this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
}, Parser$3.prototype._handleIHDR = function(length) {
    this.read(length, this._parseIHDR.bind(this));
}, Parser$3.prototype._parseIHDR = function(data) {
    this._crc.write(data);
    var width = data.readUInt32BE(0), height = data.readUInt32BE(4), depth = data[8], colorType = data[9], compr = data[10], filter = data[11], interlace = data[12];
    if (8 === depth || 4 === depth || 2 === depth || 1 === depth || 16 === depth) if (colorType in constants$6.COLORTYPE_TO_BPP_MAP) if (0 === compr) if (0 === filter) if (0 === interlace || 1 === interlace) {
        this._colorType = colorType;
        var bpp = constants$6.COLORTYPE_TO_BPP_MAP[this._colorType];
        this._hasIHDR = !0, this.metadata({
            width,
            height,
            depth,
            interlace: Boolean(interlace),
            palette: Boolean(colorType & constants$6.COLORTYPE_PALETTE),
            color: Boolean(colorType & constants$6.COLORTYPE_COLOR),
            alpha: Boolean(colorType & constants$6.COLORTYPE_ALPHA),
            bpp,
            colorType
        }), this._handleChunkEnd();
    } else this.error(new Error("Unsupported interlace method")); else this.error(new Error("Unsupported filter method")); else this.error(new Error("Unsupported compression method")); else this.error(new Error("Unsupported color type")); else this.error(new Error("Unsupported bit depth " + depth));
}, Parser$3.prototype._handlePLTE = function(length) {
    this.read(length, this._parsePLTE.bind(this));
}, Parser$3.prototype._parsePLTE = function(data) {
    this._crc.write(data);
    for (var entries = Math.floor(data.length / 3), i = 0; i < entries; i++) this._palette.push([ data[3 * i], data[3 * i + 1], data[3 * i + 2], 0xff ]);
    this.palette(this._palette), this._handleChunkEnd();
}, Parser$3.prototype._handleTRNS = function(length) {
    this.simpleTransparency(), this.read(length, this._parseTRNS.bind(this));
}, Parser$3.prototype._parseTRNS = function(data) {
    if (this._crc.write(data), this._colorType === constants$6.COLORTYPE_PALETTE_COLOR) {
        if (0 === this._palette.length) return void this.error(new Error("Transparency chunk must be after palette"));
        if (data.length > this._palette.length) return void this.error(new Error("More transparent colors than palette size"));
        for (var i = 0; i < data.length; i++) this._palette[i][3] = data[i];
        this.palette(this._palette);
    }
    this._colorType === constants$6.COLORTYPE_GRAYSCALE && this.transColor([ data.readUInt16BE(0) ]), 
    this._colorType === constants$6.COLORTYPE_COLOR && this.transColor([ data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4) ]), 
    this._handleChunkEnd();
}, Parser$3.prototype._handleGAMA = function(length) {
    this.read(length, this._parseGAMA.bind(this));
}, Parser$3.prototype._parseGAMA = function(data) {
    this._crc.write(data), this.gamma(data.readUInt32BE(0) / constants$6.GAMMA_DIVISION), 
    this._handleChunkEnd();
}, Parser$3.prototype._handleIDAT = function(length) {
    this._emittedHeadersFinished || (this._emittedHeadersFinished = !0, this.headersFinished()), 
    this.read(-length, this._parseIDAT.bind(this, length));
}, Parser$3.prototype._parseIDAT = function(length, data) {
    if (this._crc.write(data), this._colorType === constants$6.COLORTYPE_PALETTE_COLOR && 0 === this._palette.length) throw new Error("Expected palette not found");
    this.inflateData(data);
    var leftOverLength = length - data.length;
    leftOverLength > 0 ? this._handleIDAT(leftOverLength) : this._handleChunkEnd();
}, Parser$3.prototype._handleIEND = function(length) {
    this.read(length, this._parseIEND.bind(this));
}, Parser$3.prototype._parseIEND = function(data) {
    this._crc.write(data), this._hasIEND = !0, this._handleChunkEnd(), this.finished && this.finished();
};

var bitmapper$2 = {}, interlaceUtils = interlace, pixelBppMapper = [ function() {}, function(pxData, data, pxPos, rawPos) {
    if (rawPos === data.length) throw new Error("Ran out of data");
    var pixel = data[rawPos];
    pxData[pxPos] = pixel, pxData[pxPos + 1] = pixel, pxData[pxPos + 2] = pixel, pxData[pxPos + 3] = 0xff;
}, function(pxData, data, pxPos, rawPos) {
    if (rawPos + 1 >= data.length) throw new Error("Ran out of data");
    var pixel = data[rawPos];
    pxData[pxPos] = pixel, pxData[pxPos + 1] = pixel, pxData[pxPos + 2] = pixel, pxData[pxPos + 3] = data[rawPos + 1];
}, function(pxData, data, pxPos, rawPos) {
    if (rawPos + 2 >= data.length) throw new Error("Ran out of data");
    pxData[pxPos] = data[rawPos], pxData[pxPos + 1] = data[rawPos + 1], pxData[pxPos + 2] = data[rawPos + 2], 
    pxData[pxPos + 3] = 0xff;
}, function(pxData, data, pxPos, rawPos) {
    if (rawPos + 3 >= data.length) throw new Error("Ran out of data");
    pxData[pxPos] = data[rawPos], pxData[pxPos + 1] = data[rawPos + 1], pxData[pxPos + 2] = data[rawPos + 2], 
    pxData[pxPos + 3] = data[rawPos + 3];
} ], pixelBppCustomMapper = [ function() {}, function(pxData, pixelData, pxPos, maxBit) {
    var pixel = pixelData[0];
    pxData[pxPos] = pixel, pxData[pxPos + 1] = pixel, pxData[pxPos + 2] = pixel, pxData[pxPos + 3] = maxBit;
}, function(pxData, pixelData, pxPos) {
    var pixel = pixelData[0];
    pxData[pxPos] = pixel, pxData[pxPos + 1] = pixel, pxData[pxPos + 2] = pixel, pxData[pxPos + 3] = pixelData[1];
}, function(pxData, pixelData, pxPos, maxBit) {
    pxData[pxPos] = pixelData[0], pxData[pxPos + 1] = pixelData[1], pxData[pxPos + 2] = pixelData[2], 
    pxData[pxPos + 3] = maxBit;
}, function(pxData, pixelData, pxPos) {
    pxData[pxPos] = pixelData[0], pxData[pxPos + 1] = pixelData[1], pxData[pxPos + 2] = pixelData[2], 
    pxData[pxPos + 3] = pixelData[3];
} ];

function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
    for (var imageWidth = image.width, imageHeight = image.height, imagePass = image.index, y = 0; y < imageHeight; y++) for (var x = 0; x < imageWidth; x++) {
        var pxPos = getPxPos(x, y, imagePass);
        pixelBppMapper[bpp](pxData, data, pxPos, rawPos), rawPos += bpp;
    }
    return rawPos;
}

function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
    for (var imageWidth = image.width, imageHeight = image.height, imagePass = image.index, y = 0; y < imageHeight; y++) {
        for (var x = 0; x < imageWidth; x++) {
            var pixelData = bits.get(bpp), pxPos = getPxPos(x, y, imagePass);
            pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
        }
        bits.resetAfterLine();
    }
}

bitmapper$2.dataToBitMap = function(data, bitmapInfo) {
    var pxData, width = bitmapInfo.width, height = bitmapInfo.height, depth = bitmapInfo.depth, bpp = bitmapInfo.bpp, interlace = bitmapInfo.interlace;
    if (8 !== depth) var bits = function bitRetriever(data, depth) {
        var leftOver = [], i = 0;
        function split() {
            if (i === data.length) throw new Error("Ran out of data");
            var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1, byte = data[i];
            switch (i++, depth) {
              default:
                throw new Error("unrecognised depth");

              case 16:
                byte2 = data[i], i++, leftOver.push((byte << 8) + byte2);
                break;

              case 4:
                byte2 = 0x0f & byte, byte1 = byte >> 4, leftOver.push(byte1, byte2);
                break;

              case 2:
                byte4 = 3 & byte, byte3 = byte >> 2 & 3, byte2 = byte >> 4 & 3, byte1 = byte >> 6 & 3, 
                leftOver.push(byte1, byte2, byte3, byte4);
                break;

              case 1:
                byte8 = 1 & byte, byte7 = byte >> 1 & 1, byte6 = byte >> 2 & 1, byte5 = byte >> 3 & 1, 
                byte4 = byte >> 4 & 1, byte3 = byte >> 5 & 1, byte2 = byte >> 6 & 1, byte1 = byte >> 7 & 1, 
                leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            }
        }
        return {
            get: function(count) {
                for (;leftOver.length < count; ) split();
                var returner = leftOver.slice(0, count);
                return leftOver = leftOver.slice(count), returner;
            },
            resetAfterLine: function() {
                leftOver.length = 0;
            },
            end: function() {
                if (i !== data.length) throw new Error("extra data found");
            }
        };
    }(data, depth);
    pxData = depth <= 8 ? new Buffer(width * height * 4) : new Uint16Array(width * height * 4);
    var images, getPxPos, maxBit = Math.pow(2, depth) - 1, rawPos = 0;
    if (interlace) images = interlaceUtils.getImagePasses(width, height), getPxPos = interlaceUtils.getInterlaceIterator(width, height); else {
        var nonInterlacedPxPos = 0;
        getPxPos = function() {
            var returner = nonInterlacedPxPos;
            return nonInterlacedPxPos += 4, returner;
        }, images = [ {
            width,
            height
        } ];
    }
    for (var imageIndex = 0; imageIndex < images.length; imageIndex++) 8 === depth ? rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos) : mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
    if (8 === depth) {
        if (rawPos !== data.length) throw new Error("extra data found");
    } else bits.end();
    return pxData;
};

var formatNormaliser$2 = function(indata, imageData) {
    var depth = imageData.depth, width = imageData.width, height = imageData.height, colorType = imageData.colorType, transColor = imageData.transColor, palette = imageData.palette, outdata = indata;
    return 3 === colorType ? function dePalette(indata, outdata, width, height, palette) {
        for (var pxPos = 0, y = 0; y < height; y++) for (var x = 0; x < width; x++) {
            var color = palette[indata[pxPos]];
            if (!color) throw new Error("index " + indata[pxPos] + " not in palette");
            for (var i = 0; i < 4; i++) outdata[pxPos + i] = color[i];
            pxPos += 4;
        }
    }(indata, outdata, width, height, palette) : (transColor && function replaceTransparentColor(indata, outdata, width, height, transColor) {
        for (var pxPos = 0, y = 0; y < height; y++) for (var x = 0; x < width; x++) {
            var makeTrans = !1;
            if (1 === transColor.length ? transColor[0] === indata[pxPos] && (makeTrans = !0) : transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2] && (makeTrans = !0), 
            makeTrans) for (var i = 0; i < 4; i++) outdata[pxPos + i] = 0;
            pxPos += 4;
        }
    }(indata, outdata, width, height, transColor), 8 !== depth && (16 === depth && (outdata = new Buffer(width * height * 4)), 
    function scaleDepth(indata, outdata, width, height, depth) {
        for (var maxInSample = Math.pow(2, depth) - 1, pxPos = 0, y = 0; y < height; y++) for (var x = 0; x < width; x++) {
            for (var i = 0; i < 4; i++) outdata[pxPos + i] = Math.floor(255 * indata[pxPos + i] / maxInSample + 0.5);
            pxPos += 4;
        }
    }(indata, outdata, width, height, depth))), outdata;
}, util$2 = require$$0__default$1.default, zlib$3 = require$$4__default.default, ChunkStream = chunkstream.exports, FilterAsync = filterParseAsync.exports, Parser$2 = parser$1.exports, bitmapper$1 = bitmapper$2, formatNormaliser$1 = formatNormaliser$2, ParserAsync = parserAsync.exports = function(options) {
    ChunkStream.call(this), this._parser = new Parser$2(options, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this)
    }), this._options = options, this.writable = !0, this._parser.start();
};

util$2.inherits(ParserAsync, ChunkStream), ParserAsync.prototype._handleError = function(err) {
    this.emit("error", err), this.writable = !1, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), 
    this._filter && (this._filter.destroy(), this._filter.on("error", (function() {}))), 
    this.errord = !0;
}, ParserAsync.prototype._inflateData = function(data) {
    if (!this._inflate) if (this._bitmapInfo.interlace) this._inflate = zlib$3.createInflate(), 
    this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), 
    this._inflate.pipe(this._filter); else {
        var imageSize = (1 + (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3)) * this._bitmapInfo.height, chunkSize = Math.max(imageSize, zlib$3.Z_MIN_CHUNK);
        this._inflate = zlib$3.createInflate({
            chunkSize
        });
        var leftToInflate = imageSize, emitError = this.emit.bind(this, "error");
        this._inflate.on("error", (function(err) {
            leftToInflate && emitError(err);
        })), this._filter.on("complete", this._complete.bind(this));
        var filterWrite = this._filter.write.bind(this._filter);
        this._inflate.on("data", (function(chunk) {
            leftToInflate && (chunk.length > leftToInflate && (chunk = chunk.slice(0, leftToInflate)), 
            leftToInflate -= chunk.length, filterWrite(chunk));
        })), this._inflate.on("end", this._filter.end.bind(this._filter));
    }
    this._inflate.write(data);
}, ParserAsync.prototype._handleMetaData = function(metaData) {
    this._metaData = metaData, this._bitmapInfo = Object.create(metaData), this._filter = new FilterAsync(this._bitmapInfo);
}, ParserAsync.prototype._handleTransColor = function(transColor) {
    this._bitmapInfo.transColor = transColor;
}, ParserAsync.prototype._handlePalette = function(palette) {
    this._bitmapInfo.palette = palette;
}, ParserAsync.prototype._simpleTransparency = function() {
    this._metaData.alpha = !0;
}, ParserAsync.prototype._headersFinished = function() {
    this.emit("metadata", this._metaData);
}, ParserAsync.prototype._finished = function() {
    this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"), 
    this.destroySoon());
}, ParserAsync.prototype._complete = function(filteredData) {
    if (!this.errord) {
        try {
            var bitmapData = bitmapper$1.dataToBitMap(filteredData, this._bitmapInfo), normalisedBitmapData = formatNormaliser$1(bitmapData, this._bitmapInfo);
            bitmapData = null;
        } catch (ex) {
            return void this._handleError(ex);
        }
        this.emit("parsed", normalisedBitmapData);
    }
};

var packerAsync = {
    exports: {}
}, packer = {
    exports: {}
}, constants$5 = constants$7, paethPredictor = paethPredictor$2, filters = {
    0: function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
        for (var x = 0; x < byteWidth; x++) rawData[rawPos + x] = pxData[pxPos + x];
    },
    1: function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
        for (var x = 0; x < byteWidth; x++) {
            var left = x >= bpp ? pxData[pxPos + x - bpp] : 0, val = pxData[pxPos + x] - left;
            rawData[rawPos + x] = val;
        }
    },
    2: function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
        for (var x = 0; x < byteWidth; x++) {
            var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0, val = pxData[pxPos + x] - up;
            rawData[rawPos + x] = val;
        }
    },
    3: function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
        for (var x = 0; x < byteWidth; x++) {
            var left = x >= bpp ? pxData[pxPos + x - bpp] : 0, up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0, val = pxData[pxPos + x] - (left + up >> 1);
            rawData[rawPos + x] = val;
        }
    },
    4: function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
        for (var x = 0; x < byteWidth; x++) {
            var left = x >= bpp ? pxData[pxPos + x - bpp] : 0, up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0, upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0, val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
            rawData[rawPos + x] = val;
        }
    }
}, filterSums = {
    0: function filterSumNone(pxData, pxPos, byteWidth) {
        for (var sum = 0, length = pxPos + byteWidth, i = pxPos; i < length; i++) sum += Math.abs(pxData[i]);
        return sum;
    },
    1: function filterSumSub(pxData, pxPos, byteWidth, bpp) {
        for (var sum = 0, x = 0; x < byteWidth; x++) {
            var left = x >= bpp ? pxData[pxPos + x - bpp] : 0, val = pxData[pxPos + x] - left;
            sum += Math.abs(val);
        }
        return sum;
    },
    2: function filterSumUp(pxData, pxPos, byteWidth) {
        for (var sum = 0, length = pxPos + byteWidth, x = pxPos; x < length; x++) {
            var up = pxPos > 0 ? pxData[x - byteWidth] : 0, val = pxData[x] - up;
            sum += Math.abs(val);
        }
        return sum;
    },
    3: function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
        for (var sum = 0, x = 0; x < byteWidth; x++) {
            var left = x >= bpp ? pxData[pxPos + x - bpp] : 0, up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0, val = pxData[pxPos + x] - (left + up >> 1);
            sum += Math.abs(val);
        }
        return sum;
    },
    4: function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
        for (var sum = 0, x = 0; x < byteWidth; x++) {
            var left = x >= bpp ? pxData[pxPos + x - bpp] : 0, up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0, upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0, val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
            sum += Math.abs(val);
        }
        return sum;
    }
}, constants$4 = constants$7, CrcStream = crc.exports, zlib$2 = require$$4__default.default, Packer$3 = packer.exports = function(options) {
    if (this._options = options, options.deflateChunkSize = options.deflateChunkSize || 32768, 
    options.deflateLevel = null != options.deflateLevel ? options.deflateLevel : 9, 
    options.deflateStrategy = null != options.deflateStrategy ? options.deflateStrategy : 3, 
    options.inputHasAlpha = null == options.inputHasAlpha || options.inputHasAlpha, 
    options.deflateFactory = options.deflateFactory || zlib$2.createDeflate, options.bitDepth = options.bitDepth || 8, 
    options.colorType = "number" == typeof options.colorType ? options.colorType : constants$4.COLORTYPE_COLOR_ALPHA, 
    options.inputColorType = "number" == typeof options.inputColorType ? options.inputColorType : constants$4.COLORTYPE_COLOR_ALPHA, 
    -1 === [ constants$4.COLORTYPE_GRAYSCALE, constants$4.COLORTYPE_COLOR, constants$4.COLORTYPE_COLOR_ALPHA, constants$4.COLORTYPE_ALPHA ].indexOf(options.colorType)) throw new Error("option color type:" + options.colorType + " is not supported at present");
    if (-1 === [ constants$4.COLORTYPE_GRAYSCALE, constants$4.COLORTYPE_COLOR, constants$4.COLORTYPE_COLOR_ALPHA, constants$4.COLORTYPE_ALPHA ].indexOf(options.inputColorType)) throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
    if (8 !== options.bitDepth && 16 !== options.bitDepth) throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
};

Packer$3.prototype.getDeflateOptions = function() {
    return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
    };
}, Packer$3.prototype.createDeflate = function() {
    return this._options.deflateFactory(this.getDeflateOptions());
}, Packer$3.prototype.filterData = function(data, width, height) {
    var packedData = function(dataIn, width, height, options) {
        var buffer, outHasAlpha = -1 !== [ constants$5.COLORTYPE_COLOR_ALPHA, constants$5.COLORTYPE_ALPHA ].indexOf(options.colorType);
        if (options.colorType === options.inputColorType) {
            var bigEndian = (buffer = new ArrayBuffer(2), new DataView(buffer).setInt16(0, 256, !0), 
            256 !== new Int16Array(buffer)[0]);
            if (8 === options.bitDepth || 16 === options.bitDepth && bigEndian) return dataIn;
        }
        var data = 16 !== options.bitDepth ? dataIn : new Uint16Array(dataIn.buffer), maxValue = 255, inBpp = constants$5.COLORTYPE_TO_BPP_MAP[options.inputColorType];
        4 !== inBpp || options.inputHasAlpha || (inBpp = 3);
        var outBpp = constants$5.COLORTYPE_TO_BPP_MAP[options.colorType];
        16 === options.bitDepth && (maxValue = 65535, outBpp *= 2);
        var outData = new Buffer(width * height * outBpp), inIndex = 0, outIndex = 0, bgColor = options.bgColor || {};
        function getRGBA() {
            var red, green, blue, alpha = maxValue;
            switch (options.inputColorType) {
              case constants$5.COLORTYPE_COLOR_ALPHA:
                alpha = data[inIndex + 3], red = data[inIndex], green = data[inIndex + 1], blue = data[inIndex + 2];
                break;

              case constants$5.COLORTYPE_COLOR:
                red = data[inIndex], green = data[inIndex + 1], blue = data[inIndex + 2];
                break;

              case constants$5.COLORTYPE_ALPHA:
                alpha = data[inIndex + 1], green = red = data[inIndex], blue = red;
                break;

              case constants$5.COLORTYPE_GRAYSCALE:
                green = red = data[inIndex], blue = red;
                break;

              default:
                throw new Error("input color type:" + options.inputColorType + " is not supported at present");
            }
            return options.inputHasAlpha && (outHasAlpha || (alpha /= maxValue, red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue), 
            green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue), 
            blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue))), 
            {
                red,
                green,
                blue,
                alpha
            };
        }
        void 0 === bgColor.red && (bgColor.red = maxValue), void 0 === bgColor.green && (bgColor.green = maxValue), 
        void 0 === bgColor.blue && (bgColor.blue = maxValue);
        for (var y = 0; y < height; y++) for (var x = 0; x < width; x++) {
            var rgba = getRGBA();
            switch (options.colorType) {
              case constants$5.COLORTYPE_COLOR_ALPHA:
              case constants$5.COLORTYPE_COLOR:
                8 === options.bitDepth ? (outData[outIndex] = rgba.red, outData[outIndex + 1] = rgba.green, 
                outData[outIndex + 2] = rgba.blue, outHasAlpha && (outData[outIndex + 3] = rgba.alpha)) : (outData.writeUInt16BE(rgba.red, outIndex), 
                outData.writeUInt16BE(rgba.green, outIndex + 2), outData.writeUInt16BE(rgba.blue, outIndex + 4), 
                outHasAlpha && outData.writeUInt16BE(rgba.alpha, outIndex + 6));
                break;

              case constants$5.COLORTYPE_ALPHA:
              case constants$5.COLORTYPE_GRAYSCALE:
                var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
                8 === options.bitDepth ? (outData[outIndex] = grayscale, outHasAlpha && (outData[outIndex + 1] = rgba.alpha)) : (outData.writeUInt16BE(grayscale, outIndex), 
                outHasAlpha && outData.writeUInt16BE(rgba.alpha, outIndex + 2));
                break;

              default:
                throw new Error("unrecognised color Type " + options.colorType);
            }
            inIndex += inBpp, outIndex += outBpp;
        }
        return outData;
    }(data, width, height, this._options), bpp = constants$4.COLORTYPE_TO_BPP_MAP[this._options.colorType];
    return function(pxData, width, height, options, bpp) {
        var filterTypes;
        if ("filterType" in options && -1 !== options.filterType) {
            if ("number" != typeof options.filterType) throw new Error("unrecognised filter types");
            filterTypes = [ options.filterType ];
        } else filterTypes = [ 0, 1, 2, 3, 4 ];
        16 === options.bitDepth && (bpp *= 2);
        for (var byteWidth = width * bpp, rawPos = 0, pxPos = 0, rawData = new Buffer((byteWidth + 1) * height), sel = filterTypes[0], y = 0; y < height; y++) {
            if (filterTypes.length > 1) for (var min = 1 / 0, i = 0; i < filterTypes.length; i++) {
                var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
                sum < min && (sel = filterTypes[i], min = sum);
            }
            rawData[rawPos] = sel, rawPos++, filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp), 
            rawPos += byteWidth, pxPos += byteWidth;
        }
        return rawData;
    }(packedData, width, height, this._options, bpp);
}, Packer$3.prototype._packChunk = function(type, data) {
    var len = data ? data.length : 0, buf = new Buffer(len + 12);
    return buf.writeUInt32BE(len, 0), buf.writeUInt32BE(type, 4), data && data.copy(buf, 8), 
    buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4), 
    buf;
}, Packer$3.prototype.packGAMA = function(gamma) {
    var buf = new Buffer(4);
    return buf.writeUInt32BE(Math.floor(gamma * constants$4.GAMMA_DIVISION), 0), this._packChunk(constants$4.TYPE_gAMA, buf);
}, Packer$3.prototype.packIHDR = function(width, height) {
    var buf = new Buffer(13);
    return buf.writeUInt32BE(width, 0), buf.writeUInt32BE(height, 4), buf[8] = this._options.bitDepth, 
    buf[9] = this._options.colorType, buf[10] = 0, buf[11] = 0, buf[12] = 0, this._packChunk(constants$4.TYPE_IHDR, buf);
}, Packer$3.prototype.packIDAT = function(data) {
    return this._packChunk(constants$4.TYPE_IDAT, data);
}, Packer$3.prototype.packIEND = function() {
    return this._packChunk(constants$4.TYPE_IEND, null);
};

var util$1 = require$$0__default$1.default, Stream$1 = require$$1__default$1.default, constants$3 = constants$7, Packer$2 = packer.exports, PackerAsync = packerAsync.exports = function(opt) {
    Stream$1.call(this);
    var options = opt || {};
    this._packer = new Packer$2(options), this._deflate = this._packer.createDeflate(), 
    this.readable = !0;
};

util$1.inherits(PackerAsync, Stream$1), PackerAsync.prototype.pack = function(data, width, height, gamma) {
    this.emit("data", new Buffer(constants$3.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(width, height)), 
    gamma && this.emit("data", this._packer.packGAMA(gamma));
    var filteredData = this._packer.filterData(data, width, height);
    this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on("data", function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
    }.bind(this)), this._deflate.on("end", function() {
        this.emit("data", this._packer.packIEND()), this.emit("end");
    }.bind(this)), this._deflate.end(filteredData);
};

var pngSync = {}, syncInflate = {
    exports: {}
};

!function(module, exports) {
    var assert = require$$0__default$3.default.ok, zlib = require$$4__default.default, util = require$$0__default$1.default, kMaxLength = require$$3__default$1.default.kMaxLength;
    function Inflate(opts) {
        if (!(this instanceof Inflate)) return new Inflate(opts);
        opts && opts.chunkSize < zlib.Z_MIN_CHUNK && (opts.chunkSize = zlib.Z_MIN_CHUNK), 
        zlib.Inflate.call(this, opts), this._offset = void 0 === this._offset ? this._outOffset : this._offset, 
        this._buffer = this._buffer || this._outBuffer, opts && null != opts.maxLength && (this._maxLength = opts.maxLength);
    }
    function _close(engine, callback) {
        callback && process.nextTick(callback), engine._handle && (engine._handle.close(), 
        engine._handle = null);
    }
    function inflateSync(buffer, opts) {
        return function zlibBufferSync(engine, buffer) {
            if ("string" == typeof buffer && (buffer = Buffer.from(buffer)), !(buffer instanceof Buffer)) throw new TypeError("Not a string or buffer");
            var flushFlag = engine._finishFlushFlag;
            return null == flushFlag && (flushFlag = zlib.Z_FINISH), engine._processChunk(buffer, flushFlag);
        }(new Inflate(opts), buffer);
    }
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
        if ("function" == typeof asyncCb) return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
        var error, self = this, availInBefore = chunk && chunk.length, availOutBefore = this._chunkSize - this._offset, leftToInflate = this._maxLength, inOff = 0, buffers = [], nread = 0;
        function handleChunk(availInAfter, availOutAfter) {
            if (!self._hadError) {
                var have = availOutBefore - availOutAfter;
                if (assert(have >= 0, "have should not go down"), have > 0) {
                    var out = self._buffer.slice(self._offset, self._offset + have);
                    if (self._offset += have, out.length > leftToInflate && (out = out.slice(0, leftToInflate)), 
                    buffers.push(out), nread += out.length, 0 == (leftToInflate -= out.length)) return !1;
                }
                return (0 === availOutAfter || self._offset >= self._chunkSize) && (availOutBefore = self._chunkSize, 
                self._offset = 0, self._buffer = Buffer.allocUnsafe(self._chunkSize)), 0 === availOutAfter && (inOff += availInBefore - availInAfter, 
                availInBefore = availInAfter, !0);
            }
        }
        this.on("error", (function(err) {
            error = err;
        })), assert(this._handle, "zlib binding closed");
        do {
            var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
            res = res || this._writeState;
        } while (!this._hadError && handleChunk(res[0], res[1]));
        if (this._hadError) throw error;
        if (nread >= kMaxLength) throw _close(this), new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
        var buf = Buffer.concat(buffers, nread);
        return _close(this), buf;
    }, util.inherits(Inflate, zlib.Inflate), module.exports = exports = inflateSync, 
    exports.Inflate = Inflate, exports.createInflate = function createInflate(opts) {
        return new Inflate(opts);
    }, exports.inflateSync = inflateSync;
}(syncInflate, syncInflate.exports);

var syncReader = {
    exports: {}
}, SyncReader$2 = syncReader.exports = function(buffer) {
    this._buffer = buffer, this._reads = [];
};

SyncReader$2.prototype.read = function(length, callback) {
    this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
    });
}, SyncReader$2.prototype.process = function() {
    for (;this._reads.length > 0 && this._buffer.length; ) {
        var read = this._reads[0];
        if (!this._buffer.length || !(this._buffer.length >= read.length || read.allowLess)) break;
        this._reads.shift();
        var buf = this._buffer;
        this._buffer = buf.slice(read.length), read.func.call(this, buf.slice(0, read.length));
    }
    return this._reads.length > 0 ? new Error("There are some read requests waitng on finished stream") : this._buffer.length > 0 ? new Error("unrecognised content at end of stream") : void 0;
};

var filterParseSync = {}, SyncReader$1 = syncReader.exports, Filter = filterParse.exports;

filterParseSync.process = function(inBuffer, bitmapInfo) {
    var outBuffers = [], reader = new SyncReader$1(inBuffer);
    return new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
            outBuffers.push(bufferPart);
        },
        complete: function() {}
    }).start(), reader.process(), Buffer.concat(outBuffers);
};

var hasSyncZlib$1 = !0, zlib$1 = require$$4__default.default, inflateSync = syncInflate.exports;

zlib$1.deflateSync || (hasSyncZlib$1 = !1);

var SyncReader = syncReader.exports, FilterSync = filterParseSync, Parser$1 = parser$1.exports, bitmapper = bitmapper$2, formatNormaliser = formatNormaliser$2, hasSyncZlib = !0, zlib = require$$4__default.default;

zlib.deflateSync || (hasSyncZlib = !1);

var constants$2 = constants$7, Packer$1 = packer.exports;

pngSync.read = function(buffer, options) {
    return function(buffer, options) {
        if (!hasSyncZlib$1) throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
        var err, metaData, gamma, inflateDataList = [], reader = new SyncReader(buffer), parser = new Parser$1(options, {
            read: reader.read.bind(reader),
            error: function handleError(_err_) {
                err = _err_;
            },
            metadata: function handleMetaData(_metaData_) {
                metaData = _metaData_;
            },
            gamma: function handleGamma(_gamma_) {
                gamma = _gamma_;
            },
            palette: function handlePalette(palette) {
                metaData.palette = palette;
            },
            transColor: function handleTransColor(transColor) {
                metaData.transColor = transColor;
            },
            inflateData: function handleInflateData(inflatedData) {
                inflateDataList.push(inflatedData);
            },
            simpleTransparency: function handleSimpleTransparency() {
                metaData.alpha = !0;
            }
        });
        if (parser.start(), reader.process(), err) throw err;
        var inflatedData, inflateData = Buffer.concat(inflateDataList);
        if (inflateDataList.length = 0, metaData.interlace) inflatedData = zlib$1.inflateSync(inflateData); else {
            var imageSize = (1 + (metaData.width * metaData.bpp * metaData.depth + 7 >> 3)) * metaData.height;
            inflatedData = inflateSync(inflateData, {
                chunkSize: imageSize,
                maxLength: imageSize
            });
        }
        if (inflateData = null, !inflatedData || !inflatedData.length) throw new Error("bad png - invalid inflate data response");
        var unfilteredData = FilterSync.process(inflatedData, metaData);
        inflateData = null;
        var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
        unfilteredData = null;
        var normalisedBitmapData = formatNormaliser(bitmapData, metaData);
        return metaData.data = normalisedBitmapData, metaData.gamma = gamma || 0, metaData;
    }(buffer, options || {});
}, pngSync.write = function(png, options) {
    return function(metaData, opt) {
        if (!hasSyncZlib) throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
        var packer = new Packer$1(opt || {}), chunks = [];
        chunks.push(new Buffer(constants$2.PNG_SIGNATURE)), chunks.push(packer.packIHDR(metaData.width, metaData.height)), 
        metaData.gamma && chunks.push(packer.packGAMA(metaData.gamma));
        var filteredData = packer.filterData(metaData.data, metaData.width, metaData.height), compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
        if (filteredData = null, !compressedData || !compressedData.length) throw new Error("bad png - invalid compressed data response");
        return chunks.push(packer.packIDAT(compressedData)), chunks.push(packer.packIEND()), 
        Buffer.concat(chunks);
    }(png, options);
};

var util = require$$0__default$1.default, Stream = require$$1__default$1.default, Parser = parserAsync.exports, Packer = packerAsync.exports, PNGSync = pngSync, PNG = png.PNG = function(options) {
    Stream.call(this), options = options || {}, this.width = 0 | options.width, this.height = 0 | options.height, 
    this.data = this.width > 0 && this.height > 0 ? new Buffer(4 * this.width * this.height) : null, 
    options.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = !0, 
    this._parser = new Parser(options), this._parser.on("error", this.emit.bind(this, "error")), 
    this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), 
    this._parser.on("gamma", this._gamma.bind(this)), this._parser.on("parsed", function(data) {
        this.data = data, this.emit("parsed", data);
    }.bind(this)), this._packer = new Packer(options), this._packer.on("data", this.emit.bind(this, "data")), 
    this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), 
    this._packer.on("error", this.emit.bind(this, "error"));
};

util.inherits(PNG, Stream), PNG.sync = PNGSync, PNG.prototype.pack = function() {
    return this.data && this.data.length ? (process.nextTick(function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
    }.bind(this)), this) : (this.emit("error", "No data provided"), this);
}, PNG.prototype.parse = function(data, callback) {
    var onParsed, onError;
    return callback && (onParsed = function(parsedData) {
        this.removeListener("error", onError), this.data = parsedData, callback(null, this);
    }.bind(this), onError = function(err) {
        this.removeListener("parsed", onParsed), callback(err, null);
    }.bind(this), this.once("parsed", onParsed), this.once("error", onError)), this.end(data), 
    this;
}, PNG.prototype.write = function(data) {
    return this._parser.write(data), !0;
}, PNG.prototype.end = function(data) {
    this._parser.end(data);
}, PNG.prototype._metadata = function(metadata) {
    this.width = metadata.width, this.height = metadata.height, this.emit("metadata", metadata);
}, PNG.prototype._gamma = function(gamma) {
    this.gamma = gamma;
}, PNG.prototype._handleClose = function() {
    this._parser.writable || this._packer.readable || this.emit("close");
}, PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
    if (srcY |= 0, width |= 0, height |= 0, deltaX |= 0, deltaY |= 0, (srcX |= 0) > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) throw new Error("bitblt reading outside image");
    if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) throw new Error("bitblt writing outside image");
    for (var y = 0; y < height; y++) src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
}, PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
    return PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY), this;
}, PNG.adjustGamma = function(src) {
    if (src.gamma) {
        for (var y = 0; y < src.height; y++) for (var x = 0; x < src.width; x++) for (var idx = src.width * y + x << 2, i = 0; i < 3; i++) {
            var sample = src.data[idx + i] / 255;
            sample = Math.pow(sample, 1 / 2.2 / src.gamma), src.data[idx + i] = Math.round(255 * sample);
        }
        src.gamma = 0;
    }
}, PNG.prototype.adjustGamma = function() {
    PNG.adjustGamma(this);
}, function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _defineProperty2 = _interopRequireDefault(defineProperty.exports), _pngjs = png, _utils = es$s;
    exports.default = function _default() {
        return {
            mime: (0, _defineProperty2.default)({}, "image/png", [ "png" ]),
            constants: {
                MIME_PNG: "image/png",
                PNG_FILTER_AUTO: -1,
                PNG_FILTER_NONE: 0,
                PNG_FILTER_SUB: 1,
                PNG_FILTER_UP: 2,
                PNG_FILTER_AVERAGE: 3,
                PNG_FILTER_PATH: 4
            },
            hasAlpha: (0, _defineProperty2.default)({}, "image/png", !0),
            decoders: (0, _defineProperty2.default)({}, "image/png", _pngjs.PNG.sync.read),
            encoders: (0, _defineProperty2.default)({}, "image/png", (function(data) {
                var png = new _pngjs.PNG({
                    width: data.bitmap.width,
                    height: data.bitmap.height
                });
                return png.data = data.bitmap.data, _pngjs.PNG.sync.write(png, {
                    width: data.bitmap.width,
                    height: data.bitmap.height,
                    deflateLevel: data._deflateLevel,
                    deflateStrategy: data._deflateStrategy,
                    filterType: data._filterType,
                    colorType: "number" == typeof data._colorType ? data._colorType : data._rgba ? 6 : 2,
                    inputHasAlpha: data._rgba
                });
            })),
            class: {
                _deflateLevel: 9,
                _deflateStrategy: 3,
                _filterType: -1,
                _colorType: null,
                deflateLevel: function deflateLevel(l, cb) {
                    return "number" != typeof l ? _utils.throwError.call(this, "l must be a number", cb) : l < 0 || l > 9 ? _utils.throwError.call(this, "l must be a number 0 - 9", cb) : (this._deflateLevel = Math.round(l), 
                    (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                },
                deflateStrategy: function deflateStrategy(s, cb) {
                    return "number" != typeof s ? _utils.throwError.call(this, "s must be a number", cb) : s < 0 || s > 3 ? _utils.throwError.call(this, "s must be a number 0 - 3", cb) : (this._deflateStrategy = Math.round(s), 
                    (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                },
                filterType: function filterType(f, cb) {
                    return "number" != typeof f ? _utils.throwError.call(this, "n must be a number", cb) : f < -1 || f > 4 ? _utils.throwError.call(this, "n must be -1 (auto) or a number 0 - 4", cb) : (this._filterType = Math.round(f), 
                    (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                },
                colorType: function colorType(s, cb) {
                    return "number" != typeof s ? _utils.throwError.call(this, "s must be a number", cb) : 0 !== s && 2 !== s && 4 !== s && 6 !== s ? _utils.throwError.call(this, "s must be a number 0, 2, 4, 6.", cb) : (this._colorType = Math.round(s), 
                    (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                }
            }
        };
    };
}(es$p);

var es$o = {};

function BmpEncoder(imgData) {
    this.buffer = imgData.data, this.width = imgData.width, this.height = imgData.height, 
    this.extraBytes = this.width % 4, this.rgbSize = this.height * (3 * this.width + this.extraBytes), 
    this.headerInfoSize = 40, this.data = [], this.flag = "BM", this.reserved = 0, this.offset = 54, 
    this.fileSize = this.rgbSize + this.offset, this.planes = 1, this.bitPP = 24, this.compress = 0, 
    this.hr = 0, this.vr = 0, this.colors = 0, this.importantColors = 0;
}

function BmpDecoder(buffer, is_with_alpha) {
    if (this.pos = 0, this.buffer = buffer, this.is_with_alpha = !!is_with_alpha, this.bottom_up = !0, 
    this.flag = this.buffer.toString("utf-8", 0, this.pos += 2), "BM" != this.flag) throw new Error("Invalid BMP File");
    this.parseHeader(), this.parseRGBA();
}

BmpEncoder.prototype.encode = function() {
    var tempBuffer = new Buffer(this.offset + this.rgbSize);
    this.pos = 0, tempBuffer.write(this.flag, this.pos, 2), this.pos += 2, tempBuffer.writeUInt32LE(this.fileSize, this.pos), 
    this.pos += 4, tempBuffer.writeUInt32LE(this.reserved, this.pos), this.pos += 4, 
    tempBuffer.writeUInt32LE(this.offset, this.pos), this.pos += 4, tempBuffer.writeUInt32LE(this.headerInfoSize, this.pos), 
    this.pos += 4, tempBuffer.writeUInt32LE(this.width, this.pos), this.pos += 4, tempBuffer.writeInt32LE(-this.height, this.pos), 
    this.pos += 4, tempBuffer.writeUInt16LE(this.planes, this.pos), this.pos += 2, tempBuffer.writeUInt16LE(this.bitPP, this.pos), 
    this.pos += 2, tempBuffer.writeUInt32LE(this.compress, this.pos), this.pos += 4, 
    tempBuffer.writeUInt32LE(this.rgbSize, this.pos), this.pos += 4, tempBuffer.writeUInt32LE(this.hr, this.pos), 
    this.pos += 4, tempBuffer.writeUInt32LE(this.vr, this.pos), this.pos += 4, tempBuffer.writeUInt32LE(this.colors, this.pos), 
    this.pos += 4, tempBuffer.writeUInt32LE(this.importantColors, this.pos), this.pos += 4;
    for (var i = 0, rowBytes = 3 * this.width + this.extraBytes, y = 0; y < this.height; y++) {
        for (var x = 0; x < this.width; x++) {
            var p = this.pos + y * rowBytes + 3 * x;
            i++, tempBuffer[p] = this.buffer[i++], tempBuffer[p + 1] = this.buffer[i++], tempBuffer[p + 2] = this.buffer[i++];
        }
        if (this.extraBytes > 0) {
            var fillOffset = this.pos + y * rowBytes + 3 * this.width;
            tempBuffer.fill(0, fillOffset, fillOffset + this.extraBytes);
        }
    }
    return tempBuffer;
}, BmpDecoder.prototype.parseHeader = function() {
    if (this.fileSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.reserved = this.buffer.readUInt32LE(this.pos), 
    this.pos += 4, this.offset = this.buffer.readUInt32LE(this.pos), this.pos += 4, 
    this.headerSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.width = this.buffer.readUInt32LE(this.pos), 
    this.pos += 4, this.height = this.buffer.readInt32LE(this.pos), this.pos += 4, this.planes = this.buffer.readUInt16LE(this.pos), 
    this.pos += 2, this.bitPP = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.compress = this.buffer.readUInt32LE(this.pos), 
    this.pos += 4, this.rawSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, 
    this.hr = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.vr = this.buffer.readUInt32LE(this.pos), 
    this.pos += 4, this.colors = this.buffer.readUInt32LE(this.pos), this.pos += 4, 
    this.importantColors = this.buffer.readUInt32LE(this.pos), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), 
    this.bitPP < 15) {
        var len = 0 === this.colors ? 1 << this.bitPP : this.colors;
        this.palette = new Array(len);
        for (var i = 0; i < len; i++) {
            var blue = this.buffer.readUInt8(this.pos++), green = this.buffer.readUInt8(this.pos++), red = this.buffer.readUInt8(this.pos++), quad = this.buffer.readUInt8(this.pos++);
            this.palette[i] = {
                red,
                green,
                blue,
                quad
            };
        }
    }
    this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, BmpDecoder.prototype.parseRGBA = function() {
    var bitn = "bit" + this.bitPP, len = this.width * this.height * 4;
    this.data = new Buffer(len), this[bitn]();
}, BmpDecoder.prototype.bit1 = function() {
    var xlen = Math.ceil(this.width / 8), mode = xlen % 4, y = this.height >= 0 ? this.height - 1 : -this.height;
    for (y = this.height - 1; y >= 0; y--) {
        for (var line = this.bottom_up ? y : this.height - 1 - y, x = 0; x < xlen; x++) for (var b = this.buffer.readUInt8(this.pos++), location = line * this.width * 4 + 8 * x * 4, i = 0; i < 8 && 8 * x + i < this.width; i++) {
            var rgb = this.palette[b >> 7 - i & 0x1];
            this.data[location + 4 * i] = 0, this.data[location + 4 * i + 1] = rgb.blue, this.data[location + 4 * i + 2] = rgb.green, 
            this.data[location + 4 * i + 3] = rgb.red;
        }
        0 != mode && (this.pos += 4 - mode);
    }
}, BmpDecoder.prototype.bit4 = function() {
    if (2 == this.compress) {
        this.data.fill(0xff);
        for (var location = 0, lines = this.bottom_up ? this.height - 1 : 0, low_nibble = !1; location < this.data.length; ) {
            var a = this.buffer.readUInt8(this.pos++), b = this.buffer.readUInt8(this.pos++);
            if (0 == a) {
                if (0 == b) {
                    this.bottom_up ? lines-- : lines++, location = lines * this.width * 4, low_nibble = !1;
                    continue;
                }
                if (1 == b) break;
                if (2 == b) {
                    var x = this.buffer.readUInt8(this.pos++), y = this.buffer.readUInt8(this.pos++);
                    this.bottom_up ? lines -= y : lines += y, location += y * this.width * 4 + 4 * x;
                } else {
                    for (var c = this.buffer.readUInt8(this.pos++), i = 0; i < b; i++) low_nibble ? setPixelData.call(this, 0x0f & c) : setPixelData.call(this, (0xf0 & c) >> 4), 
                    1 & i && i + 1 < b && (c = this.buffer.readUInt8(this.pos++)), low_nibble = !low_nibble;
                    1 == (b + 1 >> 1 & 1) && this.pos++;
                }
            } else for (i = 0; i < a; i++) low_nibble ? setPixelData.call(this, 0x0f & b) : setPixelData.call(this, (0xf0 & b) >> 4), 
            low_nibble = !low_nibble;
        }
        function setPixelData(rgbIndex) {
            var rgb = this.palette[rgbIndex];
            this.data[location] = 0, this.data[location + 1] = rgb.blue, this.data[location + 2] = rgb.green, 
            this.data[location + 3] = rgb.red, location += 4;
        }
    } else {
        var xlen = Math.ceil(this.width / 2), mode = xlen % 4;
        for (y = this.height - 1; y >= 0; y--) {
            var line = this.bottom_up ? y : this.height - 1 - y;
            for (x = 0; x < xlen; x++) {
                b = this.buffer.readUInt8(this.pos++), location = line * this.width * 4 + 2 * x * 4;
                var before = b >> 4, after = 0x0F & b, rgb = this.palette[before];
                if (this.data[location] = 0, this.data[location + 1] = rgb.blue, this.data[location + 2] = rgb.green, 
                this.data[location + 3] = rgb.red, 2 * x + 1 >= this.width) break;
                rgb = this.palette[after], this.data[location + 4] = 0, this.data[location + 4 + 1] = rgb.blue, 
                this.data[location + 4 + 2] = rgb.green, this.data[location + 4 + 3] = rgb.red;
            }
            0 != mode && (this.pos += 4 - mode);
        }
    }
}, BmpDecoder.prototype.bit8 = function() {
    if (1 == this.compress) {
        this.data.fill(0xff);
        for (var location = 0, lines = this.bottom_up ? this.height - 1 : 0; location < this.data.length; ) {
            var a = this.buffer.readUInt8(this.pos++), b = this.buffer.readUInt8(this.pos++);
            if (0 == a) {
                if (0 == b) {
                    this.bottom_up ? lines-- : lines++, location = lines * this.width * 4;
                    continue;
                }
                if (1 == b) break;
                if (2 == b) {
                    var x = this.buffer.readUInt8(this.pos++), y = this.buffer.readUInt8(this.pos++);
                    this.bottom_up ? lines -= y : lines += y, location += y * this.width * 4 + 4 * x;
                } else {
                    for (var i = 0; i < b; i++) {
                        var c = this.buffer.readUInt8(this.pos++);
                        setPixelData.call(this, c);
                    }
                    !0 & b && this.pos++;
                }
            } else for (i = 0; i < a; i++) setPixelData.call(this, b);
        }
        function setPixelData(rgbIndex) {
            var rgb = this.palette[rgbIndex];
            this.data[location] = 0, this.data[location + 1] = rgb.blue, this.data[location + 2] = rgb.green, 
            this.data[location + 3] = rgb.red, location += 4;
        }
    } else {
        var mode = this.width % 4;
        for (y = this.height - 1; y >= 0; y--) {
            var line = this.bottom_up ? y : this.height - 1 - y;
            for (x = 0; x < this.width; x++) if (b = this.buffer.readUInt8(this.pos++), location = line * this.width * 4 + 4 * x, 
            b < this.palette.length) {
                var rgb = this.palette[b];
                this.data[location] = 0, this.data[location + 1] = rgb.blue, this.data[location + 2] = rgb.green, 
                this.data[location + 3] = rgb.red;
            } else this.data[location] = 0, this.data[location + 1] = 0xFF, this.data[location + 2] = 0xFF, 
            this.data[location + 3] = 0xFF;
            0 != mode && (this.pos += 4 - mode);
        }
    }
}, BmpDecoder.prototype.bit15 = function() {
    for (var dif_w = this.width % 3, _1_5 = parseInt("11111", 2), y = this.height - 1; y >= 0; y--) {
        for (var line = this.bottom_up ? y : this.height - 1 - y, x = 0; x < this.width; x++) {
            var B = this.buffer.readUInt16LE(this.pos);
            this.pos += 2;
            var blue = (B & _1_5) / _1_5 * 255 | 0, green = (B >> 5 & _1_5) / _1_5 * 255 | 0, red = (B >> 10 & _1_5) / _1_5 * 255 | 0, alpha = B >> 15 ? 0xFF : 0x00, location = line * this.width * 4 + 4 * x;
            this.data[location] = alpha, this.data[location + 1] = blue, this.data[location + 2] = green, 
            this.data[location + 3] = red;
        }
        this.pos += dif_w;
    }
}, BmpDecoder.prototype.bit16 = function() {
    var dif_w = this.width % 2 * 2;
    this.maskRed = 0x7C00, this.maskGreen = 0x3E0, this.maskBlue = 0x1F, this.mask0 = 0, 
    3 == this.compress && (this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, 
    this.maskGreen = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), 
    this.pos += 4, this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4);
    for (var ns = [ 0, 0, 0 ], i = 0; i < 16; i++) this.maskRed >> i & 0x01 && ns[0]++, 
    this.maskGreen >> i & 0x01 && ns[1]++, this.maskBlue >> i & 0x01 && ns[2]++;
    ns[1] += ns[0], ns[2] += ns[1], ns[0] = 8 - ns[0], ns[1] -= 8, ns[2] -= 8;
    for (var y = this.height - 1; y >= 0; y--) {
        for (var line = this.bottom_up ? y : this.height - 1 - y, x = 0; x < this.width; x++) {
            var B = this.buffer.readUInt16LE(this.pos);
            this.pos += 2;
            var blue = (B & this.maskBlue) << ns[0], green = (B & this.maskGreen) >> ns[1], red = (B & this.maskRed) >> ns[2], location = line * this.width * 4 + 4 * x;
            this.data[location] = 0, this.data[location + 1] = blue, this.data[location + 2] = green, 
            this.data[location + 3] = red;
        }
        this.pos += dif_w;
    }
}, BmpDecoder.prototype.bit24 = function() {
    for (var y = this.height - 1; y >= 0; y--) {
        for (var line = this.bottom_up ? y : this.height - 1 - y, x = 0; x < this.width; x++) {
            var blue = this.buffer.readUInt8(this.pos++), green = this.buffer.readUInt8(this.pos++), red = this.buffer.readUInt8(this.pos++), location = line * this.width * 4 + 4 * x;
            this.data[location] = 0, this.data[location + 1] = blue, this.data[location + 2] = green, 
            this.data[location + 3] = red;
        }
        this.pos += this.width % 4;
    }
}, BmpDecoder.prototype.bit32 = function() {
    if (3 == this.compress) {
        this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskGreen = this.buffer.readUInt32LE(this.pos), 
        this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), this.pos += 4, 
        this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4;
        for (var y = this.height - 1; y >= 0; y--) for (var line = this.bottom_up ? y : this.height - 1 - y, x = 0; x < this.width; x++) {
            var alpha = this.buffer.readUInt8(this.pos++), blue = this.buffer.readUInt8(this.pos++), green = this.buffer.readUInt8(this.pos++), red = this.buffer.readUInt8(this.pos++), location = line * this.width * 4 + 4 * x;
            this.data[location] = alpha, this.data[location + 1] = blue, this.data[location + 2] = green, 
            this.data[location + 3] = red;
        }
    } else for (y = this.height - 1; y >= 0; y--) for (line = this.bottom_up ? y : this.height - 1 - y, 
    x = 0; x < this.width; x++) blue = this.buffer.readUInt8(this.pos++), green = this.buffer.readUInt8(this.pos++), 
    red = this.buffer.readUInt8(this.pos++), alpha = this.buffer.readUInt8(this.pos++), 
    location = line * this.width * 4 + 4 * x, this.data[location] = alpha, this.data[location + 1] = blue, 
    this.data[location + 2] = green, this.data[location + 3] = red;
}, BmpDecoder.prototype.getData = function() {
    return this.data;
};

var bmpJs = {
    encode: function(imgData, quality) {
        return {
            data: new BmpEncoder(imgData).encode(),
            width: imgData.width,
            height: imgData.height
        };
    },
    decode: function(bmpData) {
        return new BmpDecoder(bmpData);
    }
};

!function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _defineProperty2 = _interopRequireDefault(defineProperty.exports), _bmpJs = _interopRequireDefault(bmpJs), _utils = es$s, decode = function decode(data) {
        return function fromAGBR(bitmap) {
            return (0, _utils.scan)({
                bitmap
            }, 0, 0, bitmap.width, bitmap.height, (function(x, y, index) {
                var alpha = this.bitmap.data[index + 0], blue = this.bitmap.data[index + 1], green = this.bitmap.data[index + 2], red = this.bitmap.data[index + 3];
                this.bitmap.data[index + 0] = red, this.bitmap.data[index + 1] = green, this.bitmap.data[index + 2] = blue, 
                this.bitmap.data[index + 3] = bitmap.is_with_alpha ? alpha : 0xff;
            })).bitmap;
        }(_bmpJs.default.decode(data));
    }, encode = function encode(image) {
        return _bmpJs.default.encode(function toAGBR(image) {
            return (0, _utils.scan)(image, 0, 0, image.bitmap.width, image.bitmap.height, (function(x, y, index) {
                var red = this.bitmap.data[index + 0], green = this.bitmap.data[index + 1], blue = this.bitmap.data[index + 2], alpha = this.bitmap.data[index + 3];
                this.bitmap.data[index + 0] = alpha, this.bitmap.data[index + 1] = blue, this.bitmap.data[index + 2] = green, 
                this.bitmap.data[index + 3] = red;
            })).bitmap;
        }(image)).data;
    };
    exports.default = function _default() {
        var _decoders, _encoders;
        return {
            mime: (0, _defineProperty2.default)({}, "image/bmp", [ "bmp" ]),
            constants: {
                MIME_BMP: "image/bmp",
                MIME_X_MS_BMP: "image/x-ms-bmp"
            },
            decoders: (_decoders = {}, (0, _defineProperty2.default)(_decoders, "image/bmp", decode), 
            (0, _defineProperty2.default)(_decoders, "image/x-ms-bmp", decode), _decoders),
            encoders: (_encoders = {}, (0, _defineProperty2.default)(_encoders, "image/bmp", encode), 
            (0, _defineProperty2.default)(_encoders, "image/x-ms-bmp", encode), _encoders)
        };
    };
}(es$o);

var es$n = {}, UTIF = {
    exports: {}
}, common = {};

!function(exports) {
    var TYPED_OK = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
    function _has(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
        for (var sources = Array.prototype.slice.call(arguments, 1); sources.length; ) {
            var source = sources.shift();
            if (source) {
                if ("object" != typeof source) throw new TypeError(source + "must be non-object");
                for (var p in source) _has(source, p) && (obj[p] = source[p]);
            }
        }
        return obj;
    }, exports.shrinkBuf = function(buf, size) {
        return buf.length === size ? buf : buf.subarray ? buf.subarray(0, size) : (buf.length = size, 
        buf);
    };
    var fnTyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
            if (src.subarray && dest.subarray) dest.set(src.subarray(src_offs, src_offs + len), dest_offs); else for (var i = 0; i < len; i++) dest[dest_offs + i] = src[src_offs + i];
        },
        flattenChunks: function(chunks) {
            var i, l, len, pos, chunk, result;
            for (len = 0, i = 0, l = chunks.length; i < l; i++) len += chunks[i].length;
            for (result = new Uint8Array(len), pos = 0, i = 0, l = chunks.length; i < l; i++) chunk = chunks[i], 
            result.set(chunk, pos), pos += chunk.length;
            return result;
        }
    }, fnUntyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
            for (var i = 0; i < len; i++) dest[dest_offs + i] = src[src_offs + i];
        },
        flattenChunks: function(chunks) {
            return [].concat.apply([], chunks);
        }
    };
    exports.setTyped = function(on) {
        on ? (exports.Buf8 = Uint8Array, exports.Buf16 = Uint16Array, exports.Buf32 = Int32Array, 
        exports.assign(exports, fnTyped)) : (exports.Buf8 = Array, exports.Buf16 = Array, 
        exports.Buf32 = Array, exports.assign(exports, fnUntyped));
    }, exports.setTyped(TYPED_OK);
}(common);

var deflate$4 = {}, deflate$3 = {}, trees$1 = {}, utils$8 = common;

function zero$1(buf) {
    for (var len = buf.length; --len >= 0; ) buf[len] = 0;
}

var extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ], extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ], extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ], bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], static_ltree = new Array(576);

zero$1(static_ltree);

var static_dtree = new Array(60);

zero$1(static_dtree);

var _dist_code = new Array(512);

zero$1(_dist_code);

var _length_code = new Array(256);

zero$1(_length_code);

var base_length = new Array(29);

zero$1(base_length);

var static_l_desc, static_d_desc, static_bl_desc, base_dist = new Array(30);

function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree, this.extra_bits = extra_bits, this.extra_base = extra_base, 
    this.elems = elems, this.max_length = max_length, this.has_stree = static_tree && static_tree.length;
}

function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree, this.max_code = 0, this.stat_desc = stat_desc;
}

function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}

function put_short(s, w) {
    s.pending_buf[s.pending++] = 0xff & w, s.pending_buf[s.pending++] = w >>> 8 & 0xff;
}

function send_bits(s, value, length) {
    s.bi_valid > 16 - length ? (s.bi_buf |= value << s.bi_valid & 0xffff, put_short(s, s.bi_buf), 
    s.bi_buf = value >> 16 - s.bi_valid, s.bi_valid += length - 16) : (s.bi_buf |= value << s.bi_valid & 0xffff, 
    s.bi_valid += length);
}

function send_code(s, c, tree) {
    send_bits(s, tree[2 * c], tree[2 * c + 1]);
}

function bi_reverse(code, len) {
    var res = 0;
    do {
        res |= 1 & code, code >>>= 1, res <<= 1;
    } while (--len > 0);
    return res >>> 1;
}

function gen_codes(tree, max_code, bl_count) {
    var bits, n, next_code = new Array(16), code = 0;
    for (bits = 1; bits <= 15; bits++) next_code[bits] = code = code + bl_count[bits - 1] << 1;
    for (n = 0; n <= max_code; n++) {
        var len = tree[2 * n + 1];
        0 !== len && (tree[2 * n] = bi_reverse(next_code[len]++, len));
    }
}

function init_block(s) {
    var n;
    for (n = 0; n < 286; n++) s.dyn_ltree[2 * n] = 0;
    for (n = 0; n < 30; n++) s.dyn_dtree[2 * n] = 0;
    for (n = 0; n < 19; n++) s.bl_tree[2 * n] = 0;
    s.dyn_ltree[512] = 1, s.opt_len = s.static_len = 0, s.last_lit = s.matches = 0;
}

function bi_windup(s) {
    s.bi_valid > 8 ? put_short(s, s.bi_buf) : s.bi_valid > 0 && (s.pending_buf[s.pending++] = s.bi_buf), 
    s.bi_buf = 0, s.bi_valid = 0;
}

function smaller(tree, n, m, depth) {
    var _n2 = 2 * n, _m2 = 2 * m;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
}

function pqdownheap(s, tree, k) {
    for (var v = s.heap[k], j = k << 1; j <= s.heap_len && (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth) && j++, 
    !smaller(tree, v, s.heap[j], s.depth)); ) s.heap[k] = s.heap[j], k = j, j <<= 1;
    s.heap[k] = v;
}

function compress_block(s, ltree, dtree) {
    var dist, lc, code, extra, lx = 0;
    if (0 !== s.last_lit) do {
        dist = s.pending_buf[s.d_buf + 2 * lx] << 8 | s.pending_buf[s.d_buf + 2 * lx + 1], 
        lc = s.pending_buf[s.l_buf + lx], lx++, 0 === dist ? send_code(s, lc, ltree) : (send_code(s, (code = _length_code[lc]) + 256 + 1, ltree), 
        0 !== (extra = extra_lbits[code]) && send_bits(s, lc -= base_length[code], extra), 
        send_code(s, code = d_code(--dist), dtree), 0 !== (extra = extra_dbits[code]) && send_bits(s, dist -= base_dist[code], extra));
    } while (lx < s.last_lit);
    send_code(s, 256, ltree);
}

function build_tree(s, desc) {
    var n, m, node, tree = desc.dyn_tree, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, elems = desc.stat_desc.elems, max_code = -1;
    for (s.heap_len = 0, s.heap_max = 573, n = 0; n < elems; n++) 0 !== tree[2 * n] ? (s.heap[++s.heap_len] = max_code = n, 
    s.depth[n] = 0) : tree[2 * n + 1] = 0;
    for (;s.heap_len < 2; ) tree[2 * (node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0)] = 1, 
    s.depth[node] = 0, s.opt_len--, has_stree && (s.static_len -= stree[2 * node + 1]);
    for (desc.max_code = max_code, n = s.heap_len >> 1; n >= 1; n--) pqdownheap(s, tree, n);
    node = elems;
    do {
        n = s.heap[1], s.heap[1] = s.heap[s.heap_len--], pqdownheap(s, tree, 1), m = s.heap[1], 
        s.heap[--s.heap_max] = n, s.heap[--s.heap_max] = m, tree[2 * node] = tree[2 * n] + tree[2 * m], 
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1, tree[2 * n + 1] = tree[2 * m + 1] = node, 
        s.heap[1] = node++, pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1], function gen_bitlen(s, desc) {
        var h, n, m, bits, xbits, f, tree = desc.dyn_tree, max_code = desc.max_code, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, extra = desc.stat_desc.extra_bits, base = desc.stat_desc.extra_base, max_length = desc.stat_desc.max_length, overflow = 0;
        for (bits = 0; bits <= 15; bits++) s.bl_count[bits] = 0;
        for (tree[2 * s.heap[s.heap_max] + 1] = 0, h = s.heap_max + 1; h < 573; h++) (bits = tree[2 * tree[2 * (n = s.heap[h]) + 1] + 1] + 1) > max_length && (bits = max_length, 
        overflow++), tree[2 * n + 1] = bits, n > max_code || (s.bl_count[bits]++, xbits = 0, 
        n >= base && (xbits = extra[n - base]), f = tree[2 * n], s.opt_len += f * (bits + xbits), 
        has_stree && (s.static_len += f * (stree[2 * n + 1] + xbits)));
        if (0 !== overflow) {
            do {
                for (bits = max_length - 1; 0 === s.bl_count[bits]; ) bits--;
                s.bl_count[bits]--, s.bl_count[bits + 1] += 2, s.bl_count[max_length]--, overflow -= 2;
            } while (overflow > 0);
            for (bits = max_length; 0 !== bits; bits--) for (n = s.bl_count[bits]; 0 !== n; ) (m = s.heap[--h]) > max_code || (tree[2 * m + 1] !== bits && (s.opt_len += (bits - tree[2 * m + 1]) * tree[2 * m], 
            tree[2 * m + 1] = bits), n--);
        }
    }(s, desc), gen_codes(tree, max_code, s.bl_count);
}

function scan_tree(s, tree, max_code) {
    var n, curlen, prevlen = -1, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
    for (0 === nextlen && (max_count = 138, min_count = 3), tree[2 * (max_code + 1) + 1] = 0xffff, 
    n = 0; n <= max_code; n++) curlen = nextlen, nextlen = tree[2 * (n + 1) + 1], ++count < max_count && curlen === nextlen || (count < min_count ? s.bl_tree[2 * curlen] += count : 0 !== curlen ? (curlen !== prevlen && s.bl_tree[2 * curlen]++, 
    s.bl_tree[32]++) : count <= 10 ? s.bl_tree[34]++ : s.bl_tree[36]++, count = 0, prevlen = curlen, 
    0 === nextlen ? (max_count = 138, min_count = 3) : curlen === nextlen ? (max_count = 6, 
    min_count = 3) : (max_count = 7, min_count = 4));
}

function send_tree(s, tree, max_code) {
    var n, curlen, prevlen = -1, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
    for (0 === nextlen && (max_count = 138, min_count = 3), n = 0; n <= max_code; n++) if (curlen = nextlen, 
    nextlen = tree[2 * (n + 1) + 1], !(++count < max_count && curlen === nextlen)) {
        if (count < min_count) do {
            send_code(s, curlen, s.bl_tree);
        } while (0 != --count); else 0 !== curlen ? (curlen !== prevlen && (send_code(s, curlen, s.bl_tree), 
        count--), send_code(s, 16, s.bl_tree), send_bits(s, count - 3, 2)) : count <= 10 ? (send_code(s, 17, s.bl_tree), 
        send_bits(s, count - 3, 3)) : (send_code(s, 18, s.bl_tree), send_bits(s, count - 11, 7));
        count = 0, prevlen = curlen, 0 === nextlen ? (max_count = 138, min_count = 3) : curlen === nextlen ? (max_count = 6, 
        min_count = 3) : (max_count = 7, min_count = 4);
    }
}

zero$1(base_dist);

var static_init_done = !1;

function _tr_stored_block(s, buf, stored_len, last) {
    send_bits(s, 0 + (last ? 1 : 0), 3), function copy_block(s, buf, len, header) {
        bi_windup(s), header && (put_short(s, len), put_short(s, ~len)), utils$8.arraySet(s.pending_buf, s.window, buf, len, s.pending), 
        s.pending += len;
    }(s, buf, stored_len, !0);
}

trees$1._tr_init = function _tr_init(s) {
    static_init_done || (function tr_static_init() {
        var n, bits, length, code, dist, bl_count = new Array(16);
        for (length = 0, code = 0; code < 28; code++) for (base_length[code] = length, n = 0; n < 1 << extra_lbits[code]; n++) _length_code[length++] = code;
        for (_length_code[length - 1] = code, dist = 0, code = 0; code < 16; code++) for (base_dist[code] = dist, 
        n = 0; n < 1 << extra_dbits[code]; n++) _dist_code[dist++] = code;
        for (dist >>= 7; code < 30; code++) for (base_dist[code] = dist << 7, n = 0; n < 1 << extra_dbits[code] - 7; n++) _dist_code[256 + dist++] = code;
        for (bits = 0; bits <= 15; bits++) bl_count[bits] = 0;
        for (n = 0; n <= 143; ) static_ltree[2 * n + 1] = 8, n++, bl_count[8]++;
        for (;n <= 255; ) static_ltree[2 * n + 1] = 9, n++, bl_count[9]++;
        for (;n <= 279; ) static_ltree[2 * n + 1] = 7, n++, bl_count[7]++;
        for (;n <= 287; ) static_ltree[2 * n + 1] = 8, n++, bl_count[8]++;
        for (gen_codes(static_ltree, 287, bl_count), n = 0; n < 30; n++) static_dtree[2 * n + 1] = 5, 
        static_dtree[2 * n] = bi_reverse(n, 5);
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, 257, 286, 15), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, 30, 15), 
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, 19, 7);
    }(), static_init_done = !0), s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc), 
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc), s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc), 
    s.bi_buf = 0, s.bi_valid = 0, init_block(s);
}, trees$1._tr_stored_block = _tr_stored_block, trees$1._tr_flush_block = function _tr_flush_block(s, buf, stored_len, last) {
    var opt_lenb, static_lenb, max_blindex = 0;
    s.level > 0 ? (2 === s.strm.data_type && (s.strm.data_type = function detect_data_type(s) {
        var n, black_mask = 0xf3ffc07f;
        for (n = 0; n <= 31; n++, black_mask >>>= 1) if (1 & black_mask && 0 !== s.dyn_ltree[2 * n]) return 0;
        if (0 !== s.dyn_ltree[18] || 0 !== s.dyn_ltree[20] || 0 !== s.dyn_ltree[26]) return 1;
        for (n = 32; n < 256; n++) if (0 !== s.dyn_ltree[2 * n]) return 1;
        return 0;
    }(s)), build_tree(s, s.l_desc), build_tree(s, s.d_desc), max_blindex = function build_bl_tree(s) {
        var max_blindex;
        for (scan_tree(s, s.dyn_ltree, s.l_desc.max_code), scan_tree(s, s.dyn_dtree, s.d_desc.max_code), 
        build_tree(s, s.bl_desc), max_blindex = 18; max_blindex >= 3 && 0 === s.bl_tree[2 * bl_order[max_blindex] + 1]; max_blindex--) ;
        return s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4, max_blindex;
    }(s), opt_lenb = s.opt_len + 3 + 7 >>> 3, (static_lenb = s.static_len + 3 + 7 >>> 3) <= opt_lenb && (opt_lenb = static_lenb)) : opt_lenb = static_lenb = stored_len + 5, 
    stored_len + 4 <= opt_lenb && -1 !== buf ? _tr_stored_block(s, buf, stored_len, last) : 4 === s.strategy || static_lenb === opt_lenb ? (send_bits(s, 2 + (last ? 1 : 0), 3), 
    compress_block(s, static_ltree, static_dtree)) : (send_bits(s, 4 + (last ? 1 : 0), 3), 
    function send_all_trees(s, lcodes, dcodes, blcodes) {
        var rank;
        for (send_bits(s, lcodes - 257, 5), send_bits(s, dcodes - 1, 5), send_bits(s, blcodes - 4, 4), 
        rank = 0; rank < blcodes; rank++) send_bits(s, s.bl_tree[2 * bl_order[rank] + 1], 3);
        send_tree(s, s.dyn_ltree, lcodes - 1), send_tree(s, s.dyn_dtree, dcodes - 1);
    }(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1), compress_block(s, s.dyn_ltree, s.dyn_dtree)), 
    init_block(s), last && bi_windup(s);
}, trees$1._tr_tally = function _tr_tally(s, dist, lc) {
    return s.pending_buf[s.d_buf + 2 * s.last_lit] = dist >>> 8 & 0xff, s.pending_buf[s.d_buf + 2 * s.last_lit + 1] = 0xff & dist, 
    s.pending_buf[s.l_buf + s.last_lit] = 0xff & lc, s.last_lit++, 0 === dist ? s.dyn_ltree[2 * lc]++ : (s.matches++, 
    dist--, s.dyn_ltree[2 * (_length_code[lc] + 256 + 1)]++, s.dyn_dtree[2 * d_code(dist)]++), 
    s.last_lit === s.lit_bufsize - 1;
}, trees$1._tr_align = function _tr_align(s) {
    send_bits(s, 2, 3), send_code(s, 256, static_ltree), function bi_flush(s) {
        16 === s.bi_valid ? (put_short(s, s.bi_buf), s.bi_buf = 0, s.bi_valid = 0) : s.bi_valid >= 8 && (s.pending_buf[s.pending++] = 0xff & s.bi_buf, 
        s.bi_buf >>= 8, s.bi_valid -= 8);
    }(s);
};

var configuration_table, adler32_1 = function adler32$2(adler, buf, len, pos) {
    for (var s1 = 0xffff & adler | 0, s2 = adler >>> 16 & 0xffff | 0, n = 0; 0 !== len; ) {
        len -= n = len > 2000 ? 2000 : len;
        do {
            s2 = s2 + (s1 = s1 + buf[pos++] | 0) | 0;
        } while (--n);
        s1 %= 65521, s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
}, crcTable = function makeTable() {
    for (var c, table = [], n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) c = 1 & c ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
        table[n] = c;
    }
    return table;
}(), crc32_1 = function crc32$2(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc ^= -1;
    for (var i = pos; i < end; i++) crc = crc >>> 8 ^ t[0xFF & (crc ^ buf[i])];
    return -1 ^ crc;
}, messages = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
}, utils$7 = common, trees = trees$1, adler32$1 = adler32_1, crc32$1 = crc32_1, msg$2 = messages;

function err(strm, errorCode) {
    return strm.msg = msg$2[errorCode], errorCode;
}

function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
}

function zero(buf) {
    for (var len = buf.length; --len >= 0; ) buf[len] = 0;
}

function flush_pending(strm) {
    var s = strm.state, len = s.pending;
    len > strm.avail_out && (len = strm.avail_out), 0 !== len && (utils$7.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out), 
    strm.next_out += len, s.pending_out += len, strm.total_out += len, strm.avail_out -= len, 
    s.pending -= len, 0 === s.pending && (s.pending_out = 0));
}

function flush_block_only(s, last) {
    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last), 
    s.block_start = s.strstart, flush_pending(s.strm);
}

function put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
}

function putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 0xff, s.pending_buf[s.pending++] = 0xff & b;
}

function longest_match(s, cur_match) {
    var match, len, chain_length = s.max_chain_length, scan = s.strstart, best_len = s.prev_length, nice_match = s.nice_match, limit = s.strstart > s.w_size - 262 ? s.strstart - (s.w_size - 262) : 0, _win = s.window, wmask = s.w_mask, prev = s.prev, strend = s.strstart + 258, scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];
    s.prev_length >= s.good_match && (chain_length >>= 2), nice_match > s.lookahead && (nice_match = s.lookahead);
    do {
        if (_win[(match = cur_match) + best_len] === scan_end && _win[match + best_len - 1] === scan_end1 && _win[match] === _win[scan] && _win[++match] === _win[scan + 1]) {
            scan += 2, match++;
            do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
            if (len = 258 - (strend - scan), scan = strend - 258, len > best_len) {
                if (s.match_start = cur_match, best_len = len, len >= nice_match) break;
                scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];
            }
        }
    } while ((cur_match = prev[cur_match & wmask]) > limit && 0 != --chain_length);
    return best_len <= s.lookahead ? best_len : s.lookahead;
}

function fill_window(s) {
    var p, n, m, more, str, strm, buf, start, size, len, _w_size = s.w_size;
    do {
        if (more = s.window_size - s.lookahead - s.strstart, s.strstart >= _w_size + (_w_size - 262)) {
            utils$7.arraySet(s.window, s.window, _w_size, _w_size, 0), s.match_start -= _w_size, 
            s.strstart -= _w_size, s.block_start -= _w_size, p = n = s.hash_size;
            do {
                m = s.head[--p], s.head[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            p = n = _w_size;
            do {
                m = s.prev[--p], s.prev[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            more += _w_size;
        }
        if (0 === s.strm.avail_in) break;
        if (strm = s.strm, buf = s.window, start = s.strstart + s.lookahead, size = more, 
        len = void 0, (len = strm.avail_in) > size && (len = size), n = 0 === len ? 0 : (strm.avail_in -= len, 
        utils$7.arraySet(buf, strm.input, strm.next_in, len, start), 1 === strm.state.wrap ? strm.adler = adler32$1(strm.adler, buf, len, start) : 2 === strm.state.wrap && (strm.adler = crc32$1(strm.adler, buf, len, start)), 
        strm.next_in += len, strm.total_in += len, len), s.lookahead += n, s.lookahead + s.insert >= 3) for (str = s.strstart - s.insert, 
        s.ins_h = s.window[str], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; s.insert && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 3 - 1]) & s.hash_mask, 
        s.prev[str & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = str, str++, s.insert--, 
        !(s.lookahead + s.insert < 3)); ) ;
    } while (s.lookahead < 262 && 0 !== s.strm.avail_in);
}

function deflate_fast(s, flush) {
    for (var hash_head, bflush; ;) {
        if (s.lookahead < 262) {
            if (fill_window(s), s.lookahead < 262 && 0 === flush) return 1;
            if (0 === s.lookahead) break;
        }
        if (hash_head = 0, s.lookahead >= 3 && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask, 
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), 
        0 !== hash_head && s.strstart - hash_head <= s.w_size - 262 && (s.match_length = longest_match(s, hash_head)), 
        s.match_length >= 3) if (bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - 3), 
        s.lookahead -= s.match_length, s.match_length <= s.max_lazy_match && s.lookahead >= 3) {
            s.match_length--;
            do {
                s.strstart++, s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask, 
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;
            } while (0 != --s.match_length);
            s.strstart++;
        } else s.strstart += s.match_length, s.match_length = 0, s.ins_h = s.window[s.strstart], 
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; else bflush = trees._tr_tally(s, 0, s.window[s.strstart]), 
        s.lookahead--, s.strstart++;
        if (bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
    }
    return s.insert = s.strstart < 2 ? s.strstart : 2, 4 === flush ? (flush_block_only(s, !0), 
    0 === s.strm.avail_out ? 3 : 4) : s.last_lit && (flush_block_only(s, !1), 0 === s.strm.avail_out) ? 1 : 2;
}

function deflate_slow(s, flush) {
    for (var hash_head, bflush, max_insert; ;) {
        if (s.lookahead < 262) {
            if (fill_window(s), s.lookahead < 262 && 0 === flush) return 1;
            if (0 === s.lookahead) break;
        }
        if (hash_head = 0, s.lookahead >= 3 && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask, 
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), 
        s.prev_length = s.match_length, s.prev_match = s.match_start, s.match_length = 2, 
        0 !== hash_head && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - 262 && (s.match_length = longest_match(s, hash_head), 
        s.match_length <= 5 && (1 === s.strategy || 3 === s.match_length && s.strstart - s.match_start > 4096) && (s.match_length = 2)), 
        s.prev_length >= 3 && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - 3, bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - 3), 
            s.lookahead -= s.prev_length - 1, s.prev_length -= 2;
            do {
                ++s.strstart <= max_insert && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask, 
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart);
            } while (0 != --s.prev_length);
            if (s.match_available = 0, s.match_length = 2, s.strstart++, bflush && (flush_block_only(s, !1), 
            0 === s.strm.avail_out)) return 1;
        } else if (s.match_available) {
            if ((bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1])) && flush_block_only(s, !1), 
            s.strstart++, s.lookahead--, 0 === s.strm.avail_out) return 1;
        } else s.match_available = 1, s.strstart++, s.lookahead--;
    }
    return s.match_available && (bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]), 
    s.match_available = 0), s.insert = s.strstart < 2 ? s.strstart : 2, 4 === flush ? (flush_block_only(s, !0), 
    0 === s.strm.avail_out ? 3 : 4) : s.last_lit && (flush_block_only(s, !1), 0 === s.strm.avail_out) ? 1 : 2;
}

function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length, this.max_lazy = max_lazy, this.nice_length = nice_length, 
    this.max_chain = max_chain, this.func = func;
}

function DeflateState() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, 
    this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, 
    this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, 
    this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, 
    this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, 
    this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, 
    this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, 
    this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, 
    this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new utils$7.Buf16(1146), 
    this.dyn_dtree = new utils$7.Buf16(122), this.bl_tree = new utils$7.Buf16(78), zero(this.dyn_ltree), 
    zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, 
    this.bl_desc = null, this.bl_count = new utils$7.Buf16(16), this.heap = new utils$7.Buf16(573), 
    zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new utils$7.Buf16(573), 
    zero(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, 
    this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, 
    this.bi_valid = 0;
}

function deflateResetKeep(strm) {
    var s;
    return strm && strm.state ? (strm.total_in = strm.total_out = 0, strm.data_type = 2, 
    (s = strm.state).pending = 0, s.pending_out = 0, s.wrap < 0 && (s.wrap = -s.wrap), 
    s.status = s.wrap ? 42 : 113, strm.adler = 2 === s.wrap ? 0 : 1, s.last_flush = 0, 
    trees._tr_init(s), 0) : err(strm, -2);
}

function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    return 0 === ret && function lm_init(s) {
        s.window_size = 2 * s.w_size, zero(s.head), s.max_lazy_match = configuration_table[s.level].max_lazy, 
        s.good_match = configuration_table[s.level].good_length, s.nice_match = configuration_table[s.level].nice_length, 
        s.max_chain_length = configuration_table[s.level].max_chain, s.strstart = 0, s.block_start = 0, 
        s.lookahead = 0, s.insert = 0, s.match_length = s.prev_length = 2, s.match_available = 0, 
        s.ins_h = 0;
    }(strm.state), ret;
}

function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) return -2;
    var wrap = 1;
    if (-1 === level && (level = 6), windowBits < 0 ? (wrap = 0, windowBits = -windowBits) : windowBits > 15 && (wrap = 2, 
    windowBits -= 16), memLevel < 1 || memLevel > 9 || 8 !== method || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > 4) return err(strm, -2);
    8 === windowBits && (windowBits = 9);
    var s = new DeflateState;
    return strm.state = s, s.strm = strm, s.wrap = wrap, s.gzhead = null, s.w_bits = windowBits, 
    s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = memLevel + 7, s.hash_size = 1 << s.hash_bits, 
    s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + 3 - 1) / 3), s.window = new utils$7.Buf8(2 * s.w_size), 
    s.head = new utils$7.Buf16(s.hash_size), s.prev = new utils$7.Buf16(s.w_size), s.lit_bufsize = 1 << memLevel + 6, 
    s.pending_buf_size = 4 * s.lit_bufsize, s.pending_buf = new utils$7.Buf8(s.pending_buf_size), 
    s.d_buf = 1 * s.lit_bufsize, s.l_buf = 3 * s.lit_bufsize, s.level = level, s.strategy = strategy, 
    s.method = method, deflateReset(strm);
}

configuration_table = [ new Config(0, 0, 0, 0, (function deflate_stored(s, flush) {
    var max_block_size = 0xffff;
    for (max_block_size > s.pending_buf_size - 5 && (max_block_size = s.pending_buf_size - 5); ;) {
        if (s.lookahead <= 1) {
            if (fill_window(s), 0 === s.lookahead && 0 === flush) return 1;
            if (0 === s.lookahead) break;
        }
        s.strstart += s.lookahead, s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if ((0 === s.strstart || s.strstart >= max_start) && (s.lookahead = s.strstart - max_start, 
        s.strstart = max_start, flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
        if (s.strstart - s.block_start >= s.w_size - 262 && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
    }
    return s.insert = 0, 4 === flush ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? 3 : 4) : (s.strstart > s.block_start && (flush_block_only(s, !1), 
    s.strm.avail_out), 1);
})), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow) ], 
deflate$3.deflateInit = function deflateInit(strm, level) {
    return deflateInit2(strm, level, 8, 15, 8, 0);
}, deflate$3.deflateInit2 = deflateInit2, deflate$3.deflateReset = deflateReset, 
deflate$3.deflateResetKeep = deflateResetKeep, deflate$3.deflateSetHeader = function deflateSetHeader(strm, head) {
    return strm && strm.state ? 2 !== strm.state.wrap ? -2 : (strm.state.gzhead = head, 
    0) : -2;
}, deflate$3.deflate = function deflate$2(strm, flush) {
    var old_flush, s, beg, val;
    if (!strm || !strm.state || flush > 5 || flush < 0) return strm ? err(strm, -2) : -2;
    if (s = strm.state, !strm.output || !strm.input && 0 !== strm.avail_in || 666 === s.status && 4 !== flush) return err(strm, 0 === strm.avail_out ? -5 : -2);
    if (s.strm = strm, old_flush = s.last_flush, s.last_flush = flush, 42 === s.status) if (2 === s.wrap) strm.adler = 0, 
    put_byte(s, 31), put_byte(s, 139), put_byte(s, 8), s.gzhead ? (put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (s.gzhead.extra ? 4 : 0) + (s.gzhead.name ? 8 : 0) + (s.gzhead.comment ? 16 : 0)), 
    put_byte(s, 0xff & s.gzhead.time), put_byte(s, s.gzhead.time >> 8 & 0xff), put_byte(s, s.gzhead.time >> 16 & 0xff), 
    put_byte(s, s.gzhead.time >> 24 & 0xff), put_byte(s, 9 === s.level ? 2 : s.strategy >= 2 || s.level < 2 ? 4 : 0), 
    put_byte(s, 0xff & s.gzhead.os), s.gzhead.extra && s.gzhead.extra.length && (put_byte(s, 0xff & s.gzhead.extra.length), 
    put_byte(s, s.gzhead.extra.length >> 8 & 0xff)), s.gzhead.hcrc && (strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending, 0)), 
    s.gzindex = 0, s.status = 69) : (put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), 
    put_byte(s, 0), put_byte(s, 0), put_byte(s, 9 === s.level ? 2 : s.strategy >= 2 || s.level < 2 ? 4 : 0), 
    put_byte(s, 3), s.status = 113); else {
        var header = 8 + (s.w_bits - 8 << 4) << 8;
        header |= (s.strategy >= 2 || s.level < 2 ? 0 : s.level < 6 ? 1 : 6 === s.level ? 2 : 3) << 6, 
        0 !== s.strstart && (header |= 32), header += 31 - header % 31, s.status = 113, 
        putShortMSB(s, header), 0 !== s.strstart && (putShortMSB(s, strm.adler >>> 16), 
        putShortMSB(s, 0xffff & strm.adler)), strm.adler = 1;
    }
    if (69 === s.status) if (s.gzhead.extra) {
        for (beg = s.pending; s.gzindex < (0xffff & s.gzhead.extra.length) && (s.pending !== s.pending_buf_size || (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg)), 
        flush_pending(strm), beg = s.pending, s.pending !== s.pending_buf_size)); ) put_byte(s, 0xff & s.gzhead.extra[s.gzindex]), 
        s.gzindex++;
        s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg)), 
        s.gzindex === s.gzhead.extra.length && (s.gzindex = 0, s.status = 73);
    } else s.status = 73;
    if (73 === s.status) if (s.gzhead.name) {
        beg = s.pending;
        do {
            if (s.pending === s.pending_buf_size && (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg)), 
            flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size)) {
                val = 1;
                break;
            }
            val = s.gzindex < s.gzhead.name.length ? 0xff & s.gzhead.name.charCodeAt(s.gzindex++) : 0, 
            put_byte(s, val);
        } while (0 !== val);
        s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg)), 
        0 === val && (s.gzindex = 0, s.status = 91);
    } else s.status = 91;
    if (91 === s.status) if (s.gzhead.comment) {
        beg = s.pending;
        do {
            if (s.pending === s.pending_buf_size && (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg)), 
            flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size)) {
                val = 1;
                break;
            }
            val = s.gzindex < s.gzhead.comment.length ? 0xff & s.gzhead.comment.charCodeAt(s.gzindex++) : 0, 
            put_byte(s, val);
        } while (0 !== val);
        s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg)), 
        0 === val && (s.status = 103);
    } else s.status = 103;
    if (103 === s.status && (s.gzhead.hcrc ? (s.pending + 2 > s.pending_buf_size && flush_pending(strm), 
    s.pending + 2 <= s.pending_buf_size && (put_byte(s, 0xff & strm.adler), put_byte(s, strm.adler >> 8 & 0xff), 
    strm.adler = 0, s.status = 113)) : s.status = 113), 0 !== s.pending) {
        if (flush_pending(strm), 0 === strm.avail_out) return s.last_flush = -1, 0;
    } else if (0 === strm.avail_in && rank(flush) <= rank(old_flush) && 4 !== flush) return err(strm, -5);
    if (666 === s.status && 0 !== strm.avail_in) return err(strm, -5);
    if (0 !== strm.avail_in || 0 !== s.lookahead || 0 !== flush && 666 !== s.status) {
        var bstate = 2 === s.strategy ? function deflate_huff(s, flush) {
            for (var bflush; ;) {
                if (0 === s.lookahead && (fill_window(s), 0 === s.lookahead)) {
                    if (0 === flush) return 1;
                    break;
                }
                if (s.match_length = 0, bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, 
                s.strstart++, bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
            }
            return s.insert = 0, 4 === flush ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? 3 : 4) : s.last_lit && (flush_block_only(s, !1), 
            0 === s.strm.avail_out) ? 1 : 2;
        }(s, flush) : 3 === s.strategy ? function deflate_rle(s, flush) {
            for (var bflush, prev, scan, strend, _win = s.window; ;) {
                if (s.lookahead <= 258) {
                    if (fill_window(s), s.lookahead <= 258 && 0 === flush) return 1;
                    if (0 === s.lookahead) break;
                }
                if (s.match_length = 0, s.lookahead >= 3 && s.strstart > 0 && (prev = _win[scan = s.strstart - 1]) === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                    strend = s.strstart + 258;
                    do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                    s.match_length = 258 - (strend - scan), s.match_length > s.lookahead && (s.match_length = s.lookahead);
                }
                if (s.match_length >= 3 ? (bflush = trees._tr_tally(s, 1, s.match_length - 3), s.lookahead -= s.match_length, 
                s.strstart += s.match_length, s.match_length = 0) : (bflush = trees._tr_tally(s, 0, s.window[s.strstart]), 
                s.lookahead--, s.strstart++), bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
            }
            return s.insert = 0, 4 === flush ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? 3 : 4) : s.last_lit && (flush_block_only(s, !1), 
            0 === s.strm.avail_out) ? 1 : 2;
        }(s, flush) : configuration_table[s.level].func(s, flush);
        if (3 !== bstate && 4 !== bstate || (s.status = 666), 1 === bstate || 3 === bstate) return 0 === strm.avail_out && (s.last_flush = -1), 
        0;
        if (2 === bstate && (1 === flush ? trees._tr_align(s) : 5 !== flush && (trees._tr_stored_block(s, 0, 0, !1), 
        3 === flush && (zero(s.head), 0 === s.lookahead && (s.strstart = 0, s.block_start = 0, 
        s.insert = 0))), flush_pending(strm), 0 === strm.avail_out)) return s.last_flush = -1, 
        0;
    }
    return 4 !== flush ? 0 : s.wrap <= 0 ? 1 : (2 === s.wrap ? (put_byte(s, 0xff & strm.adler), 
    put_byte(s, strm.adler >> 8 & 0xff), put_byte(s, strm.adler >> 16 & 0xff), put_byte(s, strm.adler >> 24 & 0xff), 
    put_byte(s, 0xff & strm.total_in), put_byte(s, strm.total_in >> 8 & 0xff), put_byte(s, strm.total_in >> 16 & 0xff), 
    put_byte(s, strm.total_in >> 24 & 0xff)) : (putShortMSB(s, strm.adler >>> 16), putShortMSB(s, 0xffff & strm.adler)), 
    flush_pending(strm), s.wrap > 0 && (s.wrap = -s.wrap), 0 !== s.pending ? 0 : 1);
}, deflate$3.deflateEnd = function deflateEnd(strm) {
    var status;
    return strm && strm.state ? 42 !== (status = strm.state.status) && 69 !== status && 73 !== status && 91 !== status && 103 !== status && 113 !== status && 666 !== status ? err(strm, -2) : (strm.state = null, 
    113 === status ? err(strm, -3) : 0) : -2;
}, deflate$3.deflateSetDictionary = function deflateSetDictionary(strm, dictionary) {
    var s, str, n, wrap, avail, next, input, tmpDict, dictLength = dictionary.length;
    if (!strm || !strm.state) return -2;
    if (2 === (wrap = (s = strm.state).wrap) || 1 === wrap && 42 !== s.status || s.lookahead) return -2;
    for (1 === wrap && (strm.adler = adler32$1(strm.adler, dictionary, dictLength, 0)), 
    s.wrap = 0, dictLength >= s.w_size && (0 === wrap && (zero(s.head), s.strstart = 0, 
    s.block_start = 0, s.insert = 0), tmpDict = new utils$7.Buf8(s.w_size), utils$7.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0), 
    dictionary = tmpDict, dictLength = s.w_size), avail = strm.avail_in, next = strm.next_in, 
    input = strm.input, strm.avail_in = dictLength, strm.next_in = 0, strm.input = dictionary, 
    fill_window(s); s.lookahead >= 3; ) {
        str = s.strstart, n = s.lookahead - 2;
        do {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 3 - 1]) & s.hash_mask, s.prev[str & s.w_mask] = s.head[s.ins_h], 
            s.head[s.ins_h] = str, str++;
        } while (--n);
        s.strstart = str, s.lookahead = 2, fill_window(s);
    }
    return s.strstart += s.lookahead, s.block_start = s.strstart, s.insert = s.lookahead, 
    s.lookahead = 0, s.match_length = s.prev_length = 2, s.match_available = 0, strm.next_in = next, 
    strm.input = input, strm.avail_in = avail, s.wrap = wrap, 0;
}, deflate$3.deflateInfo = "pako deflate (from Nodeca project)";

var strings$2 = {}, utils$6 = common, STR_APPLY_OK = !0, STR_APPLY_UIA_OK = !0;

try {
    String.fromCharCode.apply(null, [ 0 ]);
} catch (__) {
    STR_APPLY_OK = !1;
}

try {
    String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
    STR_APPLY_UIA_OK = !1;
}

for (var _utf8len = new utils$6.Buf8(256), q = 0; q < 256; q++) _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;

function buf2binstring(buf, len) {
    if (len < 65534 && (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK)) return String.fromCharCode.apply(null, utils$6.shrinkBuf(buf, len));
    for (var result = "", i = 0; i < len; i++) result += String.fromCharCode(buf[i]);
    return result;
}

_utf8len[254] = _utf8len[254] = 1, strings$2.string2buf = function(str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) 0xd800 == (0xfc00 & (c = str.charCodeAt(m_pos))) && m_pos + 1 < str_len && 0xdc00 == (0xfc00 & (c2 = str.charCodeAt(m_pos + 1))) && (c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00), 
    m_pos++), buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    for (buf = new utils$6.Buf8(buf_len), i = 0, m_pos = 0; i < buf_len; m_pos++) 0xd800 == (0xfc00 & (c = str.charCodeAt(m_pos))) && m_pos + 1 < str_len && 0xdc00 == (0xfc00 & (c2 = str.charCodeAt(m_pos + 1))) && (c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00), 
    m_pos++), c < 0x80 ? buf[i++] = c : c < 0x800 ? (buf[i++] = 0xC0 | c >>> 6, buf[i++] = 0x80 | 0x3f & c) : c < 0x10000 ? (buf[i++] = 0xE0 | c >>> 12, 
    buf[i++] = 0x80 | c >>> 6 & 0x3f, buf[i++] = 0x80 | 0x3f & c) : (buf[i++] = 0xf0 | c >>> 18, 
    buf[i++] = 0x80 | c >>> 12 & 0x3f, buf[i++] = 0x80 | c >>> 6 & 0x3f, buf[i++] = 0x80 | 0x3f & c);
    return buf;
}, strings$2.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
}, strings$2.binstring2buf = function(str) {
    for (var buf = new utils$6.Buf8(str.length), i = 0, len = buf.length; i < len; i++) buf[i] = str.charCodeAt(i);
    return buf;
}, strings$2.buf2string = function(buf, max) {
    var i, out, c, c_len, len = max || buf.length, utf16buf = new Array(2 * len);
    for (out = 0, i = 0; i < len; ) if ((c = buf[i++]) < 0x80) utf16buf[out++] = c; else if ((c_len = _utf8len[c]) > 4) utf16buf[out++] = 0xfffd, 
    i += c_len - 1; else {
        for (c &= 2 === c_len ? 0x1f : 3 === c_len ? 0x0f : 0x07; c_len > 1 && i < len; ) c = c << 6 | 0x3f & buf[i++], 
        c_len--;
        c_len > 1 ? utf16buf[out++] = 0xfffd : c < 0x10000 ? utf16buf[out++] = c : (c -= 0x10000, 
        utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff, utf16buf[out++] = 0xdc00 | 0x3ff & c);
    }
    return buf2binstring(utf16buf, out);
}, strings$2.utf8border = function(buf, max) {
    var pos;
    for ((max = max || buf.length) > buf.length && (max = buf.length), pos = max - 1; pos >= 0 && 0x80 == (0xC0 & buf[pos]); ) pos--;
    return pos < 0 || 0 === pos ? max : pos + _utf8len[buf[pos]] > max ? pos : max;
};

var zstream = function ZStream$2() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, 
    this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, 
    this.data_type = 2, this.adler = 0;
}, zlib_deflate = deflate$3, utils$5 = common, strings$1 = strings$2, msg$1 = messages, ZStream$1 = zstream, toString$1 = Object.prototype.toString;

function Deflate(options) {
    if (!(this instanceof Deflate)) return new Deflate(options);
    this.options = utils$5.assign({
        level: -1,
        method: 8,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: 0,
        to: ""
    }, options || {});
    var opt = this.options;
    opt.raw && opt.windowBits > 0 ? opt.windowBits = -opt.windowBits : opt.gzip && opt.windowBits > 0 && opt.windowBits < 16 && (opt.windowBits += 16), 
    this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new ZStream$1, 
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (0 !== status) throw new Error(msg$1[status]);
    if (opt.header && zlib_deflate.deflateSetHeader(this.strm, opt.header), opt.dictionary) {
        var dict;
        if (dict = "string" == typeof opt.dictionary ? strings$1.string2buf(opt.dictionary) : "[object ArrayBuffer]" === toString$1.call(opt.dictionary) ? new Uint8Array(opt.dictionary) : opt.dictionary, 
        0 !== (status = zlib_deflate.deflateSetDictionary(this.strm, dict))) throw new Error(msg$1[status]);
        this._dict_set = !0;
    }
}

function deflate$1(input, options) {
    var deflator = new Deflate(options);
    if (deflator.push(input, !0), deflator.err) throw deflator.msg || msg$1[deflator.err];
    return deflator.result;
}

Deflate.prototype.push = function(data, mode) {
    var status, _mode, strm = this.strm, chunkSize = this.options.chunkSize;
    if (this.ended) return !1;
    _mode = mode === ~~mode ? mode : !0 === mode ? 4 : 0, "string" == typeof data ? strm.input = strings$1.string2buf(data) : "[object ArrayBuffer]" === toString$1.call(data) ? strm.input = new Uint8Array(data) : strm.input = data, 
    strm.next_in = 0, strm.avail_in = strm.input.length;
    do {
        if (0 === strm.avail_out && (strm.output = new utils$5.Buf8(chunkSize), strm.next_out = 0, 
        strm.avail_out = chunkSize), 1 !== (status = zlib_deflate.deflate(strm, _mode)) && 0 !== status) return this.onEnd(status), 
        this.ended = !0, !1;
        0 !== strm.avail_out && (0 !== strm.avail_in || 4 !== _mode && 2 !== _mode) || ("string" === this.options.to ? this.onData(strings$1.buf2binstring(utils$5.shrinkBuf(strm.output, strm.next_out))) : this.onData(utils$5.shrinkBuf(strm.output, strm.next_out)));
    } while ((strm.avail_in > 0 || 0 === strm.avail_out) && 1 !== status);
    return 4 === _mode ? (status = zlib_deflate.deflateEnd(this.strm), this.onEnd(status), 
    this.ended = !0, 0 === status) : 2 !== _mode || (this.onEnd(0), strm.avail_out = 0, 
    !0);
}, Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
}, Deflate.prototype.onEnd = function(status) {
    0 === status && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = utils$5.flattenChunks(this.chunks)), 
    this.chunks = [], this.err = status, this.msg = this.strm.msg;
}, deflate$4.Deflate = Deflate, deflate$4.deflate = deflate$1, deflate$4.deflateRaw = function deflateRaw(input, options) {
    return (options = options || {}).raw = !0, deflate$1(input, options);
}, deflate$4.gzip = function gzip(input, options) {
    return (options = options || {}).gzip = !0, deflate$1(input, options);
};

var inflate$4 = {}, inflate$3 = {}, utils$4 = common, lbase = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ], lext = [ 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78 ], dbase = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 ], dext = [ 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64 ], utils$3 = common, adler32 = adler32_1, crc32 = crc32_1, inflate_fast = function inflate_fast(strm, start) {
    var state, _in, last, _out, beg, end, dmax, wsize, whave, wnext, s_window, hold, bits, lcode, dcode, lmask, dmask, here, op, len, dist, from, from_source, input, output;
    state = strm.state, _in = strm.next_in, input = strm.input, last = _in + (strm.avail_in - 5), 
    _out = strm.next_out, output = strm.output, beg = _out - (start - strm.avail_out), 
    end = _out + (strm.avail_out - 257), dmax = state.dmax, wsize = state.wsize, whave = state.whave, 
    wnext = state.wnext, s_window = state.window, hold = state.hold, bits = state.bits, 
    lcode = state.lencode, dcode = state.distcode, lmask = (1 << state.lenbits) - 1, 
    dmask = (1 << state.distbits) - 1;
    top: do {
        bits < 15 && (hold += input[_in++] << bits, bits += 8, hold += input[_in++] << bits, 
        bits += 8), here = lcode[hold & lmask];
        dolen: for (;;) {
            if (hold >>>= op = here >>> 24, bits -= op, 0 == (op = here >>> 16 & 0xff)) output[_out++] = 0xffff & here; else {
                if (!(16 & op)) {
                    if (0 == (64 & op)) {
                        here = lcode[(0xffff & here) + (hold & (1 << op) - 1)];
                        continue dolen;
                    }
                    if (32 & op) {
                        state.mode = 12;
                        break top;
                    }
                    strm.msg = "invalid literal/length code", state.mode = 30;
                    break top;
                }
                len = 0xffff & here, (op &= 15) && (bits < op && (hold += input[_in++] << bits, 
                bits += 8), len += hold & (1 << op) - 1, hold >>>= op, bits -= op), bits < 15 && (hold += input[_in++] << bits, 
                bits += 8, hold += input[_in++] << bits, bits += 8), here = dcode[hold & dmask];
                dodist: for (;;) {
                    if (hold >>>= op = here >>> 24, bits -= op, !(16 & (op = here >>> 16 & 0xff))) {
                        if (0 == (64 & op)) {
                            here = dcode[(0xffff & here) + (hold & (1 << op) - 1)];
                            continue dodist;
                        }
                        strm.msg = "invalid distance code", state.mode = 30;
                        break top;
                    }
                    if (dist = 0xffff & here, bits < (op &= 15) && (hold += input[_in++] << bits, (bits += 8) < op && (hold += input[_in++] << bits, 
                    bits += 8)), (dist += hold & (1 << op) - 1) > dmax) {
                        strm.msg = "invalid distance too far back", state.mode = 30;
                        break top;
                    }
                    if (hold >>>= op, bits -= op, dist > (op = _out - beg)) {
                        if ((op = dist - op) > whave && state.sane) {
                            strm.msg = "invalid distance too far back", state.mode = 30;
                            break top;
                        }
                        if (from = 0, from_source = s_window, 0 === wnext) {
                            if (from += wsize - op, op < len) {
                                len -= op;
                                do {
                                    output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist, from_source = output;
                            }
                        } else if (wnext < op) {
                            if (from += wsize + wnext - op, (op -= wnext) < len) {
                                len -= op;
                                do {
                                    output[_out++] = s_window[from++];
                                } while (--op);
                                if (from = 0, wnext < len) {
                                    len -= op = wnext;
                                    do {
                                        output[_out++] = s_window[from++];
                                    } while (--op);
                                    from = _out - dist, from_source = output;
                                }
                            }
                        } else if (from += wnext - op, op < len) {
                            len -= op;
                            do {
                                output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist, from_source = output;
                        }
                        for (;len > 2; ) output[_out++] = from_source[from++], output[_out++] = from_source[from++], 
                        output[_out++] = from_source[from++], len -= 3;
                        len && (output[_out++] = from_source[from++], len > 1 && (output[_out++] = from_source[from++]));
                    } else {
                        from = _out - dist;
                        do {
                            output[_out++] = output[from++], output[_out++] = output[from++], output[_out++] = output[from++], 
                            len -= 3;
                        } while (len > 2);
                        len && (output[_out++] = output[from++], len > 1 && (output[_out++] = output[from++]));
                    }
                    break;
                }
            }
            break;
        }
    } while (_in < last && _out < end);
    _in -= len = bits >> 3, hold &= (1 << (bits -= len << 3)) - 1, strm.next_in = _in, 
    strm.next_out = _out, strm.avail_in = _in < last ? last - _in + 5 : 5 - (_in - last), 
    strm.avail_out = _out < end ? end - _out + 257 : 257 - (_out - end), state.hold = hold, 
    state.bits = bits;
}, inflate_table = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    var incr, fill, low, mask, next, end, here_bits, here_op, here_val, bits = opts.bits, len = 0, sym = 0, min = 0, max = 0, root = 0, curr = 0, drop = 0, left = 0, used = 0, huff = 0, base = null, base_index = 0, count = new utils$4.Buf16(16), offs = new utils$4.Buf16(16), extra = null, extra_index = 0;
    for (len = 0; len <= 15; len++) count[len] = 0;
    for (sym = 0; sym < codes; sym++) count[lens[lens_index + sym]]++;
    for (root = bits, max = 15; max >= 1 && 0 === count[max]; max--) ;
    if (root > max && (root = max), 0 === max) return table[table_index++] = 20971520, 
    table[table_index++] = 20971520, opts.bits = 1, 0;
    for (min = 1; min < max && 0 === count[min]; min++) ;
    for (root < min && (root = min), left = 1, len = 1; len <= 15; len++) if (left <<= 1, 
    (left -= count[len]) < 0) return -1;
    if (left > 0 && (0 === type || 1 !== max)) return -1;
    for (offs[1] = 0, len = 1; len < 15; len++) offs[len + 1] = offs[len] + count[len];
    for (sym = 0; sym < codes; sym++) 0 !== lens[lens_index + sym] && (work[offs[lens[lens_index + sym]]++] = sym);
    if (0 === type ? (base = extra = work, end = 19) : 1 === type ? (base = lbase, base_index -= 257, 
    extra = lext, extra_index -= 257, end = 256) : (base = dbase, extra = dext, end = -1), 
    huff = 0, sym = 0, len = min, next = table_index, curr = root, drop = 0, low = -1, 
    mask = (used = 1 << root) - 1, 1 === type && used > 852 || 2 === type && used > 592) return 1;
    for (;;) {
        here_bits = len - drop, work[sym] < end ? (here_op = 0, here_val = work[sym]) : work[sym] > end ? (here_op = extra[extra_index + work[sym]], 
        here_val = base[base_index + work[sym]]) : (here_op = 96, here_val = 0), incr = 1 << len - drop, 
        min = fill = 1 << curr;
        do {
            table[next + (huff >> drop) + (fill -= incr)] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (0 !== fill);
        for (incr = 1 << len - 1; huff & incr; ) incr >>= 1;
        if (0 !== incr ? (huff &= incr - 1, huff += incr) : huff = 0, sym++, 0 == --count[len]) {
            if (len === max) break;
            len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
            for (0 === drop && (drop = root), next += min, left = 1 << (curr = len - drop); curr + drop < max && !((left -= count[curr + drop]) <= 0); ) curr++, 
            left <<= 1;
            if (used += 1 << curr, 1 === type && used > 852 || 2 === type && used > 592) return 1;
            table[low = huff & mask] = root << 24 | curr << 16 | next - table_index | 0;
        }
    }
    return 0 !== huff && (table[next + huff] = len - drop << 24 | 64 << 16 | 0), opts.bits = root, 
    0;
};

function zswap32(q) {
    return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((0xff00 & q) << 8) + ((0xff & q) << 24);
}

function InflateState() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, 
    this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, 
    this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, 
    this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, 
    this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, 
    this.ndist = 0, this.have = 0, this.next = null, this.lens = new utils$3.Buf16(320), 
    this.work = new utils$3.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, 
    this.back = 0, this.was = 0;
}

function inflateResetKeep(strm) {
    var state;
    return strm && strm.state ? (state = strm.state, strm.total_in = strm.total_out = state.total = 0, 
    strm.msg = "", state.wrap && (strm.adler = 1 & state.wrap), state.mode = 1, state.last = 0, 
    state.havedict = 0, state.dmax = 32768, state.head = null, state.hold = 0, state.bits = 0, 
    state.lencode = state.lendyn = new utils$3.Buf32(852), state.distcode = state.distdyn = new utils$3.Buf32(592), 
    state.sane = 1, state.back = -1, 0) : -2;
}

function inflateReset(strm) {
    var state;
    return strm && strm.state ? ((state = strm.state).wsize = 0, state.whave = 0, state.wnext = 0, 
    inflateResetKeep(strm)) : -2;
}

function inflateReset2(strm, windowBits) {
    var wrap, state;
    return strm && strm.state ? (state = strm.state, windowBits < 0 ? (wrap = 0, windowBits = -windowBits) : (wrap = 1 + (windowBits >> 4), 
    windowBits < 48 && (windowBits &= 15)), windowBits && (windowBits < 8 || windowBits > 15) ? -2 : (null !== state.window && state.wbits !== windowBits && (state.window = null), 
    state.wrap = wrap, state.wbits = windowBits, inflateReset(strm))) : -2;
}

function inflateInit2(strm, windowBits) {
    var ret, state;
    return strm ? (state = new InflateState, strm.state = state, state.window = null, 
    0 !== (ret = inflateReset2(strm, windowBits)) && (strm.state = null), ret) : -2;
}

var lenfix, distfix, virgin = !0;

function fixedtables(state) {
    if (virgin) {
        var sym;
        for (lenfix = new utils$3.Buf32(512), distfix = new utils$3.Buf32(32), sym = 0; sym < 144; ) state.lens[sym++] = 8;
        for (;sym < 256; ) state.lens[sym++] = 9;
        for (;sym < 280; ) state.lens[sym++] = 7;
        for (;sym < 288; ) state.lens[sym++] = 8;
        for (inflate_table(1, state.lens, 0, 288, lenfix, 0, state.work, {
            bits: 9
        }), sym = 0; sym < 32; ) state.lens[sym++] = 5;
        inflate_table(2, state.lens, 0, 32, distfix, 0, state.work, {
            bits: 5
        }), virgin = !1;
    }
    state.lencode = lenfix, state.lenbits = 9, state.distcode = distfix, state.distbits = 5;
}

function updatewindow(strm, src, end, copy) {
    var dist, state = strm.state;
    return null === state.window && (state.wsize = 1 << state.wbits, state.wnext = 0, 
    state.whave = 0, state.window = new utils$3.Buf8(state.wsize)), copy >= state.wsize ? (utils$3.arraySet(state.window, src, end - state.wsize, state.wsize, 0), 
    state.wnext = 0, state.whave = state.wsize) : ((dist = state.wsize - state.wnext) > copy && (dist = copy), 
    utils$3.arraySet(state.window, src, end - copy, dist, state.wnext), (copy -= dist) ? (utils$3.arraySet(state.window, src, end - copy, copy, 0), 
    state.wnext = copy, state.whave = state.wsize) : (state.wnext += dist, state.wnext === state.wsize && (state.wnext = 0), 
    state.whave < state.wsize && (state.whave += dist))), 0;
}

inflate$3.inflateReset = inflateReset, inflate$3.inflateReset2 = inflateReset2, 
inflate$3.inflateResetKeep = inflateResetKeep, inflate$3.inflateInit = function inflateInit(strm) {
    return inflateInit2(strm, 15);
}, inflate$3.inflateInit2 = inflateInit2, inflate$3.inflate = function inflate$2(strm, flush) {
    var state, input, output, next, put, have, left, hold, bits, _in, _out, copy, from, from_source, here_bits, here_op, here_val, last_bits, last_op, last_val, len, ret, opts, n, here = 0, hbuf = new utils$3.Buf8(4), order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
    if (!strm || !strm.state || !strm.output || !strm.input && 0 !== strm.avail_in) return -2;
    12 === (state = strm.state).mode && (state.mode = 13), put = strm.next_out, output = strm.output, 
    left = strm.avail_out, next = strm.next_in, input = strm.input, have = strm.avail_in, 
    hold = state.hold, bits = state.bits, _in = have, _out = left, ret = 0;
    inf_leave: for (;;) switch (state.mode) {
      case 1:
        if (0 === state.wrap) {
            state.mode = 13;
            break;
        }
        for (;bits < 16; ) {
            if (0 === have) break inf_leave;
            have--, hold += input[next++] << bits, bits += 8;
        }
        if (2 & state.wrap && 0x8b1f === hold) {
            state.check = 0, hbuf[0] = 0xff & hold, hbuf[1] = hold >>> 8 & 0xff, state.check = crc32(state.check, hbuf, 2, 0), 
            hold = 0, bits = 0, state.mode = 2;
            break;
        }
        if (state.flags = 0, state.head && (state.head.done = !1), !(1 & state.wrap) || (((0xff & hold) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check", state.mode = 30;
            break;
        }
        if (8 != (0x0f & hold)) {
            strm.msg = "unknown compression method", state.mode = 30;
            break;
        }
        if (bits -= 4, len = 8 + (0x0f & (hold >>>= 4)), 0 === state.wbits) state.wbits = len; else if (len > state.wbits) {
            strm.msg = "invalid window size", state.mode = 30;
            break;
        }
        state.dmax = 1 << len, strm.adler = state.check = 1, state.mode = 0x200 & hold ? 10 : 12, 
        hold = 0, bits = 0;
        break;

      case 2:
        for (;bits < 16; ) {
            if (0 === have) break inf_leave;
            have--, hold += input[next++] << bits, bits += 8;
        }
        if (state.flags = hold, 8 != (0xff & state.flags)) {
            strm.msg = "unknown compression method", state.mode = 30;
            break;
        }
        if (0xe000 & state.flags) {
            strm.msg = "unknown header flags set", state.mode = 30;
            break;
        }
        state.head && (state.head.text = hold >> 8 & 1), 0x0200 & state.flags && (hbuf[0] = 0xff & hold, 
        hbuf[1] = hold >>> 8 & 0xff, state.check = crc32(state.check, hbuf, 2, 0)), hold = 0, 
        bits = 0, state.mode = 3;

      case 3:
        for (;bits < 32; ) {
            if (0 === have) break inf_leave;
            have--, hold += input[next++] << bits, bits += 8;
        }
        state.head && (state.head.time = hold), 0x0200 & state.flags && (hbuf[0] = 0xff & hold, 
        hbuf[1] = hold >>> 8 & 0xff, hbuf[2] = hold >>> 16 & 0xff, hbuf[3] = hold >>> 24 & 0xff, 
        state.check = crc32(state.check, hbuf, 4, 0)), hold = 0, bits = 0, state.mode = 4;

      case 4:
        for (;bits < 16; ) {
            if (0 === have) break inf_leave;
            have--, hold += input[next++] << bits, bits += 8;
        }
        state.head && (state.head.xflags = 0xff & hold, state.head.os = hold >> 8), 0x0200 & state.flags && (hbuf[0] = 0xff & hold, 
        hbuf[1] = hold >>> 8 & 0xff, state.check = crc32(state.check, hbuf, 2, 0)), hold = 0, 
        bits = 0, state.mode = 5;

      case 5:
        if (0x0400 & state.flags) {
            for (;bits < 16; ) {
                if (0 === have) break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
            }
            state.length = hold, state.head && (state.head.extra_len = hold), 0x0200 & state.flags && (hbuf[0] = 0xff & hold, 
            hbuf[1] = hold >>> 8 & 0xff, state.check = crc32(state.check, hbuf, 2, 0)), hold = 0, 
            bits = 0;
        } else state.head && (state.head.extra = null);
        state.mode = 6;

      case 6:
        if (0x0400 & state.flags && ((copy = state.length) > have && (copy = have), copy && (state.head && (len = state.head.extra_len - state.length, 
        state.head.extra || (state.head.extra = new Array(state.head.extra_len)), utils$3.arraySet(state.head.extra, input, next, copy, len)), 
        0x0200 & state.flags && (state.check = crc32(state.check, input, copy, next)), have -= copy, 
        next += copy, state.length -= copy), state.length)) break inf_leave;
        state.length = 0, state.mode = 7;

      case 7:
        if (0x0800 & state.flags) {
            if (0 === have) break inf_leave;
            copy = 0;
            do {
                len = input[next + copy++], state.head && len && state.length < 65536 && (state.head.name += String.fromCharCode(len));
            } while (len && copy < have);
            if (0x0200 & state.flags && (state.check = crc32(state.check, input, copy, next)), 
            have -= copy, next += copy, len) break inf_leave;
        } else state.head && (state.head.name = null);
        state.length = 0, state.mode = 8;

      case 8:
        if (0x1000 & state.flags) {
            if (0 === have) break inf_leave;
            copy = 0;
            do {
                len = input[next + copy++], state.head && len && state.length < 65536 && (state.head.comment += String.fromCharCode(len));
            } while (len && copy < have);
            if (0x0200 & state.flags && (state.check = crc32(state.check, input, copy, next)), 
            have -= copy, next += copy, len) break inf_leave;
        } else state.head && (state.head.comment = null);
        state.mode = 9;

      case 9:
        if (0x0200 & state.flags) {
            for (;bits < 16; ) {
                if (0 === have) break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
            }
            if (hold !== (0xffff & state.check)) {
                strm.msg = "header crc mismatch", state.mode = 30;
                break;
            }
            hold = 0, bits = 0;
        }
        state.head && (state.head.hcrc = state.flags >> 9 & 1, state.head.done = !0), strm.adler = state.check = 0, 
        state.mode = 12;
        break;

      case 10:
        for (;bits < 32; ) {
            if (0 === have) break inf_leave;
            have--, hold += input[next++] << bits, bits += 8;
        }
        strm.adler = state.check = zswap32(hold), hold = 0, bits = 0, state.mode = 11;

      case 11:
        if (0 === state.havedict) return strm.next_out = put, strm.avail_out = left, strm.next_in = next, 
        strm.avail_in = have, state.hold = hold, state.bits = bits, 2;
        strm.adler = state.check = 1, state.mode = 12;

      case 12:
        if (5 === flush || 6 === flush) break inf_leave;

      case 13:
        if (state.last) {
            hold >>>= 7 & bits, bits -= 7 & bits, state.mode = 27;
            break;
        }
        for (;bits < 3; ) {
            if (0 === have) break inf_leave;
            have--, hold += input[next++] << bits, bits += 8;
        }
        switch (state.last = 0x01 & hold, bits -= 1, 0x03 & (hold >>>= 1)) {
          case 0:
            state.mode = 14;
            break;

          case 1:
            if (fixedtables(state), state.mode = 20, 6 === flush) {
                hold >>>= 2, bits -= 2;
                break inf_leave;
            }
            break;

          case 2:
            state.mode = 17;
            break;

          case 3:
            strm.msg = "invalid block type", state.mode = 30;
        }
        hold >>>= 2, bits -= 2;
        break;

      case 14:
        for (hold >>>= 7 & bits, bits -= 7 & bits; bits < 32; ) {
            if (0 === have) break inf_leave;
            have--, hold += input[next++] << bits, bits += 8;
        }
        if ((0xffff & hold) != (hold >>> 16 ^ 0xffff)) {
            strm.msg = "invalid stored block lengths", state.mode = 30;
            break;
        }
        if (state.length = 0xffff & hold, hold = 0, bits = 0, state.mode = 15, 6 === flush) break inf_leave;

      case 15:
        state.mode = 16;

      case 16:
        if (copy = state.length) {
            if (copy > have && (copy = have), copy > left && (copy = left), 0 === copy) break inf_leave;
            utils$3.arraySet(output, input, next, copy, put), have -= copy, next += copy, left -= copy, 
            put += copy, state.length -= copy;
            break;
        }
        state.mode = 12;
        break;

      case 17:
        for (;bits < 14; ) {
            if (0 === have) break inf_leave;
            have--, hold += input[next++] << bits, bits += 8;
        }
        if (state.nlen = 257 + (0x1f & hold), hold >>>= 5, bits -= 5, state.ndist = 1 + (0x1f & hold), 
        hold >>>= 5, bits -= 5, state.ncode = 4 + (0x0f & hold), hold >>>= 4, bits -= 4, 
        state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols", state.mode = 30;
            break;
        }
        state.have = 0, state.mode = 18;

      case 18:
        for (;state.have < state.ncode; ) {
            for (;bits < 3; ) {
                if (0 === have) break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
            }
            state.lens[order[state.have++]] = 0x07 & hold, hold >>>= 3, bits -= 3;
        }
        for (;state.have < 19; ) state.lens[order[state.have++]] = 0;
        if (state.lencode = state.lendyn, state.lenbits = 7, opts = {
            bits: state.lenbits
        }, ret = inflate_table(0, state.lens, 0, 19, state.lencode, 0, state.work, opts), 
        state.lenbits = opts.bits, ret) {
            strm.msg = "invalid code lengths set", state.mode = 30;
            break;
        }
        state.have = 0, state.mode = 19;

      case 19:
        for (;state.have < state.nlen + state.ndist; ) {
            for (;here_op = (here = state.lencode[hold & (1 << state.lenbits) - 1]) >>> 16 & 0xff, 
            here_val = 0xffff & here, !((here_bits = here >>> 24) <= bits); ) {
                if (0 === have) break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
            }
            if (here_val < 16) hold >>>= here_bits, bits -= here_bits, state.lens[state.have++] = here_val; else {
                if (16 === here_val) {
                    for (n = here_bits + 2; bits < n; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    if (hold >>>= here_bits, bits -= here_bits, 0 === state.have) {
                        strm.msg = "invalid bit length repeat", state.mode = 30;
                        break;
                    }
                    len = state.lens[state.have - 1], copy = 3 + (0x03 & hold), hold >>>= 2, bits -= 2;
                } else if (17 === here_val) {
                    for (n = here_bits + 3; bits < n; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    bits -= here_bits, len = 0, copy = 3 + (0x07 & (hold >>>= here_bits)), hold >>>= 3, 
                    bits -= 3;
                } else {
                    for (n = here_bits + 7; bits < n; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    bits -= here_bits, len = 0, copy = 11 + (0x7f & (hold >>>= here_bits)), hold >>>= 7, 
                    bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat", state.mode = 30;
                    break;
                }
                for (;copy--; ) state.lens[state.have++] = len;
            }
        }
        if (30 === state.mode) break;
        if (0 === state.lens[256]) {
            strm.msg = "invalid code -- missing end-of-block", state.mode = 30;
            break;
        }
        if (state.lenbits = 9, opts = {
            bits: state.lenbits
        }, ret = inflate_table(1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts), 
        state.lenbits = opts.bits, ret) {
            strm.msg = "invalid literal/lengths set", state.mode = 30;
            break;
        }
        if (state.distbits = 6, state.distcode = state.distdyn, opts = {
            bits: state.distbits
        }, ret = inflate_table(2, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts), 
        state.distbits = opts.bits, ret) {
            strm.msg = "invalid distances set", state.mode = 30;
            break;
        }
        if (state.mode = 20, 6 === flush) break inf_leave;

      case 20:
        state.mode = 21;

      case 21:
        if (have >= 6 && left >= 258) {
            strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, 
            state.hold = hold, state.bits = bits, inflate_fast(strm, _out), put = strm.next_out, 
            output = strm.output, left = strm.avail_out, next = strm.next_in, input = strm.input, 
            have = strm.avail_in, hold = state.hold, bits = state.bits, 12 === state.mode && (state.back = -1);
            break;
        }
        for (state.back = 0; here_op = (here = state.lencode[hold & (1 << state.lenbits) - 1]) >>> 16 & 0xff, 
        here_val = 0xffff & here, !((here_bits = here >>> 24) <= bits); ) {
            if (0 === have) break inf_leave;
            have--, hold += input[next++] << bits, bits += 8;
        }
        if (here_op && 0 == (0xf0 & here_op)) {
            for (last_bits = here_bits, last_op = here_op, last_val = here_val; here_op = (here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)]) >>> 16 & 0xff, 
            here_val = 0xffff & here, !(last_bits + (here_bits = here >>> 24) <= bits); ) {
                if (0 === have) break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
            }
            hold >>>= last_bits, bits -= last_bits, state.back += last_bits;
        }
        if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, state.length = here_val, 
        0 === here_op) {
            state.mode = 26;
            break;
        }
        if (32 & here_op) {
            state.back = -1, state.mode = 12;
            break;
        }
        if (64 & here_op) {
            strm.msg = "invalid literal/length code", state.mode = 30;
            break;
        }
        state.extra = 15 & here_op, state.mode = 22;

      case 22:
        if (state.extra) {
            for (n = state.extra; bits < n; ) {
                if (0 === have) break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, 
            state.back += state.extra;
        }
        state.was = state.length, state.mode = 23;

      case 23:
        for (;here_op = (here = state.distcode[hold & (1 << state.distbits) - 1]) >>> 16 & 0xff, 
        here_val = 0xffff & here, !((here_bits = here >>> 24) <= bits); ) {
            if (0 === have) break inf_leave;
            have--, hold += input[next++] << bits, bits += 8;
        }
        if (0 == (0xf0 & here_op)) {
            for (last_bits = here_bits, last_op = here_op, last_val = here_val; here_op = (here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)]) >>> 16 & 0xff, 
            here_val = 0xffff & here, !(last_bits + (here_bits = here >>> 24) <= bits); ) {
                if (0 === have) break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
            }
            hold >>>= last_bits, bits -= last_bits, state.back += last_bits;
        }
        if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, 64 & here_op) {
            strm.msg = "invalid distance code", state.mode = 30;
            break;
        }
        state.offset = here_val, state.extra = 15 & here_op, state.mode = 24;

      case 24:
        if (state.extra) {
            for (n = state.extra; bits < n; ) {
                if (0 === have) break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, 
            state.back += state.extra;
        }
        if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back", state.mode = 30;
            break;
        }
        state.mode = 25;

      case 25:
        if (0 === left) break inf_leave;
        if (copy = _out - left, state.offset > copy) {
            if ((copy = state.offset - copy) > state.whave && state.sane) {
                strm.msg = "invalid distance too far back", state.mode = 30;
                break;
            }
            copy > state.wnext ? (copy -= state.wnext, from = state.wsize - copy) : from = state.wnext - copy, 
            copy > state.length && (copy = state.length), from_source = state.window;
        } else from_source = output, from = put - state.offset, copy = state.length;
        copy > left && (copy = left), left -= copy, state.length -= copy;
        do {
            output[put++] = from_source[from++];
        } while (--copy);
        0 === state.length && (state.mode = 21);
        break;

      case 26:
        if (0 === left) break inf_leave;
        output[put++] = state.length, left--, state.mode = 21;
        break;

      case 27:
        if (state.wrap) {
            for (;bits < 32; ) {
                if (0 === have) break inf_leave;
                have--, hold |= input[next++] << bits, bits += 8;
            }
            if (_out -= left, strm.total_out += _out, state.total += _out, _out && (strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out)), 
            _out = left, (state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check", state.mode = 30;
                break;
            }
            hold = 0, bits = 0;
        }
        state.mode = 28;

      case 28:
        if (state.wrap && state.flags) {
            for (;bits < 32; ) {
                if (0 === have) break inf_leave;
                have--, hold += input[next++] << bits, bits += 8;
            }
            if (hold !== (0xffffffff & state.total)) {
                strm.msg = "incorrect length check", state.mode = 30;
                break;
            }
            hold = 0, bits = 0;
        }
        state.mode = 29;

      case 29:
        ret = 1;
        break inf_leave;

      case 30:
        ret = -3;
        break inf_leave;

      case 31:
        return -4;

      default:
        return -2;
    }
    return strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, 
    state.hold = hold, state.bits = bits, (state.wsize || _out !== strm.avail_out && state.mode < 30 && (state.mode < 27 || 4 !== flush)) && updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out), 
    _in -= strm.avail_in, _out -= strm.avail_out, strm.total_in += _in, strm.total_out += _out, 
    state.total += _out, state.wrap && _out && (strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out)), 
    strm.data_type = state.bits + (state.last ? 64 : 0) + (12 === state.mode ? 128 : 0) + (20 === state.mode || 15 === state.mode ? 256 : 0), 
    (0 === _in && 0 === _out || 4 === flush) && 0 === ret && (ret = -5), ret;
}, inflate$3.inflateEnd = function inflateEnd(strm) {
    if (!strm || !strm.state) return -2;
    var state = strm.state;
    return state.window && (state.window = null), strm.state = null, 0;
}, inflate$3.inflateGetHeader = function inflateGetHeader(strm, head) {
    var state;
    return strm && strm.state ? 0 == (2 & (state = strm.state).wrap) ? -2 : (state.head = head, 
    head.done = !1, 0) : -2;
}, inflate$3.inflateSetDictionary = function inflateSetDictionary(strm, dictionary) {
    var state, dictLength = dictionary.length;
    return strm && strm.state ? 0 !== (state = strm.state).wrap && 11 !== state.mode ? -2 : 11 === state.mode && adler32(1, dictionary, dictLength, 0) !== state.check ? -3 : updatewindow(strm, dictionary, dictLength, dictLength) ? (state.mode = 31, 
    -4) : (state.havedict = 1, 0) : -2;
}, inflate$3.inflateInfo = "pako inflate (from Nodeca project)";

var constants$1 = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
}, zlib_inflate = inflate$3, utils$2 = common, strings = strings$2, c = constants$1, msg = messages, ZStream = zstream, GZheader = function GZheader$1() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, 
    this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}, toString = Object.prototype.toString;

function Inflate(options) {
    if (!(this instanceof Inflate)) return new Inflate(options);
    this.options = utils$2.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
    }, options || {});
    var opt = this.options;
    opt.raw && opt.windowBits >= 0 && opt.windowBits < 16 && (opt.windowBits = -opt.windowBits, 
    0 === opt.windowBits && (opt.windowBits = -15)), !(opt.windowBits >= 0 && opt.windowBits < 16) || options && options.windowBits || (opt.windowBits += 32), 
    opt.windowBits > 15 && opt.windowBits < 48 && 0 == (15 & opt.windowBits) && (opt.windowBits |= 15), 
    this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new ZStream, 
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== c.Z_OK) throw new Error(msg[status]);
    if (this.header = new GZheader, zlib_inflate.inflateGetHeader(this.strm, this.header), 
    opt.dictionary && ("string" == typeof opt.dictionary ? opt.dictionary = strings.string2buf(opt.dictionary) : "[object ArrayBuffer]" === toString.call(opt.dictionary) && (opt.dictionary = new Uint8Array(opt.dictionary)), 
    opt.raw && (status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary)) !== c.Z_OK)) throw new Error(msg[status]);
}

function inflate$1(input, options) {
    var inflator = new Inflate(options);
    if (inflator.push(input, !0), inflator.err) throw inflator.msg || msg[inflator.err];
    return inflator.result;
}

Inflate.prototype.push = function(data, mode) {
    var status, _mode, next_out_utf8, tail, utf8str, strm = this.strm, chunkSize = this.options.chunkSize, dictionary = this.options.dictionary, allowBufError = !1;
    if (this.ended) return !1;
    _mode = mode === ~~mode ? mode : !0 === mode ? c.Z_FINISH : c.Z_NO_FLUSH, "string" == typeof data ? strm.input = strings.binstring2buf(data) : "[object ArrayBuffer]" === toString.call(data) ? strm.input = new Uint8Array(data) : strm.input = data, 
    strm.next_in = 0, strm.avail_in = strm.input.length;
    do {
        if (0 === strm.avail_out && (strm.output = new utils$2.Buf8(chunkSize), strm.next_out = 0, 
        strm.avail_out = chunkSize), (status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH)) === c.Z_NEED_DICT && dictionary && (status = zlib_inflate.inflateSetDictionary(this.strm, dictionary)), 
        status === c.Z_BUF_ERROR && !0 === allowBufError && (status = c.Z_OK, allowBufError = !1), 
        status !== c.Z_STREAM_END && status !== c.Z_OK) return this.onEnd(status), this.ended = !0, 
        !1;
        strm.next_out && (0 !== strm.avail_out && status !== c.Z_STREAM_END && (0 !== strm.avail_in || _mode !== c.Z_FINISH && _mode !== c.Z_SYNC_FLUSH) || ("string" === this.options.to ? (next_out_utf8 = strings.utf8border(strm.output, strm.next_out), 
        tail = strm.next_out - next_out_utf8, utf8str = strings.buf2string(strm.output, next_out_utf8), 
        strm.next_out = tail, strm.avail_out = chunkSize - tail, tail && utils$2.arraySet(strm.output, strm.output, next_out_utf8, tail, 0), 
        this.onData(utf8str)) : this.onData(utils$2.shrinkBuf(strm.output, strm.next_out)))), 
        0 === strm.avail_in && 0 === strm.avail_out && (allowBufError = !0);
    } while ((strm.avail_in > 0 || 0 === strm.avail_out) && status !== c.Z_STREAM_END);
    return status === c.Z_STREAM_END && (_mode = c.Z_FINISH), _mode === c.Z_FINISH ? (status = zlib_inflate.inflateEnd(this.strm), 
    this.onEnd(status), this.ended = !0, status === c.Z_OK) : _mode !== c.Z_SYNC_FLUSH || (this.onEnd(c.Z_OK), 
    strm.avail_out = 0, !0);
}, Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
}, Inflate.prototype.onEnd = function(status) {
    status === c.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = utils$2.flattenChunks(this.chunks)), 
    this.chunks = [], this.err = status, this.msg = this.strm.msg;
}, inflate$4.Inflate = Inflate, inflate$4.inflate = inflate$1, inflate$4.inflateRaw = function inflateRaw(input, options) {
    return (options = options || {}).raw = !0, inflate$1(input, options);
}, inflate$4.ungzip = inflate$1;

var pako = {};

(0, common.assign)(pako, deflate$4, inflate$4, constants$1);

var pako_1 = pako;

!function(module) {
    !function() {
        var UTIF = {};
        function log() {
            "undefined" != typeof process && "development" != process.env.NODE_ENV || console.log.apply(console, arguments);
        }
        module.exports = UTIF, function(UTIF, pako) {
            var V, D, P;
            V = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(g) {
                return typeof g;
            } : function(g) {
                return g && "function" == typeof Symbol && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
            }, D = function() {
                function g(g) {
                    this.message = "JPEG error: " + g;
                }
                return g.prototype = Error(), g.prototype.name = "JpegError", g.constructor = g;
            }(), P = function() {
                function g(g, D) {
                    this.message = g, this.g = D;
                }
                return g.prototype = Error(), g.prototype.name = "DNLMarkerError", g.constructor = g;
            }(), function() {
                function g() {
                    this.M = null, this.B = -1;
                }
                function W(a, d) {
                    for (var b, B, f = 0, e = [], k = 16; 0 < k && !a[k - 1]; ) k--;
                    e.push({
                        children: [],
                        index: 0
                    });
                    var r, l = e[0];
                    for (b = 0; b < k; b++) {
                        for (B = 0; B < a[b]; B++) {
                            for ((l = e.pop()).children[l.index] = d[f]; 0 < l.index; ) l = e.pop();
                            for (l.index++, e.push(l); e.length <= b; ) e.push(r = {
                                children: [],
                                index: 0
                            }), l.children[l.index] = r.children, l = r;
                            f++;
                        }
                        b + 1 < k && (e.push(r = {
                            children: [],
                            index: 0
                        }), l.children[l.index] = r.children, l = r);
                    }
                    return e[0].children;
                }
                function X(a, d, f, e, b, B, k, l, r) {
                    function n() {
                        if (0 < x) return x--, z >> x & 1;
                        if (255 === (z = a[d++])) {
                            var c = a[d++];
                            if (c) {
                                if (220 === c && g) {
                                    d += 2;
                                    var b = a[d++] << 8 | a[d++];
                                    if (0 < b && b !== f.g) throw new P("Found DNL marker (0xFFDC) while parsing scan data", b);
                                }
                                throw new D("unexpected marker " + (z << 8 | c).toString(16));
                            }
                        }
                        return x = 7, z >>> 7;
                    }
                    function q(a) {
                        for (;;) {
                            if ("number" == typeof (a = a[n()])) return a;
                            if ("object" !== (void 0 === a ? "undefined" : V(a))) throw new D("invalid huffman sequence");
                        }
                    }
                    function h(a) {
                        for (var c = 0; 0 < a; ) c = c << 1 | n(), a--;
                        return c;
                    }
                    function c(a) {
                        if (1 === a) return 1 === n() ? 1 : -1;
                        var c = h(a);
                        return c >= 1 << a - 1 ? c : c + (-1 << a) + 1;
                    }
                    function C(a, b) {
                        var d = q(a.D);
                        for (d = 0 === d ? 0 : c(d), a.a[b] = a.m += d, d = 1; 64 > d; ) {
                            var h = q(a.o), k = 15 & h;
                            if (h >>= 4, 0 === k) {
                                if (15 > h) break;
                                d += 16;
                            } else d += h, a.a[b + J[d]] = c(k), d++;
                        }
                    }
                    function w(a, d) {
                        var b = q(a.D);
                        b = 0 === b ? 0 : c(b) << r, a.a[d] = a.m += b;
                    }
                    function p(a, c) {
                        a.a[c] |= n() << r;
                    }
                    function m(a, b) {
                        if (0 < A) A--; else for (var d = B; d <= k; ) {
                            var e = q(a.o), f = 15 & e;
                            if (e >>= 4, 0 === f) {
                                if (15 > e) {
                                    A = h(e) + (1 << e) - 1;
                                    break;
                                }
                                d += 16;
                            } else d += e, a.a[b + J[d]] = c(f) * (1 << r), d++;
                        }
                    }
                    function t(a, d) {
                        for (var f, b = B, e = 0; b <= k; ) {
                            f = d + J[b];
                            var l = 0 > a.a[f] ? -1 : 1;
                            switch (E) {
                              case 0:
                                if (f = 15 & (e = q(a.o)), e >>= 4, 0 === f) 15 > e ? (A = h(e) + (1 << e), E = 4) : (e = 16, 
                                E = 1); else {
                                    if (1 !== f) throw new D("invalid ACn encoding");
                                    Q = c(f), E = e ? 2 : 3;
                                }
                                continue;

                              case 1:
                              case 2:
                                a.a[f] ? a.a[f] += l * (n() << r) : 0 == --e && (E = 2 === E ? 3 : 0);
                                break;

                              case 3:
                                a.a[f] ? a.a[f] += l * (n() << r) : (a.a[f] = Q << r, E = 0);
                                break;

                              case 4:
                                a.a[f] && (a.a[f] += l * (n() << r));
                            }
                            b++;
                        }
                        4 === E && 0 == --A && (E = 0);
                    }
                    for (var Q, F, L, M, I, S, T, g = 9 < arguments.length && void 0 !== arguments[9] && arguments[9], u = f.P, v = d, z = 0, x = 0, A = 0, E = 0, K = e.length, R = f.S ? 0 === B ? 0 === l ? w : p : 0 === l ? m : t : C, G = 0, O = 1 === K ? e[0].c * e[0].l : u * f.O; G < O; ) {
                        var U = b ? Math.min(O - G, b) : O;
                        for (F = 0; F < K; F++) e[F].m = 0;
                        if (A = 0, 1 === K) {
                            var y = e[0];
                            for (I = 0; I < U; I++) R(y, 64 * ((y.c + 1) * (G / y.c | 0) + G % y.c)), G++;
                        } else for (I = 0; I < U; I++) {
                            for (F = 0; F < K; F++) for (S = (y = e[F]).h, T = y.j, L = 0; L < T; L++) for (M = 0; M < S; M++) R(y, 64 * ((y.c + 1) * ((G / u | 0) * y.j + L) + (G % u * y.h + M)));
                            G++;
                        }
                        if (x = 0, (y = N(a, d)) && y.f && ((0, _util.warn)("decodeScan - unexpected MCU data, current marker is: " + y.f), 
                        d = y.offset), !(y = y && y.F) || 65280 >= y) throw new D("marker was not found");
                        if (!(65488 <= y && 65495 >= y)) break;
                        d += 2;
                    }
                    return (y = N(a, d)) && y.f && ((0, _util.warn)("decodeScan - unexpected Scan data, current marker is: " + y.f), 
                    d = y.offset), d - v;
                }
                function Y(a, d) {
                    for (var f = d.c, e = d.l, b = new Int16Array(64), B = 0; B < e; B++) for (var k = 0; k < f; k++) {
                        var l = 64 * ((d.c + 1) * B + k), r = b, n = d.G, q = d.a;
                        if (!n) throw new D("missing required Quantization Table.");
                        for (var h = 0; 64 > h; h += 8) {
                            var c = q[l + h], C = q[l + h + 1], w = q[l + h + 2], p = q[l + h + 3], m = q[l + h + 4], t = q[l + h + 5], g = q[l + h + 6], u = q[l + h + 7];
                            if (c *= n[h], 0 == (C | w | p | m | t | g | u)) c = 5793 * c + 512 >> 10, r[h] = c, 
                            r[h + 1] = c, r[h + 2] = c, r[h + 3] = c, r[h + 4] = c, r[h + 5] = c, r[h + 6] = c, 
                            r[h + 7] = c; else {
                                C *= n[h + 1], w *= n[h + 2], p *= n[h + 3], m *= n[h + 4], t *= n[h + 5];
                                var v = 5793 * c + 128 >> 8, z = 5793 * m + 128 >> 8, x = w, A = g *= n[h + 6];
                                z = (v = v + z + 1 >> 1) - z, c = 3784 * x + 1567 * A + 128 >> 8, x = 1567 * x - 3784 * A + 128 >> 8, 
                                t = (m = (m = 2896 * (C - (u *= n[h + 7])) + 128 >> 8) + (t <<= 4) + 1 >> 1) - t, 
                                p = (u = (u = 2896 * (C + u) + 128 >> 8) + (p <<= 4) + 1 >> 1) - p, A = (v = v + (A = c) + 1 >> 1) - A, 
                                x = (z = z + x + 1 >> 1) - x, c = 2276 * m + 3406 * u + 2048 >> 12, m = 3406 * m - 2276 * u + 2048 >> 12, 
                                u = c, c = 799 * p + 4017 * t + 2048 >> 12, p = 4017 * p - 799 * t + 2048 >> 12, 
                                t = c, r[h] = v + u, r[h + 7] = v - u, r[h + 1] = z + t, r[h + 6] = z - t, r[h + 2] = x + p, 
                                r[h + 5] = x - p, r[h + 3] = A + m, r[h + 4] = A - m;
                            }
                        }
                        for (n = 0; 8 > n; ++n) c = r[n], 0 == ((C = r[n + 8]) | (w = r[n + 16]) | (p = r[n + 24]) | (m = r[n + 32]) | (t = r[n + 40]) | (g = r[n + 48]) | (u = r[n + 56])) ? (c = -2040 > (c = 5793 * c + 8192 >> 14) ? 0 : 2024 <= c ? 255 : c + 2056 >> 4, 
                        q[l + n] = c, q[l + n + 8] = c, q[l + n + 16] = c, q[l + n + 24] = c, q[l + n + 32] = c, 
                        q[l + n + 40] = c, q[l + n + 48] = c, q[l + n + 56] = c) : (v = 5793 * c + 2048 >> 12, 
                        z = 5793 * m + 2048 >> 12, c = 3784 * (x = w) + 1567 * (A = g) + 2048 >> 12, x = 1567 * x - 3784 * A + 2048 >> 12, 
                        A = c, t = (m = (m = 2896 * (C - u) + 2048 >> 12) + t + 1 >> 1) - t, p = (u = (u = 2896 * (C + u) + 2048 >> 12) + p + 1 >> 1) - p, 
                        c = 2276 * m + 3406 * u + 2048 >> 12, m = 3406 * m - 2276 * u + 2048 >> 12, u = c, 
                        c = 799 * p + 4017 * t + 2048 >> 12, p = 4017 * p - 799 * t + 2048 >> 12, C = (z = (z = (v = 4112 + (v + z + 1 >> 1)) - z) + x + 1 >> 1) + (t = c), 
                        g = z - t, t = (x = z - x) - p, c = 16 > (c = (v = v + A + 1 >> 1) + u) ? 0 : 4080 <= c ? 255 : c >> 4, 
                        C = 16 > C ? 0 : 4080 <= C ? 255 : C >> 4, w = 16 > (w = x + p) ? 0 : 4080 <= w ? 255 : w >> 4, 
                        p = 16 > (p = (A = v - A) + m) ? 0 : 4080 <= p ? 255 : p >> 4, m = 16 > (m = A - m) ? 0 : 4080 <= m ? 255 : m >> 4, 
                        t = 16 > t ? 0 : 4080 <= t ? 255 : t >> 4, g = 16 > g ? 0 : 4080 <= g ? 255 : g >> 4, 
                        u = 16 > (u = v - u) ? 0 : 4080 <= u ? 255 : u >> 4, q[l + n] = c, q[l + n + 8] = C, 
                        q[l + n + 16] = w, q[l + n + 24] = p, q[l + n + 32] = m, q[l + n + 40] = t, q[l + n + 48] = g, 
                        q[l + n + 56] = u);
                    }
                    return d.a;
                }
                function N(a, d) {
                    var f = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : d, e = a.length - 1;
                    if (f = f < d ? f : d, d >= e) return null;
                    var b = a[d] << 8 | a[d + 1];
                    if (65472 <= b && 65534 >= b) return {
                        f: null,
                        F: b,
                        offset: d
                    };
                    for (var B = a[f] << 8 | a[f + 1]; !(65472 <= B && 65534 >= B); ) {
                        if (++f >= e) return null;
                        B = a[f] << 8 | a[f + 1];
                    }
                    return {
                        f: b.toString(16),
                        F: B,
                        offset: f
                    };
                }
                var J = new Uint8Array([ 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 ]);
                g.prototype = {
                    parse: function(a) {
                        function d() {
                            var d = a[k] << 8 | a[k + 1];
                            return k += 2, d;
                        }
                        function f() {
                            var b = d(), c = N(a, b = k + b - 2, k);
                            return c && c.f && ((0, _util.warn)("readDataBlock - incorrect length, current marker is: " + c.f), 
                            b = c.offset), b = a.subarray(k, b), k += b.length, b;
                        }
                        function e(a) {
                            for (var b = Math.ceil(a.v / 8 / a.s), c = Math.ceil(a.g / 8 / a.u), d = 0; d < a.b.length; d++) {
                                v = a.b[d];
                                var e = Math.ceil(Math.ceil(a.v / 8) * v.h / a.s), f = Math.ceil(Math.ceil(a.g / 8) * v.j / a.u);
                                v.a = new Int16Array(64 * c * v.j * (b * v.h + 1)), v.c = e, v.l = f;
                            }
                            a.P = b, a.O = c;
                        }
                        var b = (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}).N, B = void 0 === b ? null : b, k = 0, l = null, r = 0;
                        b = [];
                        var n = [], q = [], h = d();
                        if (65496 !== h) throw new D("SOI not found");
                        for (h = d(); 65497 !== h; ) {
                            switch (h) {
                              case 65504:
                              case 65505:
                              case 65506:
                              case 65507:
                              case 65508:
                              case 65509:
                              case 65510:
                              case 65511:
                              case 65512:
                              case 65513:
                              case 65514:
                              case 65515:
                              case 65516:
                              case 65517:
                              case 65518:
                              case 65519:
                              case 65534:
                                var c = f();
                                65518 === h && 65 === c[0] && 100 === c[1] && 111 === c[2] && 98 === c[3] && 101 === c[4] && (l = {
                                    version: c[5] << 8 | c[6],
                                    Y: c[7] << 8 | c[8],
                                    Z: c[9] << 8 | c[10],
                                    W: c[11]
                                });
                                break;

                              case 65499:
                                h = d() + k - 2;
                                for (var g; k < h; ) {
                                    var w = a[k++], p = new Uint16Array(64);
                                    if (0 == w >> 4) for (c = 0; 64 > c; c++) p[g = J[c]] = a[k++]; else {
                                        if (1 != w >> 4) throw new D("DQT - invalid table spec");
                                        for (c = 0; 64 > c; c++) p[g = J[c]] = d();
                                    }
                                    b[15 & w] = p;
                                }
                                break;

                              case 65472:
                              case 65473:
                              case 65474:
                                if (m) throw new D("Only single frame JPEGs supported");
                                d();
                                var m = {};
                                for (m.X = 65473 === h, m.S = 65474 === h, m.precision = a[k++], h = d(), m.g = B || h, 
                                m.v = d(), m.b = [], m.C = {}, c = a[k++], h = p = w = 0; h < c; h++) {
                                    g = a[k];
                                    var t = a[k + 1] >> 4, H = 15 & a[k + 1];
                                    w < t && (w = t), p < H && (p = H), t = m.b.push({
                                        h: t,
                                        j: H,
                                        T: a[k + 2],
                                        G: null
                                    }), m.C[g] = t - 1, k += 3;
                                }
                                m.s = w, m.u = p, e(m);
                                break;

                              case 65476:
                                for (g = d(), h = 2; h < g; ) {
                                    for (w = a[k++], p = new Uint8Array(16), c = t = 0; 16 > c; c++, k++) t += p[c] = a[k];
                                    for (H = new Uint8Array(t), c = 0; c < t; c++, k++) H[c] = a[k];
                                    h += 17 + t, (0 == w >> 4 ? q : n)[15 & w] = W(p, H);
                                }
                                break;

                              case 65501:
                                d();
                                var u = d();
                                break;

                              case 65498:
                                for (c = 1 == ++r && !B, d(), w = a[k++], g = [], h = 0; h < w; h++) {
                                    p = m.C[a[k++]];
                                    var v = m.b[p];
                                    p = a[k++], v.D = q[p >> 4], v.o = n[15 & p], g.push(v);
                                }
                                h = a[k++], w = a[k++], p = a[k++];
                                try {
                                    var z = X(a, k, m, g, u, h, w, p >> 4, 15 & p, c);
                                    k += z;
                                } catch (x) {
                                    if (x instanceof P) return (0, _util.warn)('Attempting to re-parse JPEG image using "scanLines" parameter found in DNL marker (0xFFDC) segment.'), 
                                    this.parse(a, {
                                        N: x.g
                                    });
                                    throw x;
                                }
                                break;

                              case 65500:
                                k += 4;
                                break;

                              case 65535:
                                255 !== a[k] && k--;
                                break;

                              default:
                                if (255 === a[k - 3] && 192 <= a[k - 2] && 254 >= a[k - 2]) k -= 3; else {
                                    if (!(c = N(a, k - 2)) || !c.f) throw new D("unknown marker " + h.toString(16));
                                    (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + c.f), 
                                    k = c.offset;
                                }
                            }
                            h = d();
                        }
                        for (this.width = m.v, this.height = m.g, this.A = l, this.b = [], h = 0; h < m.b.length; h++) (u = b[(v = m.b[h]).T]) && (v.G = u), 
                        this.b.push({
                            R: Y(0, v),
                            U: v.h / m.s,
                            V: v.j / m.u,
                            c: v.c,
                            l: v.l
                        });
                        this.i = this.b.length;
                    },
                    L: function(a, d) {
                        var b, g, f = this.width / a, e = this.height / d, k = this.b.length, l = a * d * k, r = new Uint8ClampedArray(l), n = new Uint32Array(a);
                        for (g = 0; g < k; g++) {
                            var q = this.b[g], h = q.U * f, c = q.V * e, C = g, w = q.R, p = q.c + 1 << 3;
                            for (b = 0; b < a; b++) q = 0 | b * h, n[b] = (4294967288 & q) << 3 | 7 & q;
                            for (h = 0; h < d; h++) for (q = p * (4294967288 & (q = 0 | h * c)) | (7 & q) << 3, 
                            b = 0; b < a; b++) r[C] = w[q + n[b]], C += k;
                        }
                        if (e = this.M) for (g = 0; g < l; ) for (f = q = 0; q < k; q++, g++, f += 2) r[g] = (r[g] * e[f] >> 8) + e[f + 1];
                        return r;
                    },
                    w: function() {
                        return this.A ? !!this.A.W : 3 === this.i ? 0 !== this.B : 1 === this.B;
                    },
                    I: function(a) {
                        for (var d, f, e, b = 0, g = a.length; b < g; b += 3) d = a[b], f = a[b + 1], e = a[b + 2], 
                        a[b] = d - 179.456 + 1.402 * e, a[b + 1] = d + 135.459 - .344 * f - .714 * e, a[b + 2] = d - 226.816 + 1.772 * f;
                        return a;
                    },
                    K: function(a) {
                        for (var d, f, e, b, g = 0, k = 0, l = a.length; k < l; k += 4) d = a[k], f = a[k + 1], 
                        e = a[k + 2], b = a[k + 3], a[g++] = f * (-6.60635669420364E-5 * f + 4.37130475926232E-4 * e - 5.4080610064599E-5 * d + 4.8449797120281E-4 * b - .154362151871126) - 122.67195406894 + e * (-9.57964378445773E-4 * e + 8.17076911346625E-4 * d - .00477271405408747 * b + 1.53380253221734) + d * (9.61250184130688E-4 * d - .00266257332283933 * b + .48357088451265) + b * (-3.36197177618394E-4 * b + .484791561490776), 
                        a[g++] = 107.268039397724 + f * (2.19927104525741E-5 * f - 6.40992018297945E-4 * e + 6.59397001245577E-4 * d + 4.26105652938837E-4 * b - .176491792462875) + e * (-7.78269941513683E-4 * e + .00130872261408275 * d + 7.70482631801132E-4 * b - .151051492775562) + d * (.00126935368114843 * d - .00265090189010898 * b + .25802910206845) + b * (-3.18913117588328E-4 * b - .213742400323665), 
                        a[g++] = f * (-5.70115196973677E-4 * f - 2.63409051004589E-5 * e + .0020741088115012 * d - .00288260236853442 * b + .814272968359295) - 20.810012546947 + e * (-1.53496057440975E-5 * e - 1.32689043961446E-4 * d + 5.60833691242812E-4 * b - .195152027534049) + d * (.00174418132927582 * d - .00255243321439347 * b + .116935020465145) + b * (-3.43531996510555E-4 * b + .24165260232407);
                        return a.subarray(0, g);
                    },
                    J: function(a) {
                        for (var d, f, e, b = 0, g = a.length; b < g; b += 4) d = a[b], f = a[b + 1], e = a[b + 2], 
                        a[b] = 434.456 - d - 1.402 * e, a[b + 1] = 119.541 - d + .344 * f + .714 * e, a[b + 2] = 481.816 - d - 1.772 * f;
                        return a;
                    },
                    H: function(a) {
                        for (var d, f, e, b, g = 0, k = 1 / 255, l = 0, r = a.length; l < r; l += 4) d = a[l] * k, 
                        f = a[l + 1] * k, e = a[l + 2] * k, b = a[l + 3] * k, a[g++] = 255 + d * (-4.387332384609988 * d + 54.48615194189176 * f + 18.82290502165302 * e + 212.25662451639585 * b - 285.2331026137004) + f * (1.7149763477362134 * f - 5.6096736904047315 * e - 17.873870861415444 * b - 5.497006427196366) + e * (-2.5217340131683033 * e - 21.248923337353073 * b + 17.5119270841813) - b * (21.86122147463605 * b + 189.48180835922747), 
                        a[g++] = 255 + d * (8.841041422036149 * d + 60.118027045597366 * f + 6.871425592049007 * e + 31.159100130055922 * b - 79.2970844816548) + f * (-15.310361306967817 * f + 17.575251261109482 * e + 131.35250912493976 * b - 190.9453302588951) + e * (4.444339102852739 * e + 9.8632861493405 * b - 24.86741582555878) - b * (20.737325471181034 * b + 187.80453709719578), 
                        a[g++] = 255 + d * (.8842522430003296 * d + 8.078677503112928 * f + 30.89978309703729 * e - .23883238689178934 * b - 14.183576799673286) + f * (10.49593273432072 * f + 63.02378494754052 * e + 50.606957656360734 * b - 112.23884253719248) + e * (.03296041114873217 * e + 115.60384449646641 * b - 193.58209356861505) - b * (22.33816807309886 * b + 180.12613974708367);
                        return a.subarray(0, g);
                    },
                    getData: function(a, d, f) {
                        if (4 < this.i) throw new D("Unsupported color mode");
                        if (a = this.L(a, d), 1 === this.i && f) {
                            f = a.length, d = new Uint8ClampedArray(3 * f);
                            for (var e = 0, b = 0; b < f; b++) {
                                var g = a[b];
                                d[e++] = g, d[e++] = g, d[e++] = g;
                            }
                            return d;
                        }
                        if (3 === this.i && this.w()) return this.I(a);
                        if (4 === this.i) {
                            if (this.w()) return f ? this.K(a) : this.J(a);
                            if (f) return this.H(a);
                        }
                        return a;
                    }
                }, UTIF.JpegDecoder = g;
            }(), UTIF.encodeImage = function(rgba, w, h, metadata) {
                var idf = {
                    t256: [ w ],
                    t257: [ h ],
                    t258: [ 8, 8, 8, 8 ],
                    t259: [ 1 ],
                    t262: [ 2 ],
                    t273: [ 1000 ],
                    t277: [ 4 ],
                    t278: [ h ],
                    t279: [ w * h * 4 ],
                    t282: [ 1 ],
                    t283: [ 1 ],
                    t284: [ 1 ],
                    t286: [ 0 ],
                    t287: [ 0 ],
                    t296: [ 1 ],
                    t305: [ "Photopea (UTIF.js)" ],
                    t338: [ 1 ]
                };
                if (metadata) for (var i in metadata) idf[i] = metadata[i];
                var prfx = new Uint8Array(UTIF.encode([ idf ])), img = new Uint8Array(rgba), data = new Uint8Array(1000 + w * h * 4);
                for (i = 0; i < prfx.length; i++) data[i] = prfx[i];
                for (i = 0; i < img.length; i++) data[1000 + i] = img[i];
                return data.buffer;
            }, UTIF.encode = function(ifds) {
                var data = new Uint8Array(20000), offset = 4, bin = UTIF._binBE;
                data[0] = 77, data[1] = 77, data[3] = 42;
                var ifdo = 8;
                bin.writeUint(data, offset, ifdo), offset += 4;
                for (var i = 0; i < ifds.length; i++) {
                    var noffs = UTIF._writeIFD(bin, data, ifdo, ifds[i]);
                    ifdo = noffs[1], i < ifds.length - 1 && bin.writeUint(data, noffs[0], ifdo);
                }
                return data.slice(0, ifdo).buffer;
            }, UTIF.decode = function(buff) {
                UTIF.decode._decodeG3.allow2D = null;
                var data = new Uint8Array(buff), offset = 0, id = UTIF._binBE.readASCII(data, offset, 2);
                offset += 2;
                var bin = "II" == id ? UTIF._binLE : UTIF._binBE;
                bin.readUshort(data, offset), offset += 2;
                var ifdo = bin.readUint(data, offset);
                offset += 4;
                for (var ifds = []; ;) {
                    var noff = UTIF._readIFD(bin, data, ifdo, ifds);
                    if (0 == (ifdo = bin.readUint(data, noff))) break;
                }
                return ifds;
            }, UTIF.decodeImages = function(buff, ifds) {
                for (var data = new Uint8Array(buff), id = UTIF._binBE.readASCII(data, 0, 2), ii = 0; ii < ifds.length; ii++) {
                    var img = ifds[ii];
                    if (null != img.t256) {
                        img.isLE = "II" == id, img.width = img.t256[0], img.height = img.t257[0];
                        var cmpr = img.t259 ? img.t259[0] : 1, fo = img.t266 ? img.t266[0] : 1;
                        img.t284 && 2 == img.t284[0] && log("PlanarConfiguration 2 should not be used!");
                        var bipp = (img.t258 ? Math.min(32, img.t258[0]) : 1) * (img.t277 ? img.t277[0] : 1), bipl = 8 * Math.ceil(img.width * bipp / 8), soff = img.t273;
                        null == soff && (soff = img.t324);
                        var bcnt = img.t279;
                        1 == cmpr && 1 == soff.length && (bcnt = [ img.height * (bipl >>> 3) ]), null == bcnt && (bcnt = img.t325);
                        var bytes = new Uint8Array(img.height * (bipl >>> 3)), bilen = 0;
                        if (null != img.t322) {
                            for (var tw = img.t322[0], th = img.t323[0], tx = Math.floor((img.width + tw - 1) / tw), ty = Math.floor((img.height + th - 1) / th), tbuff = new Uint8Array(0 | Math.ceil(tw * th * bipp / 8)), y = 0; y < ty; y++) for (var x = 0; x < tx; x++) {
                                for (var i = y * tx + x, j = 0; j < tbuff.length; j++) tbuff[j] = 0;
                                UTIF.decode._decompress(img, data, soff[i], bcnt[i], cmpr, tbuff, 0, fo), 6 == cmpr ? bytes = tbuff : UTIF._copyTile(tbuff, 0 | Math.ceil(tw * bipp / 8), th, bytes, 0 | Math.ceil(img.width * bipp / 8), img.height, 0 | Math.ceil(x * tw * bipp / 8), y * th);
                            }
                            bilen = 8 * bytes.length;
                        } else {
                            var rps = img.t278 ? img.t278[0] : img.height;
                            for (rps = Math.min(rps, img.height), i = 0; i < soff.length; i++) UTIF.decode._decompress(img, data, soff[i], bcnt[i], cmpr, bytes, 0 | Math.ceil(bilen / 8), fo), 
                            bilen += bipl * rps;
                            bilen = Math.min(bilen, 8 * bytes.length);
                        }
                        img.data = new Uint8Array(bytes.buffer, 0, 0 | Math.ceil(bilen / 8));
                    }
                }
            }, UTIF.decode._decompress = function(img, data, off, len, cmpr, tgt, toff, fo) {
                if (1 == cmpr) for (var j = 0; j < len; j++) tgt[toff + j] = data[off + j]; else if (3 == cmpr) UTIF.decode._decodeG3(data, off, len, tgt, toff, img.width, fo); else if (4 == cmpr) UTIF.decode._decodeG4(data, off, len, tgt, toff, img.width, fo); else if (5 == cmpr) UTIF.decode._decodeLZW(data, off, tgt, toff); else if (6 == cmpr) UTIF.decode._decodeOldJPEG(img, data, off, len, tgt, toff); else if (7 == cmpr) UTIF.decode._decodeNewJPEG(img, data, off, len, tgt, toff); else if (8 == cmpr) for (var src = new Uint8Array(data.buffer, off, len), bin = pako.inflate(src), i = 0; i < bin.length; i++) tgt[toff + i] = bin[i]; else 32773 == cmpr ? UTIF.decode._decodePackBits(data, off, len, tgt, toff) : 32809 == cmpr ? UTIF.decode._decodeThunder(data, off, len, tgt, toff) : log("Unknown compression", cmpr);
                if (img.t317 && 2 == img.t317[0]) for (var noc = img.t277 ? img.t277[0] : 1, h = img.t278 ? img.t278[0] : img.height, bpr = img.width * noc, y = 0; y < h; y++) {
                    var ntoff = toff + y * bpr;
                    if (3 == noc) for (j = 3; j < bpr; j += 3) tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - 3] & 255, 
                    tgt[ntoff + j + 1] = tgt[ntoff + j + 1] + tgt[ntoff + j - 2] & 255, tgt[ntoff + j + 2] = tgt[ntoff + j + 2] + tgt[ntoff + j - 1] & 255; else for (j = noc; j < bpr; j++) tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - noc] & 255;
                }
            }, UTIF.decode._decodeNikon = function(data, off, len, tgt, toff) {
                var ver0, ver1;
                log(data.slice(off, off + 100)), ver0 = data[off], ver1 = data[++off], off++, log(ver0.toString(16), ver1.toString(16), len);
            }, UTIF.decode._decodeNewJPEG = function(img, data, off, len, tgt, toff) {
                var tables = img.t347, tlen = tables ? tables.length : 0, buff = new Uint8Array(tlen + len);
                if (tables) {
                    for (var boff = 0, i = 0; i < tlen - 1 && (255 != tables[i] || 217 != tables[i + 1]); i++) buff[boff++] = tables[i];
                    var byte1 = data[off], byte2 = data[off + 1];
                    for (255 == byte1 && 216 == byte2 || (buff[boff++] = byte1, buff[boff++] = byte2), 
                    i = 2; i < len; i++) buff[boff++] = data[off + i];
                } else for (i = 0; i < len; i++) buff[i] = data[off + i];
                if (32803 == img.t262) {
                    var bps = img.t258[0], out = (new LosslessJpegDecoder).decode(buff), olen = out.length;
                    if (16 == bps) for (i = 0; i < olen; i++) tgt[toff++] = 255 & out[i], tgt[toff++] = out[i] >>> 8; else {
                        if (12 != bps) throw new Error("unsupported bit depth " + bps);
                        for (i = 0; i < olen; i += 2) tgt[toff++] = out[i] >>> 4, tgt[toff++] = 255 & (out[i] << 4 | out[i + 1] >>> 8), 
                        tgt[toff++] = 255 & out[i + 1];
                    }
                } else {
                    var parser = new UTIF.JpegDecoder;
                    parser.parse(buff);
                    var decoded = parser.getData(parser.width, parser.height);
                    for (i = 0; i < decoded.length; i++) tgt[toff + i] = decoded[i];
                }
                6 == img.t262[0] && (img.t262[0] = 2);
            }, UTIF.decode._decodeOldJPEGInit = function(img, data, off, len) {
                var tables, sosMarker, i, j, k, joff = 0, soff = 0, isTiled = !1, jpgIchgFmt = img.t513, jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0, jpgIchgFmtLen = img.t514, jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0, soffTag = img.t324 || img.t273 || jpgIchgFmt, ycbcrss = img.t530, ssx = 0, ssy = 0, spp = img.t277 ? img.t277[0] : 1, jpgresint = img.t515;
                if (soffTag && (soff = soffTag[0], isTiled = soffTag.length > 1), !isTiled) {
                    if (255 == data[off] && 216 == data[off + 1]) return {
                        jpegOffset: off
                    };
                    if (null != jpgIchgFmt && (255 == data[off + jifoff] && 216 == data[off + jifoff + 1] ? joff = off + jifoff : log("JPEGInterchangeFormat does not point to SOI"), 
                    null == jpgIchgFmtLen ? log("JPEGInterchangeFormatLength field is missing") : (jifoff >= soff || jifoff + jiflen <= soff) && log("JPEGInterchangeFormatLength field value is invalid"), 
                    null != joff)) return {
                        jpegOffset: joff
                    };
                }
                if (null != ycbcrss && (ssx = ycbcrss[0], ssy = ycbcrss[1]), null != jpgIchgFmt && null != jpgIchgFmtLen) if (jiflen >= 2 && jifoff + jiflen <= soff) {
                    for (tables = 255 == data[off + jifoff + jiflen - 2] && 216 == data[off + jifoff + jiflen - 1] ? new Uint8Array(jiflen - 2) : new Uint8Array(jiflen), 
                    i = 0; i < tables.length; i++) tables[i] = data[off + jifoff + i];
                    log("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
                } else log("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
                if (null == tables) {
                    var ooff = 0, out = [];
                    out[ooff++] = 255, out[ooff++] = 216;
                    var qtables = img.t519;
                    if (null == qtables) throw new Error("JPEGQTables tag is missing");
                    for (i = 0; i < qtables.length; i++) for (out[ooff++] = 255, out[ooff++] = 219, 
                    out[ooff++] = 0, out[ooff++] = 67, out[ooff++] = i, j = 0; j < 64; j++) out[ooff++] = data[off + qtables[i] + j];
                    for (k = 0; k < 2; k++) {
                        var htables = img[0 == k ? "t520" : "t521"];
                        if (null == htables) throw new Error((0 == k ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
                        for (i = 0; i < htables.length; i++) {
                            out[ooff++] = 255, out[ooff++] = 196;
                            var nc = 19;
                            for (j = 0; j < 16; j++) nc += data[off + htables[i] + j];
                            for (out[ooff++] = nc >>> 8, out[ooff++] = 255 & nc, out[ooff++] = i | k << 4, j = 0; j < 16; j++) out[ooff++] = data[off + htables[i] + j];
                            for (j = 0; j < nc; j++) out[ooff++] = data[off + htables[i] + 16 + j];
                        }
                    }
                    if (out[ooff++] = 255, out[ooff++] = 192, out[ooff++] = 0, out[ooff++] = 8 + 3 * spp, 
                    out[ooff++] = 8, out[ooff++] = img.height >>> 8 & 255, out[ooff++] = 255 & img.height, 
                    out[ooff++] = img.width >>> 8 & 255, out[ooff++] = 255 & img.width, out[ooff++] = spp, 
                    1 == spp) out[ooff++] = 1, out[ooff++] = 17, out[ooff++] = 0; else for (i = 0; i < 3; i++) out[ooff++] = i + 1, 
                    out[ooff++] = 0 != i ? 17 : (15 & ssx) << 4 | 15 & ssy, out[ooff++] = i;
                    null != jpgresint && 0 != jpgresint[0] && (out[ooff++] = 255, out[ooff++] = 221, 
                    out[ooff++] = 0, out[ooff++] = 4, out[ooff++] = jpgresint[0] >>> 8 & 255, out[ooff++] = 255 & jpgresint[0]), 
                    tables = new Uint8Array(out);
                }
                var sofpos = -1;
                for (i = 0; i < tables.length - 1; ) {
                    if (255 == tables[i] && 192 == tables[i + 1]) {
                        sofpos = i;
                        break;
                    }
                    i++;
                }
                if (-1 == sofpos) {
                    var tmptab = new Uint8Array(tables.length + 10 + 3 * spp);
                    tmptab.set(tables);
                    var tmpoff = tables.length;
                    if (sofpos = tables.length, (tables = tmptab)[tmpoff++] = 255, tables[tmpoff++] = 192, 
                    tables[tmpoff++] = 0, tables[tmpoff++] = 8 + 3 * spp, tables[tmpoff++] = 8, tables[tmpoff++] = img.height >>> 8 & 255, 
                    tables[tmpoff++] = 255 & img.height, tables[tmpoff++] = img.width >>> 8 & 255, tables[tmpoff++] = 255 & img.width, 
                    tables[tmpoff++] = spp, 1 == spp) tables[tmpoff++] = 1, tables[tmpoff++] = 17, tables[tmpoff++] = 0; else for (i = 0; i < 3; i++) tables[tmpoff++] = i + 1, 
                    tables[tmpoff++] = 0 != i ? 17 : (15 & ssx) << 4 | 15 & ssy, tables[tmpoff++] = i;
                }
                if (255 == data[soff] && 218 == data[soff + 1]) {
                    var soslen = data[soff + 2] << 8 | data[soff + 3];
                    for ((sosMarker = new Uint8Array(soslen + 2))[0] = data[soff], sosMarker[1] = data[soff + 1], 
                    sosMarker[2] = data[soff + 2], sosMarker[3] = data[soff + 3], i = 0; i < soslen - 2; i++) sosMarker[i + 4] = data[soff + i + 4];
                } else {
                    var sosoff = 0;
                    if ((sosMarker = new Uint8Array(8 + 2 * spp))[sosoff++] = 255, sosMarker[sosoff++] = 218, 
                    sosMarker[sosoff++] = 0, sosMarker[sosoff++] = 6 + 2 * spp, sosMarker[sosoff++] = spp, 
                    1 == spp) sosMarker[sosoff++] = 1, sosMarker[sosoff++] = 0; else for (i = 0; i < 3; i++) sosMarker[sosoff++] = i + 1, 
                    sosMarker[sosoff++] = i << 4 | i;
                    sosMarker[sosoff++] = 0, sosMarker[sosoff++] = 63, sosMarker[sosoff++] = 0;
                }
                return {
                    jpegOffset: off,
                    tables,
                    sosMarker,
                    sofPosition: sofpos
                };
            }, UTIF.decode._decodeOldJPEG = function(img, data, off, len, tgt, toff) {
                var dlen, tlen, buff, jpegData = UTIF.decode._decodeOldJPEGInit(img, data, off, len);
                if (null != jpegData.jpegOffset) for (dlen = off + len - jpegData.jpegOffset, buff = new Uint8Array(dlen), 
                i = 0; i < dlen; i++) buff[i] = data[jpegData.jpegOffset + i]; else {
                    for (tlen = jpegData.tables.length, (buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2)).set(jpegData.tables), 
                    buff[jpegData.sofPosition + 5] = img.height >>> 8 & 255, buff[jpegData.sofPosition + 6] = 255 & img.height, 
                    buff[jpegData.sofPosition + 7] = img.width >>> 8 & 255, buff[jpegData.sofPosition + 8] = 255 & img.width, 
                    255 == data[off] && data[off + 1] == SOS || (buff.set(jpegData.sosMarker, bufoff), 
                    bufoff += sosMarker.length), i = 0; i < len; i++) buff[bufoff++] = data[off + i];
                    buff[bufoff++] = 255, buff[bufoff++] = EOI;
                }
                var parser = new UTIF.JpegDecoder;
                parser.parse(buff);
                for (var decoded = parser.getData(parser.width, parser.height), i = 0; i < decoded.length; i++) tgt[toff + i] = decoded[i];
                6 == img.t262[0] && (img.t262[0] = 2);
            }, UTIF.decode._decodePackBits = function(data, off, len, tgt, toff) {
                for (var sa = new Int8Array(data.buffer), ta = new Int8Array(tgt.buffer), lim = off + len; off < lim; ) {
                    var n = sa[off];
                    if (off++, n >= 0 && n < 128) for (var i = 0; i < n + 1; i++) ta[toff] = sa[off], 
                    toff++, off++;
                    if (n >= -127 && n < 0) {
                        for (i = 0; i < 1 - n; i++) ta[toff] = sa[off], toff++;
                        off++;
                    }
                }
            }, UTIF.decode._decodeThunder = function(data, off, len, tgt, toff) {
                for (var d2 = [ 0, 1, 0, -1 ], d3 = [ 0, 1, 2, 3, 0, -3, -2, -1 ], lim = off + len, qoff = 2 * toff, px = 0; off < lim; ) {
                    var b = data[off], msk = b >>> 6, n = 63 & b;
                    if (off++, 3 == msk && (px = 15 & n, tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1), 
                    qoff++), 0 == msk) for (var i = 0; i < n; i++) tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1), 
                    qoff++;
                    if (2 == msk) for (i = 0; i < 2; i++) 4 != (d = n >>> 3 * (1 - i) & 7) && (px += d3[d], 
                    tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1), qoff++);
                    if (1 == msk) for (i = 0; i < 3; i++) {
                        var d;
                        2 != (d = n >>> 2 * (2 - i) & 3) && (px += d2[d], tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1), 
                        qoff++);
                    }
                }
            }, UTIF.decode._dmap = {
                1: 0,
                "011": 1,
                "000011": 2,
                "0000011": 3,
                "010": -1,
                "000010": -2,
                "0000010": -3
            }, UTIF.decode._lens = function() {
                var addKeys = function(lens, arr, i0, inc) {
                    for (var i = 0; i < arr.length; i++) lens[arr[i]] = i0 + i * inc;
                }, termW = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100", termB = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111", makeW = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011", makeB = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101", makeA = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
                termW = termW.split(","), termB = termB.split(","), makeW = makeW.split(","), makeB = makeB.split(","), 
                makeA = makeA.split(",");
                var lensW = {}, lensB = {};
                return addKeys(lensW, termW, 0, 1), addKeys(lensW, makeW, 64, 64), addKeys(lensW, makeA, 1792, 64), 
                addKeys(lensB, termB, 0, 1), addKeys(lensB, makeB, 64, 64), addKeys(lensB, makeA, 1792, 64), 
                [ lensW, lensB ];
            }(), UTIF.decode._decodeG4 = function(data, off, slen, tgt, toff, w, fo) {
                for (var U = UTIF.decode, boff = off << 3, len = 0, wrd = "", line = [], pline = [], i = 0; i < w; i++) pline.push(0);
                pline = U._makeDiff(pline);
                for (var a0 = 0, a1 = 0, b1 = 0, b2 = 0, clr = 0, y = 0, mode = "", toRead = 0, bipl = 8 * Math.ceil(w / 8); boff >>> 3 < off + slen; ) {
                    b1 = U._findDiff(pline, a0 + (0 == a0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
                    var bit = 0;
                    if (1 == fo && (bit = data[boff >>> 3] >>> 7 - (7 & boff) & 1), 2 == fo && (bit = data[boff >>> 3] >>> (7 & boff) & 1), 
                    boff++, wrd += bit, "H" == mode) {
                        if (null != U._lens[clr][wrd]) {
                            var dl = U._lens[clr][wrd];
                            wrd = "", len += dl, dl < 64 && (U._addNtimes(line, len, clr), a0 += len, clr = 1 - clr, 
                            len = 0, 0 == --toRead && (mode = ""));
                        }
                    } else "0001" == wrd && (wrd = "", U._addNtimes(line, b2 - a0, clr), a0 = b2), "001" == wrd && (wrd = "", 
                    mode = "H", toRead = 2), null != U._dmap[wrd] && (a1 = b1 + U._dmap[wrd], U._addNtimes(line, a1 - a0, clr), 
                    a0 = a1, wrd = "", clr = 1 - clr);
                    line.length == w && "" == mode && (U._writeBits(line, tgt, 8 * toff + y * bipl), 
                    clr = 0, y++, a0 = 0, pline = U._makeDiff(line), line = []);
                }
            }, UTIF.decode._findDiff = function(line, x, clr) {
                for (var i = 0; i < line.length; i += 2) if (line[i] >= x && line[i + 1] == clr) return line[i];
            }, UTIF.decode._makeDiff = function(line) {
                var out = [];
                1 == line[0] && out.push(0, 1);
                for (var i = 1; i < line.length; i++) line[i - 1] != line[i] && out.push(i, line[i]);
                return out.push(line.length, 0, line.length, 1), out;
            }, UTIF.decode._decodeG3 = function(data, off, slen, tgt, toff, w, fo) {
                for (var U = UTIF.decode, boff = off << 3, len = 0, wrd = "", line = [], pline = [], i = 0; i < w; i++) line.push(0);
                for (var a0 = 0, a1 = 0, b1 = 0, b2 = 0, clr = 0, y = -1, mode = "", toRead = 0, is1D = !1, bipl = 8 * Math.ceil(w / 8); boff >>> 3 < off + slen; ) {
                    b1 = U._findDiff(pline, a0 + (0 == a0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
                    var bit = 0;
                    if (1 == fo && (bit = data[boff >>> 3] >>> 7 - (7 & boff) & 1), 2 == fo && (bit = data[boff >>> 3] >>> (7 & boff) & 1), 
                    boff++, wrd += bit, is1D) {
                        if (null != U._lens[clr][wrd]) {
                            var dl = U._lens[clr][wrd];
                            wrd = "", len += dl, dl < 64 && (U._addNtimes(line, len, clr), clr = 1 - clr, len = 0);
                        }
                    } else "H" == mode ? null != U._lens[clr][wrd] && (dl = U._lens[clr][wrd], wrd = "", 
                    len += dl, dl < 64 && (U._addNtimes(line, len, clr), a0 += len, clr = 1 - clr, len = 0, 
                    0 == --toRead && (mode = ""))) : ("0001" == wrd && (wrd = "", U._addNtimes(line, b2 - a0, clr), 
                    a0 = b2), "001" == wrd && (wrd = "", mode = "H", toRead = 2), null != U._dmap[wrd] && (a1 = b1 + U._dmap[wrd], 
                    U._addNtimes(line, a1 - a0, clr), a0 = a1, wrd = "", clr = 1 - clr));
                    wrd.endsWith("000000000001") && (y >= 0 && U._writeBits(line, tgt, 8 * toff + y * bipl), 
                    1 == fo && (is1D = 1 == (data[boff >>> 3] >>> 7 - (7 & boff) & 1)), 2 == fo && (is1D = 1 == (data[boff >>> 3] >>> (7 & boff) & 1)), 
                    boff++, null == U._decodeG3.allow2D && (U._decodeG3.allow2D = is1D), U._decodeG3.allow2D || (is1D = !0, 
                    boff--), wrd = "", clr = 0, y++, a0 = 0, pline = U._makeDiff(line), line = []);
                }
                line.length == w && U._writeBits(line, tgt, 8 * toff + y * bipl);
            }, UTIF.decode._addNtimes = function(arr, n, val) {
                for (var i = 0; i < n; i++) arr.push(val);
            }, UTIF.decode._writeBits = function(bits, tgt, boff) {
                for (var i = 0; i < bits.length; i++) tgt[boff + i >>> 3] |= bits[i] << 7 - (boff + i & 7);
            }, UTIF.decode._decodeLZW = function(data, off, tgt, toff) {
                if (null == UTIF.decode._lzwTab) {
                    for (var tb = new Uint32Array(0xffff), tn = new Uint16Array(0xffff), chr = new Uint8Array(2e6), i = 0; i < 256; i++) chr[i << 2] = i, 
                    tb[i] = i << 2, tn[i] = 1;
                    UTIF.decode._lzwTab = [ tb, tn, chr ];
                }
                for (var copy = UTIF.decode._copyData, tab = UTIF.decode._lzwTab[0], tln = UTIF.decode._lzwTab[1], totl = (chr = UTIF.decode._lzwTab[2], 
                258), chrl = 1032, bits = 9, boff = off << 3, Code = 0, OldCode = 0; Code = (data[boff >>> 3] << 16 | data[boff + 8 >>> 3] << 8 | data[boff + 16 >>> 3]) >> 24 - (7 & boff) - bits & (1 << bits) - 1, 
                boff += bits, 257 != Code; ) {
                    if (256 == Code) {
                        if (bits = 9, totl = 258, chrl = 1032, Code = (data[boff >>> 3] << 16 | data[boff + 8 >>> 3] << 8 | data[boff + 16 >>> 3]) >> 24 - (7 & boff) - bits & (1 << bits) - 1, 
                        boff += bits, 257 == Code) break;
                        tgt[toff] = Code, toff++;
                    } else if (Code < totl) {
                        var cd = tab[Code], cl = tln[Code];
                        copy(chr, cd, tgt, toff, cl), toff += cl, OldCode >= totl ? (tab[totl] = chrl, chr[tab[totl]] = cd[0], 
                        tln[totl] = 1, chrl = chrl + 1 + 3 & -4, totl++) : (tab[totl] = chrl, copy(chr, tab[OldCode], chr, chrl, nil = tln[OldCode]), 
                        chr[chrl + nil] = chr[cd], nil++, tln[totl] = nil, totl++, chrl = chrl + nil + 3 & -4), 
                        totl + 1 == 1 << bits && bits++;
                    } else {
                        var nil;
                        OldCode >= totl ? (tab[totl] = chrl, tln[totl] = 0, totl++) : (tab[totl] = chrl, 
                        copy(chr, tab[OldCode], chr, chrl, nil = tln[OldCode]), chr[chrl + nil] = chr[chrl], 
                        nil++, tln[totl] = nil, totl++, copy(chr, chrl, tgt, toff, nil), toff += nil, chrl = chrl + nil + 3 & -4), 
                        totl + 1 == 1 << bits && bits++;
                    }
                    OldCode = Code;
                }
            }, UTIF.decode._copyData = function(s, so, t, to, l) {
                for (var i = 0; i < l; i += 4) t[to + i] = s[so + i], t[to + i + 1] = s[so + i + 1], 
                t[to + i + 2] = s[so + i + 2], t[to + i + 3] = s[so + i + 3];
            }, UTIF.tags = {
                254: "NewSubfileType",
                255: "SubfileType",
                256: "ImageWidth",
                257: "ImageLength",
                258: "BitsPerSample",
                259: "Compression",
                262: "PhotometricInterpretation",
                266: "FillOrder",
                269: "DocumentName",
                270: "ImageDescription",
                271: "Make",
                272: "Model",
                273: "StripOffset",
                274: "Orientation",
                277: "SamplesPerPixel",
                278: "RowsPerStrip",
                279: "StripByteCounts",
                280: "MinSampleValue",
                281: "MaxSampleValue",
                282: "XResolution",
                283: "YResolution",
                284: "PlanarConfiguration",
                285: "PageName",
                286: "XPosition",
                287: "YPosition",
                292: "T4Options",
                296: "ResolutionUnit",
                297: "PageNumber",
                305: "Software",
                306: "DateTime",
                315: "Artist",
                316: "HostComputer",
                317: "Predictor",
                318: "WhitePoint",
                319: "PrimaryChromaticities",
                320: "ColorMap",
                321: "HalftoneHints",
                322: "TileWidth",
                323: "TileLength",
                324: "TileOffset",
                325: "TileByteCounts",
                330: "SubIFDs",
                336: "DotRange",
                338: "ExtraSample",
                339: "SampleFormat",
                347: "JPEGTables",
                512: "JPEGProc",
                513: "JPEGInterchangeFormat",
                514: "JPEGInterchangeFormatLength",
                519: "JPEGQTables",
                520: "JPEGDCTables",
                521: "JPEGACTables",
                529: "YCbCrCoefficients",
                530: "YCbCrSubSampling",
                531: "YCbCrPositioning",
                532: "ReferenceBlackWhite",
                700: "XMP",
                33421: "CFARepeatPatternDim",
                33422: "CFAPattern",
                33432: "Copyright",
                33434: "ExposureTime",
                33437: "FNumber",
                33723: "IPTC/NAA",
                34377: "Photoshop",
                34665: "ExifIFD",
                34675: "ICC Profile",
                34850: "ExposureProgram",
                34853: "GPSInfo",
                34855: "ISOSpeedRatings",
                34858: "TimeZoneOffset",
                34859: "SelfTimeMode",
                36867: "DateTimeOriginal",
                36868: "DateTimeDigitized",
                37377: "ShutterSpeedValue",
                37378: "ApertureValue",
                37380: "ExposureBiasValue",
                37383: "MeteringMode",
                37385: "Flash",
                37386: "FocalLength",
                37390: "FocalPlaneXResolution",
                37391: "FocalPlaneYResolution",
                37392: "FocalPlaneResolutionUnit",
                37393: "ImageNumber",
                37398: "TIFF/EPStandardID",
                37399: "SensingMethod",
                37500: "MakerNote",
                37510: "UserComment",
                37724: "ImageSourceData",
                40092: "XPComment",
                40094: "XPKeywords",
                40961: "ColorSpace",
                40962: "PixelXDimension",
                40963: "PixelXDimension",
                41486: "FocalPlaneXResolution",
                41487: "FocalPlaneYResolution",
                41488: "FocalPlaneResolutionUnit",
                41985: "CustomRendered",
                41986: "ExposureMode",
                41987: "WhiteBalance",
                41990: "SceneCaptureType",
                50706: "DNGVersion",
                50707: "DNGBackwardVersion",
                50708: "UniqueCameraModel",
                50709: "LocalizedCameraModel",
                50710: "CFAPlaneColor",
                50711: "CFALayout",
                50712: "LinearizationTable",
                50713: "BlackLevelRepeatDim",
                50714: "BlackLevel",
                50716: "BlackLevelDeltaV",
                50717: "WhiteLevel",
                50718: "DefaultScale",
                50719: "DefaultCropOrigin",
                50720: "DefaultCropSize",
                50733: "BayerGreenSplit",
                50738: "AntiAliasStrength",
                50721: "ColorMatrix1",
                50722: "ColorMatrix2",
                50723: "CameraCalibration1",
                50724: "CameraCalibration2",
                50727: "AnalogBalance",
                50728: "AsShotNeutral",
                50730: "BaselineExposure",
                50731: "BaselineNoise",
                50732: "BaselineSharpness",
                50734: "LinearResponseLimit",
                50735: "CameraSerialNumber",
                50736: "LensInfo",
                50739: "ShadowScale",
                50740: "DNGPrivateData",
                50741: "MakerNoteSafety",
                50778: "CalibrationIlluminant1",
                50779: "CalibrationIlluminant2",
                50780: "BestQualityScale",
                50781: "RawDataUniqueID",
                50827: "OriginalRawFileName",
                50829: "ActiveArea",
                50830: "MaskedAreas",
                50931: "CameraCalibrationSignature",
                50932: "ProfileCalibrationSignature",
                50935: "NoiseReductionApplied",
                50936: "ProfileName",
                50937: "ProfileHueSatMapDims",
                50938: "ProfileHueSatMapData1",
                50939: "ProfileHueSatMapData2",
                50940: "ProfileToneCurve",
                50941: "ProfileEmbedPolicy",
                50942: "ProfileCopyright",
                50964: "ForwardMatrix1",
                50965: "ForwardMatrix2",
                50966: "PreviewApplicationName",
                50967: "PreviewApplicationVersion",
                50969: "PreviewSettingsDigest",
                50970: "PreviewColorSpace",
                50971: "PreviewDateTime",
                50972: "RawImageDigest",
                51008: "OpcodeList1",
                51009: "OpcodeList2",
                51022: "OpcodeList3",
                51041: "NoiseProfile",
                51089: "OriginalDefaultFinalSize",
                51090: "OriginalBestQualityFinalSize",
                51091: "OriginalDefaultCropSize",
                51125: "DefaultUserCrop"
            }, UTIF.ttypes = {
                256: 3,
                257: 3,
                258: 3,
                259: 3,
                262: 3,
                273: 4,
                274: 3,
                277: 3,
                278: 4,
                279: 4,
                282: 5,
                283: 5,
                284: 3,
                286: 5,
                287: 5,
                296: 3,
                305: 2,
                306: 2,
                338: 3,
                513: 4,
                514: 4,
                34665: 4
            }, UTIF._readIFD = function(bin, data, offset, ifds) {
                var cnt = bin.readUshort(data, offset);
                offset += 2;
                var ifd = {};
                ifds.push(ifd);
                for (var i = 0; i < cnt; i++) {
                    var tag = bin.readUshort(data, offset);
                    offset += 2;
                    var type = bin.readUshort(data, offset);
                    offset += 2;
                    var num = bin.readUint(data, offset);
                    offset += 4;
                    var voff = bin.readUint(data, offset);
                    offset += 4;
                    var arr = [];
                    if (ifd["t" + tag] = arr, 1 == type || 7 == type) for (var j = 0; j < num; j++) arr.push(data[(num < 5 ? offset - 4 : voff) + j]);
                    if (2 == type && arr.push(bin.readASCII(data, num < 5 ? offset - 4 : voff, num - 1)), 
                    3 == type) for (j = 0; j < num; j++) arr.push(bin.readUshort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
                    if (4 == type) for (j = 0; j < num; j++) arr.push(bin.readUint(data, (num < 2 ? offset - 4 : voff) + 4 * j));
                    if (5 == type) for (j = 0; j < num; j++) arr.push(bin.readUint(data, voff + 8 * j) / bin.readUint(data, voff + 8 * j + 4));
                    if (8 == type) for (j = 0; j < num; j++) arr.push(bin.readShort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
                    if (9 == type) for (j = 0; j < num; j++) arr.push(bin.readInt(data, (num < 2 ? offset - 4 : voff) + 4 * j));
                    if (10 == type) for (j = 0; j < num; j++) arr.push(bin.readInt(data, voff + 8 * j) / bin.readInt(data, voff + 8 * j + 4));
                    if (11 == type) for (j = 0; j < num; j++) arr.push(bin.readFloat(data, voff + 4 * j));
                    if (12 == type) for (j = 0; j < num; j++) arr.push(bin.readDouble(data, voff + 8 * j));
                    if (0 != num && 0 == arr.length && log("unknown TIFF tag type: ", type, "num:", num), 
                    330 == tag) for (j = 0; j < num; j++) UTIF._readIFD(bin, data, arr[j], ifds);
                }
                return offset;
            }, UTIF._writeIFD = function(bin, data, offset, ifd) {
                var keys = Object.keys(ifd);
                bin.writeUshort(data, offset, keys.length);
                for (var eoff = (offset += 2) + 12 * keys.length + 4, ki = 0; ki < keys.length; ki++) {
                    var key = keys[ki], tag = parseInt(key.slice(1)), type = UTIF.ttypes[tag];
                    if (null == type) throw new Error("unknown type of tag: " + tag);
                    var val = ifd[key];
                    2 == type && (val = val[0] + "\0");
                    var num = val.length;
                    bin.writeUshort(data, offset, tag), offset += 2, bin.writeUshort(data, offset, type), 
                    offset += 2, bin.writeUint(data, offset, num);
                    var dlen = [ -1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8 ][type] * num, toff = offset += 4;
                    if (dlen > 4 && (bin.writeUint(data, offset, eoff), toff = eoff), 2 == type && bin.writeASCII(data, toff, val), 
                    3 == type) for (var i = 0; i < num; i++) bin.writeUshort(data, toff + 2 * i, val[i]);
                    if (4 == type) for (i = 0; i < num; i++) bin.writeUint(data, toff + 4 * i, val[i]);
                    if (5 == type) for (i = 0; i < num; i++) bin.writeUint(data, toff + 8 * i, Math.round(10000 * val[i])), 
                    bin.writeUint(data, toff + 8 * i + 4, 10000);
                    if (12 == type) for (i = 0; i < num; i++) bin.writeDouble(data, toff + 8 * i, val[i]);
                    dlen > 4 && (eoff += dlen += 1 & dlen), offset += 4;
                }
                return [ offset, eoff ];
            }, UTIF.toRGBA8 = function(out) {
                var w = out.width, h = out.height, area = w * h, qarea = 4 * area, data = out.data, img = new Uint8Array(4 * area), intp = out.t262[0], bps = out.t258 ? Math.min(32, out.t258[0]) : 1, isLE = out.isLE ? 1 : 0;
                if (0 == intp) for (var bpl = Math.ceil(bps * w / 8), y = 0; y < h; y++) {
                    var off = y * bpl, io = y * w;
                    if (1 == bps) for (var i = 0; i < w; i++) {
                        var qi = io + i << 2, px = data[off + (i >> 3)] >> 7 - (7 & i) & 1;
                        img[qi] = img[qi + 1] = img[qi + 2] = 255 * (1 - px), img[qi + 3] = 255;
                    }
                    if (4 == bps) for (i = 0; i < w; i++) qi = io + i << 2, px = data[off + (i >> 1)] >> 4 - 4 * (1 & i) & 15, 
                    img[qi] = img[qi + 1] = img[qi + 2] = 17 * (15 - px), img[qi + 3] = 255;
                    if (8 == bps) for (i = 0; i < w; i++) qi = io + i << 2, px = data[off + i], img[qi] = img[qi + 1] = img[qi + 2] = 255 - px, 
                    img[qi + 3] = 255;
                } else if (1 == intp) for (bpl = Math.ceil(bps * w / 8), y = 0; y < h; y++) {
                    if (off = y * bpl, io = y * w, 1 == bps) for (i = 0; i < w; i++) qi = io + i << 2, 
                    px = data[off + (i >> 3)] >> 7 - (7 & i) & 1, img[qi] = img[qi + 1] = img[qi + 2] = 255 * px, 
                    img[qi + 3] = 255;
                    if (2 == bps) for (i = 0; i < w; i++) qi = io + i << 2, px = data[off + (i >> 2)] >> 6 - 2 * (3 & i) & 3, 
                    img[qi] = img[qi + 1] = img[qi + 2] = 85 * px, img[qi + 3] = 255;
                    if (8 == bps) for (i = 0; i < w; i++) qi = io + i << 2, px = data[off + i], img[qi] = img[qi + 1] = img[qi + 2] = px, 
                    img[qi + 3] = 255;
                    if (16 == bps) for (i = 0; i < w; i++) qi = io + i << 2, px = data[off + (2 * i + isLE)], 
                    img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, px), img[qi + 3] = 255;
                } else if (2 == intp) if (8 == bps) if (out.t338) if (out.t338[0] > 0) for (i = 0; i < qarea; i++) img[i] = data[i]; else for (i = 0; i < qarea; i += 4) img[i] = data[i], 
                img[i + 1] = data[i + 1], img[i + 2] = data[i + 2], img[i + 3] = 255; else {
                    if (4 == (smpls = out.t258 ? out.t258.length : 3)) for (i = 0; i < qarea; i++) img[i] = data[i];
                    if (3 == smpls) for (i = 0; i < area; i++) {
                        var ti = 3 * i;
                        img[qi = i << 2] = data[ti], img[qi + 1] = data[ti + 1], img[qi + 2] = data[ti + 2], 
                        img[qi + 3] = 255;
                    }
                } else for (i = 0; i < area; i++) ti = 6 * i, img[qi = i << 2] = data[ti], img[qi + 1] = data[ti + 2], 
                img[qi + 2] = data[ti + 4], img[qi + 3] = 255; else if (3 == intp) {
                    var map = out.t320;
                    for (i = 0; i < area; i++) {
                        qi = i << 2;
                        var mi = data[i];
                        img[qi] = map[mi] >> 8, img[qi + 1] = map[256 + mi] >> 8, img[qi + 2] = map[512 + mi] >> 8, 
                        img[qi + 3] = 255;
                    }
                } else if (5 == intp) {
                    var smpls, gotAlpha = (smpls = out.t258 ? out.t258.length : 4) > 4 ? 1 : 0;
                    for (i = 0; i < area; i++) {
                        qi = i << 2;
                        var si = i * smpls, C = 255 - data[si], M = 255 - data[si + 1], Y = 255 - data[si + 2], K = (255 - data[si + 3]) * (1 / 255);
                        img[qi] = ~~(C * K + 0.5), img[qi + 1] = ~~(M * K + 0.5), img[qi + 2] = ~~(Y * K + 0.5), 
                        img[qi + 3] = 255 * (1 - gotAlpha) + data[si + 4] * gotAlpha;
                    }
                } else log("Unknown Photometric interpretation: " + intp);
                return img;
            }, UTIF.replaceIMG = function() {
                for (var imgs = document.getElementsByTagName("img"), i = 0; i < imgs.length; i++) {
                    var img = imgs[i], src = img.getAttribute("src");
                    if (null != src) {
                        var suff = src.split(".").pop().toLowerCase();
                        if ("tif" == suff || "tiff" == suff) {
                            var xhr = new XMLHttpRequest;
                            UTIF._xhrs.push(xhr), UTIF._imgs.push(img), xhr.open("GET", src), xhr.responseType = "arraybuffer", 
                            xhr.onload = UTIF._imgLoaded, xhr.send();
                        }
                    }
                }
            }, UTIF._xhrs = [], UTIF._imgs = [], UTIF._imgLoaded = function(e) {
                var buff = e.target.response, ifds = UTIF.decode(buff), page = ifds[0];
                UTIF.decodeImages(buff, ifds);
                var rgba = UTIF.toRGBA8(page), w = page.width, h = page.height, ind = UTIF._xhrs.indexOf(e.target), img = UTIF._imgs[ind];
                UTIF._xhrs.splice(ind, 1), UTIF._imgs.splice(ind, 1);
                var cnv = document.createElement("canvas");
                cnv.width = w, cnv.height = h;
                for (var ctx = cnv.getContext("2d"), imgd = ctx.createImageData(w, h), i = 0; i < rgba.length; i++) imgd.data[i] = rgba[i];
                ctx.putImageData(imgd, 0, 0);
                var attr = [ "style", "class", "id" ];
                for (i = 0; i < attr.length; i++) cnv.setAttribute(attr[i], img.getAttribute(attr[i]));
                img.parentNode.replaceChild(cnv, img);
            }, UTIF._binBE = {
                nextZero: function(data, o) {
                    for (;0 != data[o]; ) o++;
                    return o;
                },
                readUshort: function(buff, p) {
                    return buff[p] << 8 | buff[p + 1];
                },
                readShort: function(buff, p) {
                    var a = UTIF._binBE.ui8;
                    return a[0] = buff[p + 1], a[1] = buff[p + 0], UTIF._binBE.i16[0];
                },
                readInt: function(buff, p) {
                    var a = UTIF._binBE.ui8;
                    return a[0] = buff[p + 3], a[1] = buff[p + 2], a[2] = buff[p + 1], a[3] = buff[p + 0], 
                    UTIF._binBE.i32[0];
                },
                readUint: function(buff, p) {
                    var a = UTIF._binBE.ui8;
                    return a[0] = buff[p + 3], a[1] = buff[p + 2], a[2] = buff[p + 1], a[3] = buff[p + 0], 
                    UTIF._binBE.ui32[0];
                },
                readASCII: function(buff, p, l) {
                    for (var s = "", i = 0; i < l; i++) s += String.fromCharCode(buff[p + i]);
                    return s;
                },
                readFloat: function(buff, p) {
                    for (var a = UTIF._binBE.ui8, i = 0; i < 4; i++) a[i] = buff[p + 3 - i];
                    return UTIF._binBE.fl32[0];
                },
                readDouble: function(buff, p) {
                    for (var a = UTIF._binBE.ui8, i = 0; i < 8; i++) a[i] = buff[p + 7 - i];
                    return UTIF._binBE.fl64[0];
                },
                writeUshort: function(buff, p, n) {
                    buff[p] = n >> 8 & 255, buff[p + 1] = 255 & n;
                },
                writeUint: function(buff, p, n) {
                    buff[p] = n >> 24 & 255, buff[p + 1] = n >> 16 & 255, buff[p + 2] = n >> 8 & 255, 
                    buff[p + 3] = n >> 0 & 255;
                },
                writeASCII: function(buff, p, s) {
                    for (var i = 0; i < s.length; i++) buff[p + i] = s.charCodeAt(i);
                },
                writeDouble: function(buff, p, n) {
                    UTIF._binBE.fl64[0] = n;
                    for (var i = 0; i < 8; i++) buff[p + i] = UTIF._binBE.ui8[7 - i];
                }
            }, UTIF._binBE.ui8 = new Uint8Array(8), UTIF._binBE.i16 = new Int16Array(UTIF._binBE.ui8.buffer), 
            UTIF._binBE.i32 = new Int32Array(UTIF._binBE.ui8.buffer), UTIF._binBE.ui32 = new Uint32Array(UTIF._binBE.ui8.buffer), 
            UTIF._binBE.fl32 = new Float32Array(UTIF._binBE.ui8.buffer), UTIF._binBE.fl64 = new Float64Array(UTIF._binBE.ui8.buffer), 
            UTIF._binLE = {
                nextZero: UTIF._binBE.nextZero,
                readUshort: function(buff, p) {
                    return buff[p + 1] << 8 | buff[p];
                },
                readShort: function(buff, p) {
                    var a = UTIF._binBE.ui8;
                    return a[0] = buff[p + 0], a[1] = buff[p + 1], UTIF._binBE.i16[0];
                },
                readInt: function(buff, p) {
                    var a = UTIF._binBE.ui8;
                    return a[0] = buff[p + 0], a[1] = buff[p + 1], a[2] = buff[p + 2], a[3] = buff[p + 3], 
                    UTIF._binBE.i32[0];
                },
                readUint: function(buff, p) {
                    var a = UTIF._binBE.ui8;
                    return a[0] = buff[p + 0], a[1] = buff[p + 1], a[2] = buff[p + 2], a[3] = buff[p + 3], 
                    UTIF._binBE.ui32[0];
                },
                readASCII: UTIF._binBE.readASCII,
                readFloat: function(buff, p) {
                    for (var a = UTIF._binBE.ui8, i = 0; i < 4; i++) a[i] = buff[p + i];
                    return UTIF._binBE.fl32[0];
                },
                readDouble: function(buff, p) {
                    for (var a = UTIF._binBE.ui8, i = 0; i < 8; i++) a[i] = buff[p + i];
                    return UTIF._binBE.fl64[0];
                }
            }, UTIF._copyTile = function(tb, tw, th, b, w, h, xoff, yoff) {
                for (var xlim = Math.min(tw, w - xoff), ylim = Math.min(th, h - yoff), y = 0; y < ylim; y++) for (var tof = (yoff + y) * w + xoff, sof = y * tw, x = 0; x < xlim; x++) b[tof + x] = tb[sof + x];
            };
        }(UTIF, pako_1);
    }();
}(UTIF), function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _defineProperty2 = _interopRequireDefault(defineProperty.exports), _utif = _interopRequireDefault(UTIF.exports);
    exports.default = function _default() {
        return {
            mime: (0, _defineProperty2.default)({}, "image/tiff", [ "tiff", "tif" ]),
            constants: {
                MIME_TIFF: "image/tiff"
            },
            decoders: (0, _defineProperty2.default)({}, "image/tiff", (function(data) {
                var ifds = _utif.default.decode(data), page = ifds[0];
                _utif.default.decodeImages(data, ifds);
                var rgba = _utif.default.toRGBA8(page);
                return {
                    data: Buffer.from(rgba),
                    width: page.t256[0],
                    height: page.t257[0]
                };
            })),
            encoders: (0, _defineProperty2.default)({}, "image/tiff", (function(image) {
                var tiff = _utif.default.encodeImage(image.bitmap.data, image.bitmap.width, image.bitmap.height);
                return Buffer.from(tiff);
            }))
        };
    };
}(es$n);

var es$m = {}, omggif = {};

function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
    for (var min_code_size = code_stream[p++], clear_code = 1 << min_code_size, eoi_code = clear_code + 1, next_code = eoi_code + 1, cur_code_size = min_code_size + 1, code_mask = (1 << cur_code_size) - 1, cur_shift = 0, cur = 0, op = 0, subblock_size = code_stream[p++], code_table = new Int32Array(4096), prev_code = null; ;) {
        for (;cur_shift < 16 && 0 !== subblock_size; ) cur |= code_stream[p++] << cur_shift, 
        cur_shift += 8, 1 === subblock_size ? subblock_size = code_stream[p++] : --subblock_size;
        if (cur_shift < cur_code_size) break;
        var code = cur & code_mask;
        if (cur >>= cur_code_size, cur_shift -= cur_code_size, code !== clear_code) {
            if (code === eoi_code) break;
            for (var chase_code = code < next_code ? code : prev_code, chase_length = 0, chase = chase_code; chase > clear_code; ) chase = code_table[chase] >> 8, 
            ++chase_length;
            var k = chase;
            if (op + chase_length + (chase_code !== code ? 1 : 0) > output_length) return void console.log("Warning, gif stream longer than expected.");
            output[op++] = k;
            var b = op += chase_length;
            for (chase_code !== code && (output[op++] = k), chase = chase_code; chase_length--; ) chase = code_table[chase], 
            output[--b] = 0xff & chase, chase >>= 8;
            null !== prev_code && next_code < 4096 && (code_table[next_code++] = prev_code << 8 | k, 
            next_code >= code_mask + 1 && cur_code_size < 12 && (++cur_code_size, code_mask = code_mask << 1 | 1)), 
            prev_code = code;
        } else next_code = eoi_code + 1, code_mask = (1 << (cur_code_size = min_code_size + 1)) - 1, 
        prev_code = null;
    }
    return op !== output_length && console.log("Warning, gif stream shorter than expected."), 
    output;
}

try {
    omggif.GifWriter = function GifWriter(buf, width, height, gopts) {
        var p = 0, loop_count = void 0 === (gopts = void 0 === gopts ? {} : gopts).loop ? null : gopts.loop, global_palette = void 0 === gopts.palette ? null : gopts.palette;
        if (width <= 0 || height <= 0 || width > 65535 || height > 65535) throw new Error("Width/Height invalid.");
        function check_palette_and_num_colors(palette) {
            var num_colors = palette.length;
            if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
            return num_colors;
        }
        buf[p++] = 0x47, buf[p++] = 0x49, buf[p++] = 0x46, buf[p++] = 0x38, buf[p++] = 0x39, 
        buf[p++] = 0x61;
        var gp_num_colors_pow2 = 0, background = 0;
        if (null !== global_palette) {
            for (var gp_num_colors = check_palette_and_num_colors(global_palette); gp_num_colors >>= 1; ) ++gp_num_colors_pow2;
            if (gp_num_colors = 1 << gp_num_colors_pow2, --gp_num_colors_pow2, void 0 !== gopts.background) {
                if ((background = gopts.background) >= gp_num_colors) throw new Error("Background index out of range.");
                if (0 === background) throw new Error("Background index explicitly passed as 0.");
            }
        }
        if (buf[p++] = 0xff & width, buf[p++] = width >> 8 & 0xff, buf[p++] = 0xff & height, 
        buf[p++] = height >> 8 & 0xff, buf[p++] = (null !== global_palette ? 0x80 : 0) | gp_num_colors_pow2, 
        buf[p++] = background, buf[p++] = 0, null !== global_palette) for (var i = 0, il = global_palette.length; i < il; ++i) {
            var rgb = global_palette[i];
            buf[p++] = rgb >> 16 & 0xff, buf[p++] = rgb >> 8 & 0xff, buf[p++] = 0xff & rgb;
        }
        if (null !== loop_count) {
            if (loop_count < 0 || loop_count > 65535) throw new Error("Loop count invalid.");
            buf[p++] = 0x21, buf[p++] = 0xff, buf[p++] = 0x0b, buf[p++] = 0x4e, buf[p++] = 0x45, 
            buf[p++] = 0x54, buf[p++] = 0x53, buf[p++] = 0x43, buf[p++] = 0x41, buf[p++] = 0x50, 
            buf[p++] = 0x45, buf[p++] = 0x32, buf[p++] = 0x2e, buf[p++] = 0x30, buf[p++] = 0x03, 
            buf[p++] = 0x01, buf[p++] = 0xff & loop_count, buf[p++] = loop_count >> 8 & 0xff, 
            buf[p++] = 0x00;
        }
        var ended = !1;
        this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
            if (!0 === ended && (--p, ended = !1), opts = void 0 === opts ? {} : opts, x < 0 || y < 0 || x > 65535 || y > 65535) throw new Error("x/y invalid.");
            if (w <= 0 || h <= 0 || w > 65535 || h > 65535) throw new Error("Width/Height invalid.");
            if (indexed_pixels.length < w * h) throw new Error("Not enough pixels for the frame size.");
            var using_local_palette = !0, palette = opts.palette;
            if (null == palette && (using_local_palette = !1, palette = global_palette), null == palette) throw new Error("Must supply either a local or global palette.");
            for (var num_colors = check_palette_and_num_colors(palette), min_code_size = 0; num_colors >>= 1; ) ++min_code_size;
            num_colors = 1 << min_code_size;
            var delay = void 0 === opts.delay ? 0 : opts.delay, disposal = void 0 === opts.disposal ? 0 : opts.disposal;
            if (disposal < 0 || disposal > 3) throw new Error("Disposal out of range.");
            var use_transparency = !1, transparent_index = 0;
            if (void 0 !== opts.transparent && null !== opts.transparent && (use_transparency = !0, 
            (transparent_index = opts.transparent) < 0 || transparent_index >= num_colors)) throw new Error("Transparent color index.");
            if ((0 !== disposal || use_transparency || 0 !== delay) && (buf[p++] = 0x21, buf[p++] = 0xf9, 
            buf[p++] = 4, buf[p++] = disposal << 2 | (!0 === use_transparency ? 1 : 0), buf[p++] = 0xff & delay, 
            buf[p++] = delay >> 8 & 0xff, buf[p++] = transparent_index, buf[p++] = 0), buf[p++] = 0x2c, 
            buf[p++] = 0xff & x, buf[p++] = x >> 8 & 0xff, buf[p++] = 0xff & y, buf[p++] = y >> 8 & 0xff, 
            buf[p++] = 0xff & w, buf[p++] = w >> 8 & 0xff, buf[p++] = 0xff & h, buf[p++] = h >> 8 & 0xff, 
            buf[p++] = !0 === using_local_palette ? 0x80 | min_code_size - 1 : 0, !0 === using_local_palette) for (var i = 0, il = palette.length; i < il; ++i) {
                var rgb = palette[i];
                buf[p++] = rgb >> 16 & 0xff, buf[p++] = rgb >> 8 & 0xff, buf[p++] = 0xff & rgb;
            }
            return p = function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
                buf[p++] = min_code_size;
                var cur_subblock = p++, clear_code = 1 << min_code_size, code_mask = clear_code - 1, eoi_code = clear_code + 1, next_code = eoi_code + 1, cur_code_size = min_code_size + 1, cur_shift = 0, cur = 0;
                function emit_bytes_to_buffer(bit_block_size) {
                    for (;cur_shift >= bit_block_size; ) buf[p++] = 0xff & cur, cur >>= 8, cur_shift -= 8, 
                    p === cur_subblock + 256 && (buf[cur_subblock] = 255, cur_subblock = p++);
                }
                function emit_code(c) {
                    cur |= c << cur_shift, cur_shift += cur_code_size, emit_bytes_to_buffer(8);
                }
                var ib_code = index_stream[0] & code_mask, code_table = {};
                emit_code(clear_code);
                for (var i = 1, il = index_stream.length; i < il; ++i) {
                    var k = index_stream[i] & code_mask, cur_key = ib_code << 8 | k, cur_code = code_table[cur_key];
                    if (void 0 === cur_code) {
                        for (cur |= ib_code << cur_shift, cur_shift += cur_code_size; cur_shift >= 8; ) buf[p++] = 0xff & cur, 
                        cur >>= 8, cur_shift -= 8, p === cur_subblock + 256 && (buf[cur_subblock] = 255, 
                        cur_subblock = p++);
                        4096 === next_code ? (emit_code(clear_code), next_code = eoi_code + 1, cur_code_size = min_code_size + 1, 
                        code_table = {}) : (next_code >= 1 << cur_code_size && ++cur_code_size, code_table[cur_key] = next_code++), 
                        ib_code = k;
                    } else ib_code = cur_code;
                }
                return emit_code(ib_code), emit_code(eoi_code), emit_bytes_to_buffer(1), cur_subblock + 1 === p ? buf[cur_subblock] = 0 : (buf[cur_subblock] = p - cur_subblock - 1, 
                buf[p++] = 0), p;
            }(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels), p;
        }, this.end = function() {
            return !1 === ended && (buf[p++] = 0x3b, ended = !0), p;
        }, this.getOutputBuffer = function() {
            return buf;
        }, this.setOutputBuffer = function(v) {
            buf = v;
        }, this.getOutputBufferPosition = function() {
            return p;
        }, this.setOutputBufferPosition = function(v) {
            p = v;
        };
    }, omggif.GifReader = function GifReader(buf) {
        var p = 0;
        if (0x47 !== buf[p++] || 0x49 !== buf[p++] || 0x46 !== buf[p++] || 0x38 !== buf[p++] || 0x38 != (buf[p++] + 1 & 0xfd) || 0x61 !== buf[p++]) throw new Error("Invalid GIF 87a/89a header.");
        var width = buf[p++] | buf[p++] << 8, height = buf[p++] | buf[p++] << 8, pf0 = buf[p++], global_palette_flag = pf0 >> 7, num_global_colors = 1 << 1 + (0x7 & pf0);
        buf[p++], buf[p++];
        var global_palette_offset = null, global_palette_size = null;
        global_palette_flag && (global_palette_offset = p, global_palette_size = num_global_colors, 
        p += 3 * num_global_colors);
        var no_eof = !0, frames = [], delay = 0, transparent_index = null, disposal = 0, loop_count = null;
        for (this.width = width, this.height = height; no_eof && p < buf.length; ) switch (buf[p++]) {
          case 0x21:
            switch (buf[p++]) {
              case 0xff:
                if (0x0b !== buf[p] || 0x4e == buf[p + 1] && 0x45 == buf[p + 2] && 0x54 == buf[p + 3] && 0x53 == buf[p + 4] && 0x43 == buf[p + 5] && 0x41 == buf[p + 6] && 0x50 == buf[p + 7] && 0x45 == buf[p + 8] && 0x32 == buf[p + 9] && 0x2e == buf[p + 10] && 0x30 == buf[p + 11] && 0x03 == buf[p + 12] && 0x01 == buf[p + 13] && 0 == buf[p + 16]) p += 14, 
                loop_count = buf[p++] | buf[p++] << 8, p++; else for (p += 12; ;) {
                    if (!((block_size = buf[p++]) >= 0)) throw Error("Invalid block size");
                    if (0 === block_size) break;
                    p += block_size;
                }
                break;

              case 0xf9:
                if (0x4 !== buf[p++] || 0 !== buf[p + 4]) throw new Error("Invalid graphics extension block.");
                var pf1 = buf[p++];
                delay = buf[p++] | buf[p++] << 8, transparent_index = buf[p++], 0 == (1 & pf1) && (transparent_index = null), 
                disposal = pf1 >> 2 & 0x7, p++;
                break;

              case 0xfe:
                for (;;) {
                    if (!((block_size = buf[p++]) >= 0)) throw Error("Invalid block size");
                    if (0 === block_size) break;
                    p += block_size;
                }
                break;

              default:
                throw new Error("Unknown graphic control label: 0x" + buf[p - 1].toString(16));
            }
            break;

          case 0x2c:
            var x = buf[p++] | buf[p++] << 8, y = buf[p++] | buf[p++] << 8, w = buf[p++] | buf[p++] << 8, h = buf[p++] | buf[p++] << 8, pf2 = buf[p++], interlace_flag = pf2 >> 6 & 1, num_local_colors = 1 << 1 + (0x7 & pf2), palette_offset = global_palette_offset, palette_size = global_palette_size, has_local_palette = !1;
            pf2 >> 7 && (has_local_palette = !0, palette_offset = p, palette_size = num_local_colors, 
            p += 3 * num_local_colors);
            var data_offset = p;
            for (p++; ;) {
                var block_size;
                if (!((block_size = buf[p++]) >= 0)) throw Error("Invalid block size");
                if (0 === block_size) break;
                p += block_size;
            }
            frames.push({
                x,
                y,
                width: w,
                height: h,
                has_local_palette,
                palette_offset,
                palette_size,
                data_offset,
                data_length: p - data_offset,
                transparent_index,
                interlaced: !!interlace_flag,
                delay,
                disposal
            });
            break;

          case 0x3b:
            no_eof = !1;
            break;

          default:
            throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
        }
        this.numFrames = function() {
            return frames.length;
        }, this.loopCount = function() {
            return loop_count;
        }, this.frameInfo = function(frame_num) {
            if (frame_num < 0 || frame_num >= frames.length) throw new Error("Frame index out of range.");
            return frames[frame_num];
        }, this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
            var frame = this.frameInfo(frame_num), num_pixels = frame.width * frame.height, index_stream = new Uint8Array(num_pixels);
            GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
            var palette_offset = frame.palette_offset, trans = frame.transparent_index;
            null === trans && (trans = 256);
            var framewidth = frame.width, framestride = width - framewidth, xleft = framewidth, opbeg = 4 * (frame.y * width + frame.x), opend = 4 * ((frame.y + frame.height) * width + frame.x), op = opbeg, scanstride = 4 * framestride;
            !0 === frame.interlaced && (scanstride += 4 * width * 7);
            for (var interlaceskip = 8, i = 0, il = index_stream.length; i < il; ++i) {
                var index = index_stream[i];
                if (0 === xleft && (xleft = framewidth, (op += scanstride) >= opend && (scanstride = 4 * framestride + 4 * width * (interlaceskip - 1), 
                op = opbeg + (framewidth + framestride) * (interlaceskip << 1), interlaceskip >>= 1)), 
                index === trans) op += 4; else {
                    var r = buf[palette_offset + 3 * index], g = buf[palette_offset + 3 * index + 1], b = buf[palette_offset + 3 * index + 2];
                    pixels[op++] = b, pixels[op++] = g, pixels[op++] = r, pixels[op++] = 255;
                }
                --xleft;
            }
        }, this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
            var frame = this.frameInfo(frame_num), num_pixels = frame.width * frame.height, index_stream = new Uint8Array(num_pixels);
            GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
            var palette_offset = frame.palette_offset, trans = frame.transparent_index;
            null === trans && (trans = 256);
            var framewidth = frame.width, framestride = width - framewidth, xleft = framewidth, opbeg = 4 * (frame.y * width + frame.x), opend = 4 * ((frame.y + frame.height) * width + frame.x), op = opbeg, scanstride = 4 * framestride;
            !0 === frame.interlaced && (scanstride += 4 * width * 7);
            for (var interlaceskip = 8, i = 0, il = index_stream.length; i < il; ++i) {
                var index = index_stream[i];
                if (0 === xleft && (xleft = framewidth, (op += scanstride) >= opend && (scanstride = 4 * framestride + 4 * width * (interlaceskip - 1), 
                op = opbeg + (framewidth + framestride) * (interlaceskip << 1), interlaceskip >>= 1)), 
                index === trans) op += 4; else {
                    var r = buf[palette_offset + 3 * index], g = buf[palette_offset + 3 * index + 1], b = buf[palette_offset + 3 * index + 2];
                    pixels[op++] = r, pixels[op++] = g, pixels[op++] = b, pixels[op++] = 255;
                }
                --xleft;
            }
        };
    };
} catch (e) {}

class BitmapImage$2 {
    constructor(...args) {
        if (0 === args.length) throw new Error("constructor requires parameters");
        const firstArg = args[0];
        if (null !== firstArg && "object" == typeof firstArg) if (firstArg instanceof BitmapImage$2) {
            const sourceBitmap = firstArg.bitmap;
            this.bitmap = {
                width: sourceBitmap.width,
                height: sourceBitmap.height,
                data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)
            }, sourceBitmap.data.copy(this.bitmap.data);
        } else {
            if (!(firstArg.width && firstArg.height && firstArg.data)) throw new Error("unrecognized constructor parameters");
            this.bitmap = firstArg;
        } else {
            if ("number" != typeof firstArg || "number" != typeof args[1]) throw new Error("unrecognized constructor parameters");
            {
                const width = firstArg, height = args[1], thirdArg = args[2];
                this.bitmap = {
                    width,
                    height
                }, Buffer.isBuffer(thirdArg) ? this.bitmap.data = thirdArg : (this.bitmap.data = new Buffer(width * height * 4), 
                "number" == typeof thirdArg && this.fillRGBA(thirdArg));
            }
        }
    }
    blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {
        if (fromX + fromWidth > this.bitmap.width) throw new Error("copy exceeds width of source bitmap");
        if (toX + fromWidth > toImage.bitmap.width) throw new Error("copy exceeds width of target bitmap");
        if (fromY + fromHeight > this.bitmap.height) throw new Error("copy exceeds height of source bitmap");
        if (toY + fromHeight > toImage.bitmap.height) throw new Erro("copy exceeds height of target bitmap");
        const sourceBuf = this.bitmap.data, targetBuf = toImage.bitmap.data, sourceByteWidth = 4 * this.bitmap.width, targetByteWidth = 4 * toImage.bitmap.width, copyByteWidth = 4 * fromWidth;
        let si = fromY * sourceByteWidth + 4 * fromX, ti = toY * targetByteWidth + 4 * toX;
        for (;--fromHeight >= 0; ) sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth), 
        si += sourceByteWidth, ti += targetByteWidth;
        return this;
    }
    fillRGBA(rgba) {
        const buf = this.bitmap.data, bufByteWidth = 4 * this.bitmap.height;
        let bi = 0;
        for (;bi < bufByteWidth; ) buf.writeUInt32BE(rgba, bi), bi += 4;
        for (;bi < buf.length; ) buf.copy(buf, bi, 0, bufByteWidth), bi += bufByteWidth;
        return this;
    }
    getRGBA(x, y) {
        const bi = 4 * (y * this.bitmap.width + x);
        return this.bitmap.data.readUInt32BE(bi);
    }
    getRGBASet() {
        const rgbaSet = new Set, buf = this.bitmap.data;
        for (let bi = 0; bi < buf.length; bi += 4) rgbaSet.add(buf.readUInt32BE(bi, !0));
        return rgbaSet;
    }
    greyscale() {
        const buf = this.bitmap.data;
        return this.scan(0, 0, this.bitmap.width, this.bitmap.height, ((x, y, idx) => {
            const grey = Math.round(0.299 * buf[idx] + 0.587 * buf[idx + 1] + 0.114 * buf[idx + 2]);
            buf[idx] = grey, buf[idx + 1] = grey, buf[idx + 2] = grey;
        })), this;
    }
    reframe(xOffset, yOffset, width, height, fillRGBA) {
        const cropX = xOffset < 0 ? 0 : xOffset, cropY = yOffset < 0 ? 0 : yOffset, cropWidth = width + cropX > this.bitmap.width ? this.bitmap.width - cropX : width, cropHeight = height + cropY > this.bitmap.height ? this.bitmap.height - cropY : height, newX = xOffset < 0 ? -xOffset : 0, newY = yOffset < 0 ? -yOffset : 0;
        let image;
        if (void 0 === fillRGBA) {
            if (cropX !== xOffset || cropY != yOffset || cropWidth !== width || cropHeight !== height) throw new GifError("fillRGBA required for this reframing");
            image = new BitmapImage$2(width, height);
        } else image = new BitmapImage$2(width, height, fillRGBA);
        return this.blit(image, newX, newY, cropX, cropY, cropWidth, cropHeight), this.bitmap = image.bitmap, 
        this;
    }
    scale(factor) {
        if (1 === factor) return;
        if (!Number.isInteger(factor) || factor < 1) throw new Error("the scale must be an integer >= 1");
        const sourceWidth = this.bitmap.width, sourceHeight = this.bitmap.height, destByteWidth = sourceWidth * factor * 4, sourceBuf = this.bitmap.data, destBuf = new Buffer(sourceHeight * destByteWidth * factor);
        let priorDestRowIndex, sourceIndex = 0, destIndex = 0;
        for (let y = 0; y < sourceHeight; ++y) {
            priorDestRowIndex = destIndex;
            for (let x = 0; x < sourceWidth; ++x) {
                const color = sourceBuf.readUInt32BE(sourceIndex, !0);
                for (let cx = 0; cx < factor; ++cx) destBuf.writeUInt32BE(color, destIndex), destIndex += 4;
                sourceIndex += 4;
            }
            for (let cy = 1; cy < factor; ++cy) destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex), 
            destIndex += destByteWidth, priorDestRowIndex += destByteWidth;
        }
        return this.bitmap = {
            width: sourceWidth * factor,
            height: sourceHeight * factor,
            data: destBuf
        }, this;
    }
    scanAllCoords(scanHandler) {
        const width = this.bitmap.width, bufferLength = this.bitmap.data.length;
        let x = 0, y = 0;
        for (let bi = 0; bi < bufferLength; bi += 4) scanHandler(x, y, bi), ++x === width && (x = 0, 
        ++y);
    }
    scanAllIndexes(scanHandler) {
        const bufferLength = this.bitmap.data.length;
        for (let bi = 0; bi < bufferLength; bi += 4) scanHandler(bi);
    }
}

var bitmapimage = BitmapImage$2, gif = {};

class Gif$2 {
    constructor(buffer, frames, spec) {
        this.width = spec.width, this.height = spec.height, this.loops = spec.loops, this.usesTransparency = spec.usesTransparency, 
        this.colorScope = spec.colorScope, this.frames = frames, this.buffer = buffer;
    }
}

Gif$2.GlobalColorsPreferred = 0, Gif$2.GlobalColorsOnly = 1, Gif$2.LocalColorsOnly = 2;

class GifError$3 extends Error {
    constructor(messageOrError) {
        super(messageOrError), messageOrError instanceof Error && (this.stack = "Gif" + messageOrError.stack);
    }
}

gif.Gif = Gif$2, gif.GifError = GifError$3;

var gifcodec = {}, gifutil = {}, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __hasOwnProp = Object.prototype.hasOwnProperty, __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
        get: all[name],
        enumerable: !0
    });
}, __toCommonJS = (cache => (module2, temp) => cache && cache.get(module2) || (temp = ((target, module2, copyDefault, desc) => {
    if (module2 && "object" == typeof module2 || "function" == typeof module2) for (let key of __getOwnPropNames(module2)) __hasOwnProp.call(target, key) || __defProp(target, key, {
        get: () => module2[key],
        enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
    });
    return target;
})(__defProp({}, "__esModule", {
    value: !0
}), module2), cache && cache.set(module2, temp), temp))("undefined" != typeof WeakMap ? new WeakMap : 0), __publicField = (obj, key, value) => (((obj, key, value) => {
    key in obj ? __defProp(obj, key, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value
    }) : obj[key] = value;
})(obj, "symbol" != typeof key ? key + "" : key, value), value), src_exports = {};

__export(src_exports, {
    applyPalette: () => applyPalette,
    applyPaletteSync: () => applyPaletteSync,
    buildPalette: () => buildPalette,
    buildPaletteSync: () => buildPaletteSync,
    constants: () => constants_exports,
    conversion: () => conversion_exports,
    distance: () => distance_exports,
    image: () => image_exports,
    palette: () => palette_exports,
    quality: () => quality_exports,
    utils: () => utils_exports
});

var constants_exports = {};

__export(constants_exports, {
    bt709: () => bt709_exports
});

var bt709_exports = {};

__export(bt709_exports, {
    Y: () => Y,
    x: () => x,
    y: () => y
});

var Y = (Y2 => (Y2[Y2.RED = 0.2126] = "RED", Y2[Y2.GREEN = 0.7152] = "GREEN", Y2[Y2.BLUE = 0.0722] = "BLUE", 
Y2[Y2.WHITE = 1] = "WHITE", Y2))(Y || {}), x = (x2 => (x2[x2.RED = 0.64] = "RED", 
x2[x2.GREEN = 0.3] = "GREEN", x2[x2.BLUE = 0.15] = "BLUE", x2[x2.WHITE = 0.3127] = "WHITE", 
x2))(x || {}), y = (y2 => (y2[y2.RED = 0.33] = "RED", y2[y2.GREEN = 0.6] = "GREEN", 
y2[y2.BLUE = 0.06] = "BLUE", y2[y2.WHITE = 0.329] = "WHITE", y2))(y || {}), conversion_exports = {};

function correctGamma(n) {
    return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;
}

function rgb2xyz(r, g, b) {
    return {
        x: 0.4124 * (r = correctGamma(r / 255)) + 0.3576 * (g = correctGamma(g / 255)) + 0.1805 * (b = correctGamma(b / 255)),
        y: 0.2126 * r + 0.7152 * g + 0.0722 * b,
        z: 0.0193 * r + 0.1192 * g + 0.9505 * b
    };
}

__export(conversion_exports, {
    lab2rgb: () => lab2rgb,
    lab2xyz: () => lab2xyz,
    rgb2hsl: () => rgb2hsl$1,
    rgb2lab: () => rgb2lab,
    rgb2xyz: () => rgb2xyz,
    xyz2lab: () => xyz2lab,
    xyz2rgb: () => xyz2rgb
});

var arithmetic_exports = {};

function degrees2radians(n) {
    return n * (Math.PI / 180);
}

function max3(a, b, c) {
    let m = a;
    return m < b && (m = b), m < c && (m = c), m;
}

function min3(a, b, c) {
    let m = a;
    return m > b && (m = b), m > c && (m = c), m;
}

function intInRange(value, low, high) {
    return value > high && (value = high), value < low && (value = low), 0 | value;
}

function inRange0to255Rounded(n) {
    return (n = Math.round(n)) > 255 ? n = 255 : n < 0 && (n = 0), n;
}

function inRange0to255(n) {
    return n > 255 ? n = 255 : n < 0 && (n = 0), n;
}

function stableSort(arrayToSort, callback) {
    const type = typeof arrayToSort[0];
    let sorted;
    if ("number" === type || "string" === type) {
        const ord = Object.create(null);
        for (let i = 0, l = arrayToSort.length; i < l; i++) {
            const val = arrayToSort[i];
            ord[val] || 0 === ord[val] || (ord[val] = i);
        }
        sorted = arrayToSort.sort(((a, b) => callback(a, b) || ord[a] - ord[b]));
    } else {
        const ord2 = arrayToSort.slice(0);
        sorted = arrayToSort.sort(((a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b)));
    }
    return sorted;
}

function rgb2hsl$1(r, g, b) {
    const min = min3(r, g, b), max = max3(r, g, b), delta = max - min, l = (min + max) / 510;
    let s = 0;
    l > 0 && l < 1 && (s = delta / (l < 0.5 ? max + min : 510 - max - min));
    let h = 0;
    return delta > 0 && (h = max === r ? (g - b) / delta : max === g ? 2 + (b - r) / delta : 4 + (r - g) / delta, 
    h *= 60, h < 0 && (h += 360)), {
        h,
        s,
        l
    };
}

function pivot(n) {
    return n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
}

function xyz2lab(x2, y2, z) {
    if (x2 = pivot(x2 / .95047), y2 = pivot(y2 / 1), z = pivot(z / 1.08883), 116 * y2 - 16 < 0) throw new Error("xxx");
    return {
        L: Math.max(0, 116 * y2 - 16),
        a: 500 * (x2 - y2),
        b: 200 * (y2 - z)
    };
}

function rgb2lab(r, g, b) {
    const xyz = rgb2xyz(r, g, b);
    return xyz2lab(xyz.x, xyz.y, xyz.z);
}

function pivot2(n) {
    return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;
}

function lab2xyz(L, a, b) {
    const y2 = (L + 16) / 116, z = y2 - b / 200;
    return {
        x: .95047 * pivot2(a / 500 + y2),
        y: 1 * pivot2(y2),
        z: 1.08883 * pivot2(z)
    };
}

function correctGamma2(n) {
    return n > 31308e-7 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;
}

function xyz2rgb(x2, y2, z) {
    const r = correctGamma2(3.2406 * x2 + -1.5372 * y2 + -0.4986 * z), g = correctGamma2(-0.9689 * x2 + 1.8758 * y2 + 0.0415 * z), b = correctGamma2(0.0557 * x2 + -0.204 * y2 + 1.057 * z);
    return {
        r: inRange0to255Rounded(255 * r),
        g: inRange0to255Rounded(255 * g),
        b: inRange0to255Rounded(255 * b)
    };
}

function lab2rgb(L, a, b) {
    const xyz = lab2xyz(L, a, b);
    return xyz2rgb(xyz.x, xyz.y, xyz.z);
}

__export(arithmetic_exports, {
    degrees2radians: () => degrees2radians,
    inRange0to255: () => inRange0to255,
    inRange0to255Rounded: () => inRange0to255Rounded,
    intInRange: () => intInRange,
    max3: () => max3,
    min3: () => min3,
    stableSort: () => stableSort
});

var distance_exports = {};

__export(distance_exports, {
    AbstractDistanceCalculator: () => AbstractDistanceCalculator,
    AbstractEuclidean: () => AbstractEuclidean,
    AbstractManhattan: () => AbstractManhattan,
    CIE94GraphicArts: () => CIE94GraphicArts,
    CIE94Textiles: () => CIE94Textiles,
    CIEDE2000: () => CIEDE2000,
    CMetric: () => CMetric,
    Euclidean: () => Euclidean,
    EuclideanBT709: () => EuclideanBT709,
    EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,
    Manhattan: () => Manhattan,
    ManhattanBT709: () => ManhattanBT709,
    ManhattanNommyde: () => ManhattanNommyde,
    PNGQuant: () => PNGQuant
});

var AbstractDistanceCalculator = class {
    constructor() {
        __publicField(this, "_maxDistance"), __publicField(this, "_whitePoint"), this._setDefaults(), 
        this.setWhitePoint(255, 255, 255, 255);
    }
    setWhitePoint(r, g, b, a) {
        this._whitePoint = {
            r: r > 0 ? 255 / r : 0,
            g: g > 0 ? 255 / g : 0,
            b: b > 0 ? 255 / b : 0,
            a: a > 0 ? 255 / a : 0
        }, this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
    }
    calculateNormalized(colorA, colorB) {
        return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
    }
}, AbstractCIE94 = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b)), dL = lab1.L - lab2.L, dA = lab1.a - lab2.a, dB = lab1.b - lab2.b, c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b), dC = c1 - Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);
        let deltaH = dA * dA + dB * dB - dC * dC;
        deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
        const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
        return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);
    }
}, CIE94Textiles = class extends AbstractCIE94 {
    _setDefaults() {
        this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 12.5 / 255;
    }
}, CIE94GraphicArts = class extends AbstractCIE94 {
    _setDefaults() {
        this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 25 / 255;
    }
}, _CIEDE2000 = class extends AbstractDistanceCalculator {
    _setDefaults() {}
    static _calculatehp(b, ap) {
        const hp = Math.atan2(b, ap);
        return hp >= 0 ? hp : hp + _CIEDE2000._deg360InRad;
    }
    static _calculateRT(ahp, aCp) {
        const aCp_to_7 = aCp ** 7, R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7)), delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
        return -Math.sin(2 * delta_theta) * R_C;
    }
    static _calculateT(ahp) {
        return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(2 * ahp) + 0.32 * Math.cos(3 * ahp + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(4 * ahp - _CIEDE2000._deg63InRad);
    }
    static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {
        const hpSum = h1p + h2p;
        return 0 === C1pC2p ? hpSum : h_bar <= _CIEDE2000._deg180InRad ? hpSum / 2 : hpSum < _CIEDE2000._deg360InRad ? (hpSum + _CIEDE2000._deg360InRad) / 2 : (hpSum - _CIEDE2000._deg360InRad) / 2;
    }
    static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {
        let dhp;
        return dhp = 0 === C1pC2p ? 0 : h_bar <= _CIEDE2000._deg180InRad ? h2p - h1p : h2p <= h1p ? h2p - h1p + _CIEDE2000._deg360InRad : h2p - h1p - _CIEDE2000._deg360InRad, 
        2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
    }
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b)), dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA, dE2 = this.calculateRawInLab(lab1, lab2);
        return Math.sqrt(dE2 + dA * dA);
    }
    calculateRawInLab(Lab1, Lab2) {
        const L1 = Lab1.L, a1 = Lab1.a, b1 = Lab1.b, L2 = Lab2.L, a2 = Lab2.a, b2 = Lab2.b, pow_a_C1_C2_to_7 = ((Math.sqrt(a1 * a1 + b1 * b1) + Math.sqrt(a2 * a2 + b2 * b2)) / 2) ** 7, G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7))), a1p = (1 + G) * a1, a2p = (1 + G) * a2, C1p = Math.sqrt(a1p * a1p + b1 * b1), C2p = Math.sqrt(a2p * a2p + b2 * b2), C1pC2p = C1p * C2p, h1p = _CIEDE2000._calculatehp(b1, a1p), h2p = _CIEDE2000._calculatehp(b2, a2p), h_bar = Math.abs(h1p - h2p), dLp = L2 - L1, dCp = C2p - C1p, dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p), ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p), aCp = (C1p + C2p) / 2, aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2, dCpSC = dCp / (1 + 0.045 * aCp), dHpSH = dHp / (1 + 0.015 * _CIEDE2000._calculateT(ahp) * aCp);
        return (dLp / (1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square))) ** 2 + dCpSC ** 2 + dHpSH ** 2 + _CIEDE2000._calculateRT(ahp, aCp) * dCpSC * dHpSH;
    }
}, CIEDE2000 = _CIEDE2000;

__publicField(CIEDE2000, "_kA", 25 / 255), __publicField(CIEDE2000, "_pow25to7", 25 ** 7), 
__publicField(CIEDE2000, "_deg360InRad", degrees2radians(360)), __publicField(CIEDE2000, "_deg180InRad", degrees2radians(180)), 
__publicField(CIEDE2000, "_deg30InRad", degrees2radians(30)), __publicField(CIEDE2000, "_deg6InRad", degrees2radians(6)), 
__publicField(CIEDE2000, "_deg63InRad", degrees2radians(63)), __publicField(CIEDE2000, "_deg275InRad", degrees2radians(275)), 
__publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));

var CMetric = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const rmean = (r1 + r2) / 2 * this._whitePoint.r, r = (r1 - r2) * this._whitePoint.r, g = (g1 - g2) * this._whitePoint.g, b = (b1 - b2) * this._whitePoint.b, dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8), dA = (a2 - a1) * this._whitePoint.a;
        return Math.sqrt(dE + dA * dA);
    }
    _setDefaults() {}
}, AbstractEuclidean = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
        return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
    }
}, Euclidean = class extends AbstractEuclidean {
    _setDefaults() {
        this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
    }
}, EuclideanBT709 = class extends AbstractEuclidean {
    _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
    }
}, EuclideanBT709NoAlpha = class extends AbstractEuclidean {
    _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 0;
    }
}, AbstractManhattan = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        let dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
        return dR < 0 && (dR = 0 - dR), dG < 0 && (dG = 0 - dG), dB < 0 && (dB = 0 - dB), 
        dA < 0 && (dA = 0 - dA), this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
    }
}, Manhattan = class extends AbstractManhattan {
    _setDefaults() {
        this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
    }
}, ManhattanNommyde = class extends AbstractManhattan {
    _setDefaults() {
        this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
    }
}, ManhattanBT709 = class extends AbstractManhattan {
    _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
    }
}, PNGQuant = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const alphas = (a2 - a1) * this._whitePoint.a;
        return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
    }
    _colordifferenceCh(x2, y2, alphas) {
        const black = x2 - y2, white = black + alphas;
        return black * black + white * white;
    }
    _setDefaults() {}
}, palette_exports = {};

__export(palette_exports, {
    AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,
    ColorHistogram: () => ColorHistogram,
    NeuQuant: () => NeuQuant$1,
    NeuQuantFloat: () => NeuQuantFloat,
    RGBQuant: () => RGBQuant,
    WuColorCube: () => WuColorCube,
    WuQuant: () => WuQuant
});

var AbstractPaletteQuantizer = class {
    quantizeSync() {
        for (const value of this.quantize()) if (value.palette) return value.palette;
        throw new Error("unreachable");
    }
}, Point = class {
    constructor() {
        __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), 
        __publicField(this, "uint32"), __publicField(this, "rgba"), this.uint32 = -1 >>> 0, 
        this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, 
        this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
    }
    static createByQuadruplet(quadruplet) {
        const point = new Point;
        return point.r = 0 | quadruplet[0], point.g = 0 | quadruplet[1], point.b = 0 | quadruplet[2], 
        point.a = 0 | quadruplet[3], point._loadUINT32(), point._loadQuadruplet(), point;
    }
    static createByRGBA(red, green, blue, alpha) {
        const point = new Point;
        return point.r = 0 | red, point.g = 0 | green, point.b = 0 | blue, point.a = 0 | alpha, 
        point._loadUINT32(), point._loadQuadruplet(), point;
    }
    static createByUint32(uint32) {
        const point = new Point;
        return point.uint32 = uint32 >>> 0, point._loadRGBA(), point._loadQuadruplet(), 
        point;
    }
    from(point) {
        this.r = point.r, this.g = point.g, this.b = point.b, this.a = point.a, this.uint32 = point.uint32, 
        this.rgba[0] = point.r, this.rgba[1] = point.g, this.rgba[2] = point.b, this.rgba[3] = point.a;
    }
    getLuminosity(useAlphaChannel) {
        let r = this.r, g = this.g, b = this.b;
        return useAlphaChannel && (r = Math.min(255, 255 - this.a + this.a * r / 255), g = Math.min(255, 255 - this.a + this.a * g / 255), 
        b = Math.min(255, 255 - this.a + this.a * b / 255)), 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }
    _loadUINT32() {
        this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
    }
    _loadRGBA() {
        this.r = 255 & this.uint32, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, 
        this.a = this.uint32 >>> 24 & 255;
    }
    _loadQuadruplet() {
        this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
    }
}, PointContainer = class {
    constructor() {
        __publicField(this, "_pointArray"), __publicField(this, "_width"), __publicField(this, "_height"), 
        this._width = 0, this._height = 0, this._pointArray = [];
    }
    getWidth() {
        return this._width;
    }
    getHeight() {
        return this._height;
    }
    setWidth(width) {
        this._width = width;
    }
    setHeight(height) {
        this._height = height;
    }
    getPointArray() {
        return this._pointArray;
    }
    clone() {
        const clone = new PointContainer;
        clone._width = this._width, clone._height = this._height;
        for (let i = 0, l = this._pointArray.length; i < l; i++) clone._pointArray[i] = Point.createByUint32(0 | this._pointArray[i].uint32);
        return clone;
    }
    toUint32Array() {
        const l = this._pointArray.length, uint32Array = new Uint32Array(l);
        for (let i = 0; i < l; i++) uint32Array[i] = this._pointArray[i].uint32;
        return uint32Array;
    }
    toUint8Array() {
        return new Uint8Array(this.toUint32Array().buffer);
    }
    static fromHTMLImageElement(img) {
        const width = img.naturalWidth, height = img.naturalHeight, canvas = document.createElement("canvas");
        return canvas.width = width, canvas.height = height, canvas.getContext("2d").drawImage(img, 0, 0, width, height, 0, 0, width, height), 
        PointContainer.fromHTMLCanvasElement(canvas);
    }
    static fromHTMLCanvasElement(canvas) {
        const width = canvas.width, height = canvas.height, imgData = canvas.getContext("2d").getImageData(0, 0, width, height);
        return PointContainer.fromImageData(imgData);
    }
    static fromImageData(imageData) {
        const width = imageData.width, height = imageData.height;
        return PointContainer.fromUint8Array(imageData.data, width, height);
    }
    static fromUint8Array(uint8Array, width, height) {
        switch (Object.prototype.toString.call(uint8Array)) {
          case "[object Uint8ClampedArray]":
          case "[object Uint8Array]":
            break;

          default:
            uint8Array = new Uint8Array(uint8Array);
        }
        const uint32Array = new Uint32Array(uint8Array.buffer);
        return PointContainer.fromUint32Array(uint32Array, width, height);
    }
    static fromUint32Array(uint32Array, width, height) {
        const container = new PointContainer;
        container._width = width, container._height = height;
        for (let i = 0, l = uint32Array.length; i < l; i++) container._pointArray[i] = Point.createByUint32(0 | uint32Array[i]);
        return container;
    }
    static fromBuffer(buffer, width, height) {
        const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);
        return PointContainer.fromUint32Array(uint32Array, width, height);
    }
};

function hueGroup(hue, segmentsNumber) {
    const seg = 360 / segmentsNumber;
    for (let i = 1, mid = seg - seg / 2; i < segmentsNumber; i++, mid += seg) if (hue >= mid && hue < mid + seg) return i;
    return 0;
}

var Palette = class {
    constructor() {
        __publicField(this, "_pointContainer"), __publicField(this, "_pointArray", []), 
        __publicField(this, "_i32idx", {}), this._pointContainer = new PointContainer, this._pointContainer.setHeight(1), 
        this._pointArray = this._pointContainer.getPointArray();
    }
    add(color) {
        this._pointArray.push(color), this._pointContainer.setWidth(this._pointArray.length);
    }
    has(color) {
        for (let i = this._pointArray.length - 1; i >= 0; i--) if (color.uint32 === this._pointArray[i].uint32) return !0;
        return !1;
    }
    getNearestColor(colorDistanceCalculator, color) {
        return this._pointArray[0 | this._getNearestIndex(colorDistanceCalculator, color)];
    }
    getPointContainer() {
        return this._pointContainer;
    }
    _nearestPointFromCache(key) {
        return "number" == typeof this._i32idx[key] ? this._i32idx[key] : -1;
    }
    _getNearestIndex(colorDistanceCalculator, point) {
        let idx = this._nearestPointFromCache("" + point.uint32);
        if (idx >= 0) return idx;
        let minimalDistance = Number.MAX_VALUE;
        idx = 0;
        for (let i = 0, l = this._pointArray.length; i < l; i++) {
            const p = this._pointArray[i], distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
            distance < minimalDistance && (minimalDistance = distance, idx = i);
        }
        return this._i32idx[point.uint32] = idx, idx;
    }
    sort() {
        this._i32idx = {}, this._pointArray.sort(((a, b) => {
            const hslA = rgb2hsl$1(a.r, a.g, a.b), hslB = rgb2hsl$1(b.r, b.g, b.b), hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, 10), hueDiff = (b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, 10)) - hueA;
            if (hueDiff) return -hueDiff;
            const lA = a.getLuminosity(!0), lB = b.getLuminosity(!0);
            if (lB - lA != 0) return lB - lA;
            const satDiff = (100 * hslB.s | 0) - (100 * hslA.s | 0);
            return satDiff ? -satDiff : 0;
        }));
    }
}, utils_exports = {};

__export(utils_exports, {
    HueStatistics: () => HueStatistics,
    Palette: () => Palette,
    Point: () => Point,
    PointContainer: () => PointContainer,
    ProgressTracker: () => ProgressTracker,
    arithmetic: () => arithmetic_exports
});

var HueGroup = class {
    constructor() {
        __publicField(this, "num", 0), __publicField(this, "cols", []);
    }
}, HueStatistics = class {
    constructor(numGroups, minCols) {
        __publicField(this, "_numGroups"), __publicField(this, "_minCols"), __publicField(this, "_stats"), 
        __publicField(this, "_groupsFull"), this._numGroups = numGroups, this._minCols = minCols, 
        this._stats = [];
        for (let i = 0; i <= numGroups; i++) this._stats[i] = new HueGroup;
        this._groupsFull = 0;
    }
    check(i32) {
        this._groupsFull === this._numGroups + 1 && (this.check = () => {});
        const r = 255 & i32, g = i32 >>> 8 & 255, b = i32 >>> 16 & 255, hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl$1(r, g, b).h, this._numGroups), gr = this._stats[hg], min = this._minCols;
        gr.num++, gr.num > min || (gr.num === min && this._groupsFull++, gr.num <= min && this._stats[hg].cols.push(i32));
    }
    injectIntoDictionary(histG) {
        for (let i = 0; i <= this._numGroups; i++) this._stats[i].num <= this._minCols && this._stats[i].cols.forEach((col => {
            histG[col] ? histG[col]++ : histG[col] = 1;
        }));
    }
    injectIntoArray(histG) {
        for (let i = 0; i <= this._numGroups; i++) this._stats[i].num <= this._minCols && this._stats[i].cols.forEach((col => {
            -1 === histG.indexOf(col) && histG.push(col);
        }));
    }
}, _ProgressTracker = class {
    constructor(valueRange, progressRange) {
        __publicField(this, "progress"), __publicField(this, "_step"), __publicField(this, "_range"), 
        __publicField(this, "_last"), __publicField(this, "_progressRange"), this._range = valueRange, 
        this._progressRange = progressRange, this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0), 
        this._last = -this._step, this.progress = 0;
    }
    shouldNotify(current) {
        return current - this._last >= this._step && (this._last = current, this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange), 
        !0);
    }
}, ProgressTracker = _ProgressTracker;

__publicField(ProgressTracker, "steps", 100);

var Neuron = class {
    constructor(defaultValue) {
        __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), 
        this.r = this.g = this.b = this.a = defaultValue;
    }
    toPoint() {
        return Point.createByRGBA(this.r >> 3, this.g >> 3, this.b >> 3, this.a >> 3);
    }
    subtract(r, g, b, a) {
        this.r -= 0 | r, this.g -= 0 | g, this.b -= 0 | b, this.a -= 0 | a;
    }
}, _NeuQuant = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256) {
        super(), __publicField(this, "_pointArray"), __publicField(this, "_networkSize"), 
        __publicField(this, "_network"), __publicField(this, "_sampleFactor"), __publicField(this, "_radPower"), 
        __publicField(this, "_freq"), __publicField(this, "_bias"), __publicField(this, "_distance"), 
        this._distance = colorDistanceCalculator, this._pointArray = [], this._sampleFactor = 1, 
        this._networkSize = colors, this._distance.setWhitePoint(2040, 2040, 2040, 2040);
    }
    sample(pointContainer) {
        this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
    }
    * quantize() {
        this._init(), yield* this._learn(), yield {
            palette: this._buildPalette(),
            progress: 100
        };
    }
    _init() {
        this._freq = [], this._bias = [], this._radPower = [], this._network = [];
        for (let i = 0; i < this._networkSize; i++) this._network[i] = new Neuron((i << 11) / this._networkSize | 0), 
        this._freq[i] = _NeuQuant._initialBias / this._networkSize | 0, this._bias[i] = 0;
    }
    * _learn() {
        let sampleFactor = this._sampleFactor;
        const pointsNumber = this._pointArray.length;
        pointsNumber < _NeuQuant._minpicturebytes && (sampleFactor = 1);
        const alphadec = 30 + (sampleFactor - 1) / 3 | 0, pointsToSample = pointsNumber / sampleFactor | 0;
        let step, delta = pointsToSample / _NeuQuant._nCycles | 0, alpha = _NeuQuant._initAlpha, radius = (this._networkSize >> 3) * _NeuQuant._radiusBias, rad = radius >> _NeuQuant._radiusBiasShift;
        rad <= 1 && (rad = 0);
        for (let i = 0; i < rad; i++) this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuant._radBias / (rad * rad)) >>> 0;
        step = pointsNumber < _NeuQuant._minpicturebytes ? 1 : pointsNumber % _NeuQuant._prime1 != 0 ? _NeuQuant._prime1 : pointsNumber % _NeuQuant._prime2 != 0 ? _NeuQuant._prime2 : pointsNumber % _NeuQuant._prime3 != 0 ? _NeuQuant._prime3 : _NeuQuant._prime4;
        const tracker = new ProgressTracker(pointsToSample, 99);
        for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
            tracker.shouldNotify(i) && (yield {
                progress: tracker.progress
            });
            const point = this._pointArray[pointIndex], b = point.b << 3, g = point.g << 3, r = point.r << 3, a = point.a << 3, neuronIndex = this._contest(b, g, r, a);
            if (this._alterSingle(alpha, neuronIndex, b, g, r, a), 0 !== rad && this._alterNeighbour(rad, neuronIndex, b, g, r, a), 
            pointIndex += step, pointIndex >= pointsNumber && (pointIndex -= pointsNumber), 
            i++, 0 === delta && (delta = 1), i % delta == 0) {
                alpha -= alpha / alphadec | 0, radius -= radius / _NeuQuant._radiusDecrease | 0, 
                rad = radius >> _NeuQuant._radiusBiasShift, rad <= 1 && (rad = 0);
                for (let j = 0; j < rad; j++) this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;
            }
        }
    }
    _buildPalette() {
        const palette = new Palette;
        return this._network.forEach((neuron => {
            palette.add(neuron.toPoint());
        })), palette.sort(), palette;
    }
    _alterNeighbour(rad, i, b, g, r, al) {
        let lo = i - rad;
        lo < -1 && (lo = -1);
        let hi = i + rad;
        hi > this._networkSize && (hi = this._networkSize);
        let j = i + 1, k = i - 1, m = 1;
        for (;j < hi || k > lo; ) {
            const a = this._radPower[m++] / _NeuQuant._alphaRadBias;
            if (j < hi) {
                const p = this._network[j++];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
            }
            if (k > lo) {
                const p = this._network[k--];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
            }
        }
    }
    _alterSingle(alpha, i, b, g, r, a) {
        alpha /= _NeuQuant._initAlpha;
        const n = this._network[i];
        n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
    }
    _contest(b, g, r, a) {
        let bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
        for (let i = 0; i < this._networkSize; i++) {
            const n = this._network[i], dist = 8160 * this._distance.calculateNormalized(n, {
                r,
                g,
                b,
                a
            }) | 0;
            dist < bestd && (bestd = dist, bestpos = i);
            const biasdist = dist - (this._bias[i] >> _NeuQuant._initialBiasShift - 3);
            biasdist < bestbiasd && (bestbiasd = biasdist, bestbiaspos = i);
            const betafreq = this._freq[i] >> _NeuQuant._betaShift;
            this._freq[i] -= betafreq, this._bias[i] += betafreq << _NeuQuant._gammaShift;
        }
        return this._freq[bestpos] += _NeuQuant._beta, this._bias[bestpos] -= _NeuQuant._betaGamma, 
        bestbiaspos;
    }
}, NeuQuant$1 = _NeuQuant;

__publicField(NeuQuant$1, "_prime1", 499), __publicField(NeuQuant$1, "_prime2", 491), 
__publicField(NeuQuant$1, "_prime3", 487), __publicField(NeuQuant$1, "_prime4", 503), 
__publicField(NeuQuant$1, "_minpicturebytes", _NeuQuant._prime4), __publicField(NeuQuant$1, "_nCycles", 100), 
__publicField(NeuQuant$1, "_initialBiasShift", 16), __publicField(NeuQuant$1, "_initialBias", 1 << _NeuQuant._initialBiasShift), 
__publicField(NeuQuant$1, "_gammaShift", 10), __publicField(NeuQuant$1, "_betaShift", 10), 
__publicField(NeuQuant$1, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift), 
__publicField(NeuQuant$1, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift), 
__publicField(NeuQuant$1, "_radiusBiasShift", 6), __publicField(NeuQuant$1, "_radiusBias", 1 << _NeuQuant._radiusBiasShift), 
__publicField(NeuQuant$1, "_radiusDecrease", 30), __publicField(NeuQuant$1, "_alphaBiasShift", 10), 
__publicField(NeuQuant$1, "_initAlpha", 1 << _NeuQuant._alphaBiasShift), __publicField(NeuQuant$1, "_radBiasShift", 8), 
__publicField(NeuQuant$1, "_radBias", 1 << _NeuQuant._radBiasShift), __publicField(NeuQuant$1, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift), 
__publicField(NeuQuant$1, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);

var NeuronFloat = class {
    constructor(defaultValue) {
        __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), 
        this.r = this.g = this.b = this.a = defaultValue;
    }
    toPoint() {
        return Point.createByRGBA(this.r >> 3, this.g >> 3, this.b >> 3, this.a >> 3);
    }
    subtract(r, g, b, a) {
        this.r -= r, this.g -= g, this.b -= b, this.a -= a;
    }
}, _NeuQuantFloat = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256) {
        super(), __publicField(this, "_pointArray"), __publicField(this, "_networkSize"), 
        __publicField(this, "_network"), __publicField(this, "_sampleFactor"), __publicField(this, "_radPower"), 
        __publicField(this, "_freq"), __publicField(this, "_bias"), __publicField(this, "_distance"), 
        this._distance = colorDistanceCalculator, this._pointArray = [], this._sampleFactor = 1, 
        this._networkSize = colors, this._distance.setWhitePoint(2040, 2040, 2040, 2040);
    }
    sample(pointContainer) {
        this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
    }
    * quantize() {
        this._init(), yield* this._learn(), yield {
            palette: this._buildPalette(),
            progress: 100
        };
    }
    _init() {
        this._freq = [], this._bias = [], this._radPower = [], this._network = [];
        for (let i = 0; i < this._networkSize; i++) this._network[i] = new NeuronFloat((i << 11) / this._networkSize), 
        this._freq[i] = _NeuQuantFloat._initialBias / this._networkSize, this._bias[i] = 0;
    }
    * _learn() {
        let sampleFactor = this._sampleFactor;
        const pointsNumber = this._pointArray.length;
        pointsNumber < _NeuQuantFloat._minpicturebytes && (sampleFactor = 1);
        const alphadec = 30 + (sampleFactor - 1) / 3, pointsToSample = pointsNumber / sampleFactor;
        let step, delta = pointsToSample / _NeuQuantFloat._nCycles | 0, alpha = _NeuQuantFloat._initAlpha, radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias, rad = radius >> _NeuQuantFloat._radiusBiasShift;
        rad <= 1 && (rad = 0);
        for (let i = 0; i < rad; i++) this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuantFloat._radBias / (rad * rad));
        step = pointsNumber < _NeuQuantFloat._minpicturebytes ? 1 : pointsNumber % _NeuQuantFloat._prime1 != 0 ? _NeuQuantFloat._prime1 : pointsNumber % _NeuQuantFloat._prime2 != 0 ? _NeuQuantFloat._prime2 : pointsNumber % _NeuQuantFloat._prime3 != 0 ? _NeuQuantFloat._prime3 : _NeuQuantFloat._prime4;
        const tracker = new ProgressTracker(pointsToSample, 99);
        for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
            tracker.shouldNotify(i) && (yield {
                progress: tracker.progress
            });
            const point = this._pointArray[pointIndex], b = point.b << 3, g = point.g << 3, r = point.r << 3, a = point.a << 3, neuronIndex = this._contest(b, g, r, a);
            if (this._alterSingle(alpha, neuronIndex, b, g, r, a), 0 !== rad && this._alterNeighbour(rad, neuronIndex, b, g, r, a), 
            pointIndex += step, pointIndex >= pointsNumber && (pointIndex -= pointsNumber), 
            i++, 0 === delta && (delta = 1), i % delta == 0) {
                alpha -= alpha / alphadec, radius -= radius / _NeuQuantFloat._radiusDecrease, rad = radius >> _NeuQuantFloat._radiusBiasShift, 
                rad <= 1 && (rad = 0);
                for (let j = 0; j < rad; j++) this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));
            }
        }
    }
    _buildPalette() {
        const palette = new Palette;
        return this._network.forEach((neuron => {
            palette.add(neuron.toPoint());
        })), palette.sort(), palette;
    }
    _alterNeighbour(rad, i, b, g, r, al) {
        let lo = i - rad;
        lo < -1 && (lo = -1);
        let hi = i + rad;
        hi > this._networkSize && (hi = this._networkSize);
        let j = i + 1, k = i - 1, m = 1;
        for (;j < hi || k > lo; ) {
            const a = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;
            if (j < hi) {
                const p = this._network[j++];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
            }
            if (k > lo) {
                const p = this._network[k--];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
            }
        }
    }
    _alterSingle(alpha, i, b, g, r, a) {
        alpha /= _NeuQuantFloat._initAlpha;
        const n = this._network[i];
        n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
    }
    _contest(b, g, r, al) {
        let bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
        for (let i = 0; i < this._networkSize; i++) {
            const n = this._network[i], dist = 8160 * this._distance.calculateNormalized(n, {
                r,
                g,
                b,
                a: al
            });
            dist < bestd && (bestd = dist, bestpos = i);
            const biasdist = dist - (this._bias[i] >> _NeuQuantFloat._initialBiasShift - 3);
            biasdist < bestbiasd && (bestbiasd = biasdist, bestbiaspos = i);
            const betafreq = this._freq[i] >> _NeuQuantFloat._betaShift;
            this._freq[i] -= betafreq, this._bias[i] += betafreq << _NeuQuantFloat._gammaShift;
        }
        return this._freq[bestpos] += _NeuQuantFloat._beta, this._bias[bestpos] -= _NeuQuantFloat._betaGamma, 
        bestbiaspos;
    }
}, NeuQuantFloat = _NeuQuantFloat;

__publicField(NeuQuantFloat, "_prime1", 499), __publicField(NeuQuantFloat, "_prime2", 491), 
__publicField(NeuQuantFloat, "_prime3", 487), __publicField(NeuQuantFloat, "_prime4", 503), 
__publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4), __publicField(NeuQuantFloat, "_nCycles", 100), 
__publicField(NeuQuantFloat, "_initialBiasShift", 16), __publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift), 
__publicField(NeuQuantFloat, "_gammaShift", 10), __publicField(NeuQuantFloat, "_betaShift", 10), 
__publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift), 
__publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift), 
__publicField(NeuQuantFloat, "_radiusBiasShift", 6), __publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift), 
__publicField(NeuQuantFloat, "_radiusDecrease", 30), __publicField(NeuQuantFloat, "_alphaBiasShift", 10), 
__publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift), 
__publicField(NeuQuantFloat, "_radBiasShift", 8), __publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift), 
__publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift), 
__publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);

var _ColorHistogram = class {
    constructor(method, colors) {
        __publicField(this, "_method"), __publicField(this, "_hueStats"), __publicField(this, "_histogram"), 
        __publicField(this, "_initColors"), __publicField(this, "_minHueCols"), this._method = method, 
        this._minHueCols = colors << 2, this._initColors = colors << 2, this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols), 
        this._histogram = Object.create(null);
    }
    sample(pointContainer) {
        switch (this._method) {
          case 1:
            this._colorStats1D(pointContainer);
            break;

          case 2:
            this._colorStats2D(pointContainer);
        }
    }
    getImportanceSortedColorsIDXI32() {
        const sorted = stableSort(Object.keys(this._histogram), ((a, b) => this._histogram[b] - this._histogram[a]));
        if (0 === sorted.length) return [];
        let idxi32;
        switch (this._method) {
          case 1:
            const initialColorsLimit = Math.min(sorted.length, this._initColors), last = sorted[initialColorsLimit - 1], freq = this._histogram[last];
            idxi32 = sorted.slice(0, initialColorsLimit);
            let pos = initialColorsLimit;
            const len = sorted.length;
            for (;pos < len && this._histogram[sorted[pos]] === freq; ) idxi32.push(sorted[pos++]);
            this._hueStats.injectIntoArray(idxi32);
            break;

          case 2:
            idxi32 = sorted;
            break;

          default:
            throw new Error("Incorrect method");
        }
        return idxi32.map((v => +v));
    }
    _colorStats1D(pointContainer) {
        const histG = this._histogram, pointArray = pointContainer.getPointArray(), len = pointArray.length;
        for (let i = 0; i < len; i++) {
            const col = pointArray[i].uint32;
            this._hueStats.check(col), col in histG ? histG[col]++ : histG[col] = 1;
        }
    }
    _colorStats2D(pointContainer) {
        const width = pointContainer.getWidth(), height = pointContainer.getHeight(), pointArray = pointContainer.getPointArray(), boxW = _ColorHistogram._boxSize[0], boxH = _ColorHistogram._boxSize[1], area = boxW * boxH, boxes = this._makeBoxes(width, height, boxW, boxH), histG = this._histogram;
        boxes.forEach((box => {
            let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;
            effc < 2 && (effc = 2);
            const histL = {};
            this._iterateBox(box, width, (i => {
                const col = pointArray[i].uint32;
                this._hueStats.check(col), col in histG ? histG[col]++ : col in histL ? ++histL[col] >= effc && (histG[col] = histL[col]) : histL[col] = 1;
            }));
        })), this._hueStats.injectIntoDictionary(histG);
    }
    _iterateBox(bbox, wid, fn) {
        const b = bbox, i0 = b.y * wid + b.x, i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1), incr = wid - b.w + 1;
        let cnt = 0, i = i0;
        do {
            fn.call(this, i), i += ++cnt % b.w == 0 ? incr : 1;
        } while (i <= i1);
    }
    _makeBoxes(width, height, stepX, stepY) {
        const wrem = width % stepX, hrem = height % stepY, xend = width - wrem, yend = height - hrem, boxesArray = [];
        for (let y2 = 0; y2 < height; y2 += stepY) for (let x2 = 0; x2 < width; x2 += stepX) boxesArray.push({
            x: x2,
            y: y2,
            w: x2 === xend ? wrem : stepX,
            h: y2 === yend ? hrem : stepY
        });
        return boxesArray;
    }
}, ColorHistogram = _ColorHistogram;

__publicField(ColorHistogram, "_boxSize", [ 64, 64 ]), __publicField(ColorHistogram, "_boxPixels", 2), 
__publicField(ColorHistogram, "_hueGroups", 10);

var RemovedColor = class {
    constructor(index, color, distance) {
        __publicField(this, "index"), __publicField(this, "color"), __publicField(this, "distance"), 
        this.index = index, this.color = color, this.distance = distance;
    }
}, RGBQuant = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256, method = 2) {
        super(), __publicField(this, "_colors"), __publicField(this, "_initialDistance"), 
        __publicField(this, "_distanceIncrement"), __publicField(this, "_histogram"), __publicField(this, "_distance"), 
        this._distance = colorDistanceCalculator, this._colors = colors, this._histogram = new ColorHistogram(method, colors), 
        this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
    }
    sample(image) {
        this._histogram.sample(image);
    }
    * quantize() {
        const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
        if (0 === idxi32.length) throw new Error("No colors in image");
        yield* this._buildPalette(idxi32);
    }
    * _buildPalette(idxi32) {
        const palette = new Palette, colorArray = palette.getPointContainer().getPointArray(), usageArray = new Array(idxi32.length);
        for (let i = 0; i < idxi32.length; i++) colorArray.push(Point.createByUint32(idxi32[i])), 
        usageArray[i] = 1;
        const len = colorArray.length, memDist = [];
        let palLen = len, thold = this._initialDistance;
        const tracker = new ProgressTracker(palLen - this._colors, 99);
        for (;palLen > this._colors; ) {
            memDist.length = 0;
            for (let i = 0; i < len; i++) {
                if (tracker.shouldNotify(len - palLen) && (yield {
                    progress: tracker.progress
                }), 0 === usageArray[i]) continue;
                const pxi = colorArray[i];
                for (let j = i + 1; j < len; j++) {
                    if (0 === usageArray[j]) continue;
                    const pxj = colorArray[j], dist = this._distance.calculateNormalized(pxi, pxj);
                    dist < thold && (memDist.push(new RemovedColor(j, pxj, dist)), usageArray[j] = 0, 
                    palLen--);
                }
            }
            thold += palLen > 3 * this._colors ? this._initialDistance : this._distanceIncrement;
        }
        if (palLen < this._colors) {
            stableSort(memDist, ((a, b) => b.distance - a.distance));
            let k = 0;
            for (;palLen < this._colors && k < memDist.length; ) usageArray[memDist[k].index] = 1, 
            palLen++, k++;
        }
        let colors = colorArray.length;
        for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) 0 === usageArray[colorIndex] && (colorIndex !== colors - 1 && (colorArray[colorIndex] = colorArray[colors - 1]), 
        --colors);
        colorArray.length = colors, palette.sort(), yield {
            palette,
            progress: 100
        };
    }
};

function createArray1D(dimension1) {
    const a = [];
    for (let k = 0; k < dimension1; k++) a[k] = 0;
    return a;
}

function createArray4D(dimension1, dimension2, dimension3, dimension4) {
    const a = new Array(dimension1);
    for (let i = 0; i < dimension1; i++) {
        a[i] = new Array(dimension2);
        for (let j = 0; j < dimension2; j++) {
            a[i][j] = new Array(dimension3);
            for (let k = 0; k < dimension3; k++) {
                a[i][j][k] = new Array(dimension4);
                for (let l = 0; l < dimension4; l++) a[i][j][k][l] = 0;
            }
        }
    }
    return a;
}

function createArray3D(dimension1, dimension2, dimension3) {
    const a = new Array(dimension1);
    for (let i = 0; i < dimension1; i++) {
        a[i] = new Array(dimension2);
        for (let j = 0; j < dimension2; j++) {
            a[i][j] = new Array(dimension3);
            for (let k = 0; k < dimension3; k++) a[i][j][k] = 0;
        }
    }
    return a;
}

function fillArray3D(a, dimension1, dimension2, dimension3, value) {
    for (let i = 0; i < dimension1; i++) {
        a[i] = [];
        for (let j = 0; j < dimension2; j++) {
            a[i][j] = [];
            for (let k = 0; k < dimension3; k++) a[i][j][k] = value;
        }
    }
}

function fillArray1D(a, dimension1, value) {
    for (let i = 0; i < dimension1; i++) a[i] = value;
}

var WuColorCube = class {
    constructor() {
        __publicField(this, "redMinimum"), __publicField(this, "redMaximum"), __publicField(this, "greenMinimum"), 
        __publicField(this, "greenMaximum"), __publicField(this, "blueMinimum"), __publicField(this, "blueMaximum"), 
        __publicField(this, "volume"), __publicField(this, "alphaMinimum"), __publicField(this, "alphaMaximum");
    }
}, _WuQuant = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {
        super(), __publicField(this, "_reds"), __publicField(this, "_greens"), __publicField(this, "_blues"), 
        __publicField(this, "_alphas"), __publicField(this, "_sums"), __publicField(this, "_weights"), 
        __publicField(this, "_momentsRed"), __publicField(this, "_momentsGreen"), __publicField(this, "_momentsBlue"), 
        __publicField(this, "_momentsAlpha"), __publicField(this, "_moments"), __publicField(this, "_table"), 
        __publicField(this, "_pixels"), __publicField(this, "_cubes"), __publicField(this, "_colors"), 
        __publicField(this, "_significantBitsPerChannel"), __publicField(this, "_maxSideIndex"), 
        __publicField(this, "_alphaMaxSideIndex"), __publicField(this, "_sideSize"), __publicField(this, "_alphaSideSize"), 
        __publicField(this, "_distance"), this._distance = colorDistanceCalculator, this._setQuality(significantBitsPerChannel), 
        this._initialize(colors);
    }
    sample(image) {
        const pointArray = image.getPointArray();
        for (let i = 0, l = pointArray.length; i < l; i++) this._addColor(pointArray[i]);
        this._pixels = this._pixels.concat(pointArray);
    }
    * quantize() {
        yield* this._preparePalette();
        const palette = new Palette;
        for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) if (this._sums[paletteIndex] > 0) {
            const sum = this._sums[paletteIndex], r = this._reds[paletteIndex] / sum, g = this._greens[paletteIndex] / sum, b = this._blues[paletteIndex] / sum, a = this._alphas[paletteIndex] / sum, color = Point.createByRGBA(0 | r, 0 | g, 0 | b, 0 | a);
            palette.add(color);
        }
        palette.sort(), yield {
            palette,
            progress: 100
        };
    }
    * _preparePalette() {
        yield* this._calculateMoments();
        let next = 0;
        const volumeVariance = createArray1D(this._colors);
        for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
            this._cut(this._cubes[next], this._cubes[cubeIndex]) ? (volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0, 
            volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0) : (volumeVariance[next] = 0, 
            cubeIndex--), next = 0;
            let temp = volumeVariance[0];
            for (let index = 1; index <= cubeIndex; ++index) volumeVariance[index] > temp && (temp = volumeVariance[index], 
            next = index);
            if (temp <= 0) {
                this._colors = cubeIndex + 1;
                break;
            }
        }
        const lookupRed = [], lookupGreen = [], lookupBlue = [], lookupAlpha = [];
        for (let k = 0; k < this._colors; ++k) {
            const weight = _WuQuant._volume(this._cubes[k], this._weights);
            weight > 0 ? (lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0, 
            lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0, 
            lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0, 
            lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0) : (lookupRed[k] = 0, 
            lookupGreen[k] = 0, lookupBlue[k] = 0, lookupAlpha[k] = 0);
        }
        this._reds = createArray1D(this._colors + 1), this._greens = createArray1D(this._colors + 1), 
        this._blues = createArray1D(this._colors + 1), this._alphas = createArray1D(this._colors + 1), 
        this._sums = createArray1D(this._colors + 1);
        for (let index = 0, l = this._pixels.length; index < l; index++) {
            const color = this._pixels[index];
            let bestMatch = -1, bestDistance = Number.MAX_VALUE;
            for (let lookup = 0; lookup < this._colors; lookup++) {
                const foundRed = lookupRed[lookup], foundGreen = lookupGreen[lookup], foundBlue = lookupBlue[lookup], foundAlpha = lookupAlpha[lookup], distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
                distance < bestDistance && (bestDistance = distance, bestMatch = lookup);
            }
            this._reds[bestMatch] += color.r, this._greens[bestMatch] += color.g, this._blues[bestMatch] += color.b, 
            this._alphas[bestMatch] += color.a, this._sums[bestMatch]++;
        }
    }
    _addColor(color) {
        const bitsToRemove = 8 - this._significantBitsPerChannel, indexRed = 1 + (color.r >> bitsToRemove), indexGreen = 1 + (color.g >> bitsToRemove), indexBlue = 1 + (color.b >> bitsToRemove), indexAlpha = 1 + (color.a >> bitsToRemove);
        this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++, this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r, 
        this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g, this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b, 
        this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a, this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
    }
    * _calculateMoments() {
        const area = [], areaRed = [], areaGreen = [], areaBlue = [], areaAlpha = [], area2 = [], xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize), xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        let trackerProgress = 0;
        const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
        for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
            fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0), 
            fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0), 
            fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
            for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {
                tracker.shouldNotify(trackerProgress) && (yield {
                    progress: tracker.progress
                }), fillArray1D(area, this._sideSize, 0), fillArray1D(areaRed, this._sideSize, 0), 
                fillArray1D(areaGreen, this._sideSize, 0), fillArray1D(areaBlue, this._sideSize, 0), 
                fillArray1D(areaAlpha, this._sideSize, 0), fillArray1D(area2, this._sideSize, 0);
                for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {
                    let line = 0, lineRed = 0, lineGreen = 0, lineBlue = 0, lineAlpha = 0, line2 = 0;
                    for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex], 
                    lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex], lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex], 
                    lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex], lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex], 
                    line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex], area[blueIndex] += line, 
                    areaRed[blueIndex] += lineRed, areaGreen[blueIndex] += lineGreen, areaBlue[blueIndex] += lineBlue, 
                    areaAlpha[blueIndex] += lineAlpha, area2[blueIndex] += line2, xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex], 
                    xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex], 
                    xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex], 
                    xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex], 
                    xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex], 
                    xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex], 
                    this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex], 
                    this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex], 
                    this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex], 
                    this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex], 
                    this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex], 
                    this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
                }
            }
        }
    }
    static _volumeFloat(cube, moment) {
        return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
    }
    static _volume(cube, moment) {
        return 0 | _WuQuant._volumeFloat(cube, moment);
    }
    static _top(cube, direction, position, moment) {
        let result;
        switch (direction) {
          case _WuQuant._alpha:
            result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
            break;

          case _WuQuant._red:
            result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
            break;

          case _WuQuant._green:
            result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
            break;

          case _WuQuant._blue:
            result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
            break;

          default:
            throw new Error("impossible");
        }
        return 0 | result;
    }
    static _bottom(cube, direction, moment) {
        switch (direction) {
          case _WuQuant._alpha:
            return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);

          case _WuQuant._red:
            return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);

          case _WuQuant._green:
            return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);

          case _WuQuant._blue:
            return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);

          default:
            return 0;
        }
    }
    _calculateVariance(cube) {
        const volumeRed = _WuQuant._volume(cube, this._momentsRed), volumeGreen = _WuQuant._volume(cube, this._momentsGreen), volumeBlue = _WuQuant._volume(cube, this._momentsBlue), volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);
        return _WuQuant._volumeFloat(cube, this._moments) - (volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha) / _WuQuant._volume(cube, this._weights);
    }
    _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
        const bottomRed = 0 | _WuQuant._bottom(cube, direction, this._momentsRed), bottomGreen = 0 | _WuQuant._bottom(cube, direction, this._momentsGreen), bottomBlue = 0 | _WuQuant._bottom(cube, direction, this._momentsBlue), bottomAlpha = 0 | _WuQuant._bottom(cube, direction, this._momentsAlpha), bottomWeight = 0 | _WuQuant._bottom(cube, direction, this._weights);
        let result = 0, cutPosition = -1;
        for (let position = first; position < last; ++position) {
            let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed), halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen), halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue), halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha), halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);
            if (0 !== halfWeight) {
                let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha, temp = halfDistance / halfWeight;
                halfRed = wholeRed - halfRed, halfGreen = wholeGreen - halfGreen, halfBlue = wholeBlue - halfBlue, 
                halfAlpha = wholeAlpha - halfAlpha, halfWeight = wholeWeight - halfWeight, 0 !== halfWeight && (halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha, 
                temp += halfDistance / halfWeight, temp > result && (result = temp, cutPosition = position));
            }
        }
        return {
            max: result,
            position: cutPosition
        };
    }
    _cut(first, second) {
        let direction;
        const wholeRed = _WuQuant._volume(first, this._momentsRed), wholeGreen = _WuQuant._volume(first, this._momentsGreen), wholeBlue = _WuQuant._volume(first, this._momentsBlue), wholeAlpha = _WuQuant._volume(first, this._momentsAlpha), wholeWeight = _WuQuant._volume(first, this._weights), red = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), green = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), blue = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
        if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
            if (direction = _WuQuant._alpha, alpha.position < 0) return !1;
        } else direction = red.max >= alpha.max && red.max >= green.max && red.max >= blue.max ? _WuQuant._red : green.max >= alpha.max && green.max >= red.max && green.max >= blue.max ? _WuQuant._green : _WuQuant._blue;
        switch (second.redMaximum = first.redMaximum, second.greenMaximum = first.greenMaximum, 
        second.blueMaximum = first.blueMaximum, second.alphaMaximum = first.alphaMaximum, 
        direction) {
          case _WuQuant._red:
            second.redMinimum = first.redMaximum = red.position, second.greenMinimum = first.greenMinimum, 
            second.blueMinimum = first.blueMinimum, second.alphaMinimum = first.alphaMinimum;
            break;

          case _WuQuant._green:
            second.greenMinimum = first.greenMaximum = green.position, second.redMinimum = first.redMinimum, 
            second.blueMinimum = first.blueMinimum, second.alphaMinimum = first.alphaMinimum;
            break;

          case _WuQuant._blue:
            second.blueMinimum = first.blueMaximum = blue.position, second.redMinimum = first.redMinimum, 
            second.greenMinimum = first.greenMinimum, second.alphaMinimum = first.alphaMinimum;
            break;

          case _WuQuant._alpha:
            second.alphaMinimum = first.alphaMaximum = alpha.position, second.blueMinimum = first.blueMinimum, 
            second.redMinimum = first.redMinimum, second.greenMinimum = first.greenMinimum;
        }
        return first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum), 
        second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum), 
        !0;
    }
    _initialize(colors) {
        this._colors = colors, this._cubes = [];
        for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) this._cubes[cubeIndex] = new WuColorCube;
        this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, 
        this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, 
        this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, 
        this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
        this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
        this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
        this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
        this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
        this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
        this._table = [];
        for (let tableIndex = 0; tableIndex < 256; ++tableIndex) this._table[tableIndex] = tableIndex * tableIndex;
        this._pixels = [];
    }
    _setQuality(significantBitsPerChannel = 5) {
        this._significantBitsPerChannel = significantBitsPerChannel, this._maxSideIndex = 1 << this._significantBitsPerChannel, 
        this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, 
        this._alphaSideSize = this._alphaMaxSideIndex + 1;
    }
}, WuQuant = _WuQuant;

__publicField(WuQuant, "_alpha", 3), __publicField(WuQuant, "_red", 2), __publicField(WuQuant, "_green", 1), 
__publicField(WuQuant, "_blue", 0);

var image_exports = {};

__export(image_exports, {
    AbstractImageQuantizer: () => AbstractImageQuantizer,
    ErrorDiffusionArray: () => ErrorDiffusionArray,
    ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,
    ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,
    NearestColor: () => NearestColor
});

var AbstractImageQuantizer = class {
    quantizeSync(pointContainer, palette) {
        for (const value of this.quantize(pointContainer, palette)) if (value.pointContainer) return value.pointContainer;
        throw new Error("unreachable");
    }
}, NearestColor = class extends AbstractImageQuantizer {
    constructor(colorDistanceCalculator) {
        super(), __publicField(this, "_distance"), this._distance = colorDistanceCalculator;
    }
    * quantize(pointContainer, palette) {
        const pointArray = pointContainer.getPointArray(), width = pointContainer.getWidth(), height = pointContainer.getHeight(), tracker = new ProgressTracker(height, 99);
        for (let y2 = 0; y2 < height; y2++) {
            tracker.shouldNotify(y2) && (yield {
                progress: tracker.progress
            });
            for (let x2 = 0, idx = y2 * width; x2 < width; x2++, idx++) {
                const point = pointArray[idx];
                point.from(palette.getNearestColor(this._distance, point));
            }
        }
        yield {
            pointContainer,
            progress: 100
        };
    }
}, ErrorDiffusionArrayKernel = (ErrorDiffusionArrayKernel2 => (ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.FloydSteinberg = 0] = "FloydSteinberg", 
ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", 
ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.Stucki = 2] = "Stucki", ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.Atkinson = 3] = "Atkinson", 
ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.Jarvis = 4] = "Jarvis", ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.Burkes = 5] = "Burkes", 
ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.Sierra = 6] = "Sierra", ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.TwoSierra = 7] = "TwoSierra", 
ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.SierraLite = 8] = "SierraLite", 
ErrorDiffusionArrayKernel2))(ErrorDiffusionArrayKernel || {}), ErrorDiffusionArray = class extends AbstractImageQuantizer {
    constructor(colorDistanceCalculator, kernel, serpentine = !0, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = !1) {
        super(), __publicField(this, "_minColorDistance"), __publicField(this, "_serpentine"), 
        __publicField(this, "_kernel"), __publicField(this, "_calculateErrorLikeGIMP"), 
        __publicField(this, "_distance"), this._setKernel(kernel), this._distance = colorDistanceCalculator, 
        this._minColorDistance = minimumColorDistanceToDither, this._serpentine = serpentine, 
        this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
    }
    * quantize(pointContainer, palette) {
        const pointArray = pointContainer.getPointArray(), originalPoint = new Point, width = pointContainer.getWidth(), height = pointContainer.getHeight(), errorLines = [];
        let dir = 1, maxErrorLines = 1;
        for (const kernel of this._kernel) {
            const kernelErrorLines = kernel[2] + 1;
            maxErrorLines < kernelErrorLines && (maxErrorLines = kernelErrorLines);
        }
        for (let i = 0; i < maxErrorLines; i++) this._fillErrorLine(errorLines[i] = [], width);
        const tracker = new ProgressTracker(height, 99);
        for (let y2 = 0; y2 < height; y2++) {
            tracker.shouldNotify(y2) && (yield {
                progress: tracker.progress
            }), this._serpentine && (dir *= -1);
            const lni = y2 * width, xStart = 1 === dir ? 0 : width - 1, xEnd = 1 === dir ? width : -1;
            this._fillErrorLine(errorLines[0], width), errorLines.push(errorLines.shift());
            const errorLine = errorLines[0];
            for (let x2 = xStart, idx = lni + xStart; x2 !== xEnd; x2 += dir, idx += dir) {
                const point = pointArray[idx], error = errorLine[x2];
                originalPoint.from(point);
                const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3])), palettePoint = palette.getNearestColor(this._distance, correctedPoint);
                if (point.from(palettePoint), this._minColorDistance && this._distance.calculateNormalized(originalPoint, palettePoint) < this._minColorDistance) continue;
                let er, eg, eb, ea;
                this._calculateErrorLikeGIMP ? (er = correctedPoint.r - palettePoint.r, eg = correctedPoint.g - palettePoint.g, 
                eb = correctedPoint.b - palettePoint.b, ea = correctedPoint.a - palettePoint.a) : (er = originalPoint.r - palettePoint.r, 
                eg = originalPoint.g - palettePoint.g, eb = originalPoint.b - palettePoint.b, ea = originalPoint.a - palettePoint.a);
                const dStart = 1 === dir ? 0 : this._kernel.length - 1, dEnd = 1 === dir ? this._kernel.length : -1;
                for (let i = dStart; i !== dEnd; i += dir) {
                    const x1 = this._kernel[i][1] * dir, y1 = this._kernel[i][2];
                    if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {
                        const d = this._kernel[i][0], e = errorLines[y1][x1 + x2];
                        e[0] += er * d, e[1] += eg * d, e[2] += eb * d, e[3] += ea * d;
                    }
                }
            }
        }
        yield {
            pointContainer,
            progress: 100
        };
    }
    _fillErrorLine(errorLine, width) {
        errorLine.length > width && (errorLine.length = width);
        const l = errorLine.length;
        for (let i = 0; i < l; i++) {
            const error = errorLine[i];
            error[0] = error[1] = error[2] = error[3] = 0;
        }
        for (let i = l; i < width; i++) errorLine[i] = [ 0, 0, 0, 0 ];
    }
    _setKernel(kernel) {
        switch (kernel) {
          case 0:
            this._kernel = [ [ 7 / 16, 1, 0 ], [ 3 / 16, -1, 1 ], [ 5 / 16, 0, 1 ], [ 1 / 16, 1, 1 ] ];
            break;

          case 1:
            this._kernel = [ [ 3 / 8, 1, 0 ], [ 3 / 8, 0, 1 ], [ 2 / 8, 1, 1 ] ];
            break;

          case 2:
            this._kernel = [ [ 8 / 42, 1, 0 ], [ 4 / 42, 2, 0 ], [ 2 / 42, -2, 1 ], [ 4 / 42, -1, 1 ], [ 8 / 42, 0, 1 ], [ 4 / 42, 1, 1 ], [ 2 / 42, 2, 1 ], [ 1 / 42, -2, 2 ], [ 2 / 42, -1, 2 ], [ 4 / 42, 0, 2 ], [ 2 / 42, 1, 2 ], [ 1 / 42, 2, 2 ] ];
            break;

          case 3:
            this._kernel = [ [ 1 / 8, 1, 0 ], [ 1 / 8, 2, 0 ], [ 1 / 8, -1, 1 ], [ 1 / 8, 0, 1 ], [ 1 / 8, 1, 1 ], [ 1 / 8, 0, 2 ] ];
            break;

          case 4:
            this._kernel = [ [ 7 / 48, 1, 0 ], [ 5 / 48, 2, 0 ], [ 3 / 48, -2, 1 ], [ 5 / 48, -1, 1 ], [ 7 / 48, 0, 1 ], [ 5 / 48, 1, 1 ], [ 3 / 48, 2, 1 ], [ 1 / 48, -2, 2 ], [ 3 / 48, -1, 2 ], [ 5 / 48, 0, 2 ], [ 3 / 48, 1, 2 ], [ 1 / 48, 2, 2 ] ];
            break;

          case 5:
            this._kernel = [ [ .25, 1, 0 ], [ 4 / 32, 2, 0 ], [ 2 / 32, -2, 1 ], [ 4 / 32, -1, 1 ], [ .25, 0, 1 ], [ 4 / 32, 1, 1 ], [ 2 / 32, 2, 1 ] ];
            break;

          case 6:
            this._kernel = [ [ 5 / 32, 1, 0 ], [ 3 / 32, 2, 0 ], [ 2 / 32, -2, 1 ], [ 4 / 32, -1, 1 ], [ 5 / 32, 0, 1 ], [ 4 / 32, 1, 1 ], [ 2 / 32, 2, 1 ], [ 2 / 32, -1, 2 ], [ 3 / 32, 0, 2 ], [ 2 / 32, 1, 2 ] ];
            break;

          case 7:
            this._kernel = [ [ .25, 1, 0 ], [ 3 / 16, 2, 0 ], [ 1 / 16, -2, 1 ], [ 2 / 16, -1, 1 ], [ 3 / 16, 0, 1 ], [ 2 / 16, 1, 1 ], [ 1 / 16, 2, 1 ] ];
            break;

          case 8:
            this._kernel = [ [ .5, 1, 0 ], [ 1 / 4, -1, 1 ], [ 1 / 4, 0, 1 ] ];
            break;

          default:
            throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);
        }
    }
};

function* hilbertCurve(width, height, callback) {
    const maxBound = Math.max(width, height), data = {
        width,
        height,
        level: Math.floor(Math.log(maxBound) / Math.log(2) + 1),
        callback,
        tracker: new ProgressTracker(width * height, 99),
        index: 0,
        x: 0,
        y: 0
    };
    yield* walkHilbert(data, 1), visit(data, 0);
}

function* walkHilbert(data, direction) {
    if (!(data.level < 1)) {
        switch (data.tracker.shouldNotify(data.index) && (yield {
            progress: data.tracker.progress
        }), data.level--, direction) {
          case 2:
            yield* walkHilbert(data, 1), visit(data, 3), yield* walkHilbert(data, 2), visit(data, 4), 
            yield* walkHilbert(data, 2), visit(data, 2), yield* walkHilbert(data, 4);
            break;

          case 3:
            yield* walkHilbert(data, 4), visit(data, 2), yield* walkHilbert(data, 3), visit(data, 1), 
            yield* walkHilbert(data, 3), visit(data, 3), yield* walkHilbert(data, 1);
            break;

          case 1:
            yield* walkHilbert(data, 2), visit(data, 4), yield* walkHilbert(data, 1), visit(data, 3), 
            yield* walkHilbert(data, 1), visit(data, 1), yield* walkHilbert(data, 3);
            break;

          case 4:
            yield* walkHilbert(data, 3), visit(data, 1), yield* walkHilbert(data, 4), visit(data, 2), 
            yield* walkHilbert(data, 4), visit(data, 4), yield* walkHilbert(data, 2);
        }
        data.level++;
    }
}

function visit(data, direction) {
    switch (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height && (data.callback(data.x, data.y), 
    data.index++), direction) {
      case 2:
        data.x--;
        break;

      case 3:
        data.x++;
        break;

      case 1:
        data.y--;
        break;

      case 4:
        data.y++;
    }
}

var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
    constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {
        super(), __publicField(this, "_distance"), __publicField(this, "_weights"), __publicField(this, "_errorQueueSize"), 
        this._distance = colorDistanceCalculator, this._errorQueueSize = errorQueueSize, 
        this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);
    }
    * quantize(pointContainer, palette) {
        const pointArray = pointContainer.getPointArray(), width = pointContainer.getWidth(), height = pointContainer.getHeight(), errorQueue = [];
        let head = 0;
        for (let i = 0; i < this._errorQueueSize; i++) errorQueue[i] = {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        };
        yield* hilbertCurve(width, height, ((x2, y2) => {
            const p = pointArray[x2 + y2 * width];
            let {r, g, b, a} = p;
            for (let i = 0; i < this._errorQueueSize; i++) {
                const weight = this._weights[i], e = errorQueue[(i + head) % this._errorQueueSize];
                r += e.r * weight, g += e.g * weight, b += e.b * weight, a += e.a * weight;
            }
            const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a)), quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);
            head = (head + 1) % this._errorQueueSize;
            const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;
            errorQueue[tail].r = p.r - quantizedPoint.r, errorQueue[tail].g = p.g - quantizedPoint.g, 
            errorQueue[tail].b = p.b - quantizedPoint.b, errorQueue[tail].a = p.a - quantizedPoint.a, 
            p.from(quantizedPoint);
        })), yield {
            pointContainer,
            progress: 100
        };
    }
    static _createWeights(errorPropagation, errorQueueSize) {
        const weights = [], multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));
        for (let i = 0, next = 1; i < errorQueueSize; i++) weights[i] = (next + 0.5 | 0) / errorQueueSize * errorPropagation, 
        next *= multiplier;
        return weights;
    }
}, quality_exports = {};

function ssim(image1, image2) {
    if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) throw new Error("Images have different sizes!");
    const c1 = (.01 * 255) ** 2, c2 = (.03 * 255) ** 2;
    let numWindows = 0, mssim = 0;
    return function iterate(image1, image2, callback) {
        const width = image1.getWidth(), height = image1.getHeight();
        for (let y2 = 0; y2 < height; y2 += 8) for (let x2 = 0; x2 < width; x2 += 8) {
            const windowWidth = Math.min(8, width - x2), windowHeight = Math.min(8, height - y2), lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight), lumaValues2 = calculateLumaValuesForWindow(image2, x2, y2, windowWidth, windowHeight);
            callback(lumaValues1, lumaValues2, calculateAverageLuma(lumaValues1), calculateAverageLuma(lumaValues2));
        }
    }(image1, image2, ((lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {
        let sigxy = 0, sigsqx = 0, sigsqy = 0;
        for (let i = 0; i < lumaValues1.length; i++) sigsqx += (lumaValues1[i] - averageLumaValue1) ** 2, 
        sigsqy += (lumaValues2[i] - averageLumaValue2) ** 2, sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
        const numPixelsInWin = lumaValues1.length - 1;
        sigsqx /= numPixelsInWin, sigsqy /= numPixelsInWin, sigxy /= numPixelsInWin, mssim += (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2) / ((averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c2)), 
        numWindows++;
    })), mssim / numWindows;
}

function calculateLumaValuesForWindow(image, x2, y2, width, height) {
    const pointArray = image.getPointArray(), lumaValues = [];
    let counter = 0;
    for (let j = y2; j < y2 + height; j++) {
        const offset = j * image.getWidth();
        for (let i = x2; i < x2 + width; i++) {
            const point = pointArray[offset + i];
            lumaValues[counter] = 0.2126 * point.r + 0.7152 * point.g + 0.0722 * point.b, counter++;
        }
    }
    return lumaValues;
}

function calculateAverageLuma(lumaValues) {
    let sumLuma = 0;
    for (const luma of lumaValues) sumLuma += luma;
    return sumLuma / lumaValues.length;
}

__export(quality_exports, {
    ssim: () => ssim
});

var setImmediateImpl = "function" == typeof setImmediate ? setImmediate : "undefined" != typeof process && "function" == typeof (null == process ? void 0 : process.nextTick) ? callback => process.nextTick(callback) : callback => setTimeout(callback, 0);

function buildPaletteSync(images, {colorDistanceFormula, paletteQuantization, colors} = {}) {
    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(colorDistanceFormulaToColorDistance(colorDistanceFormula), paletteQuantization, colors);
    return images.forEach((image => paletteQuantizer.sample(image))), paletteQuantizer.quantizeSync();
}

async function buildPalette(images, {colorDistanceFormula, paletteQuantization, colors, onProgress} = {}) {
    return new Promise(((resolve, reject) => {
        const paletteQuantizer = paletteQuantizationToPaletteQuantizer(colorDistanceFormulaToColorDistance(colorDistanceFormula), paletteQuantization, colors);
        let palette;
        images.forEach((image => paletteQuantizer.sample(image)));
        const iterator = paletteQuantizer.quantize(), next = () => {
            try {
                const result = iterator.next();
                result.done ? resolve(palette) : (result.value.palette && (palette = result.value.palette), 
                onProgress && onProgress(result.value.progress), setImmediateImpl(next));
            } catch (error) {
                reject(error);
            }
        };
        setImmediateImpl(next);
    }));
}

function applyPaletteSync(image, palette, {colorDistanceFormula, imageQuantization} = {}) {
    return imageQuantizationToImageQuantizer(colorDistanceFormulaToColorDistance(colorDistanceFormula), imageQuantization).quantizeSync(image, palette);
}

async function applyPalette(image, palette, {colorDistanceFormula, imageQuantization, onProgress} = {}) {
    return new Promise(((resolve, reject) => {
        let outPointContainer;
        const iterator = imageQuantizationToImageQuantizer(colorDistanceFormulaToColorDistance(colorDistanceFormula), imageQuantization).quantize(image, palette), next = () => {
            try {
                const result = iterator.next();
                result.done ? resolve(outPointContainer) : (result.value.pointContainer && (outPointContainer = result.value.pointContainer), 
                onProgress && onProgress(result.value.progress), setImmediateImpl(next));
            } catch (error) {
                reject(error);
            }
        };
        setImmediateImpl(next);
    }));
}

function colorDistanceFormulaToColorDistance(colorDistanceFormula = "euclidean-bt709") {
    switch (colorDistanceFormula) {
      case "cie94-graphic-arts":
        return new CIE94GraphicArts;

      case "cie94-textiles":
        return new CIE94Textiles;

      case "ciede2000":
        return new CIEDE2000;

      case "color-metric":
        return new CMetric;

      case "euclidean":
        return new Euclidean;

      case "euclidean-bt709":
        return new EuclideanBT709;

      case "euclidean-bt709-noalpha":
        return new EuclideanBT709NoAlpha;

      case "manhattan":
        return new Manhattan;

      case "manhattan-bt709":
        return new ManhattanBT709;

      case "manhattan-nommyde":
        return new ManhattanNommyde;

      case "pngquant":
        return new PNGQuant;

      default:
        throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);
    }
}

function imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = "floyd-steinberg") {
    switch (imageQuantization) {
      case "nearest":
        return new NearestColor(distanceCalculator);

      case "riemersma":
        return new ErrorDiffusionRiemersma(distanceCalculator);

      case "floyd-steinberg":
        return new ErrorDiffusionArray(distanceCalculator, 0);

      case "false-floyd-steinberg":
        return new ErrorDiffusionArray(distanceCalculator, 1);

      case "stucki":
        return new ErrorDiffusionArray(distanceCalculator, 2);

      case "atkinson":
        return new ErrorDiffusionArray(distanceCalculator, 3);

      case "jarvis":
        return new ErrorDiffusionArray(distanceCalculator, 4);

      case "burkes":
        return new ErrorDiffusionArray(distanceCalculator, 5);

      case "sierra":
        return new ErrorDiffusionArray(distanceCalculator, 6);

      case "two-sierra":
        return new ErrorDiffusionArray(distanceCalculator, 7);

      case "sierra-lite":
        return new ErrorDiffusionArray(distanceCalculator, 8);

      default:
        throw new Error(`Unknown imageQuantization ${imageQuantization}`);
    }
}

function paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = "wuquant", colors = 256) {
    switch (paletteQuantization) {
      case "neuquant":
        return new NeuQuant$1(distanceCalculator, colors);

      case "rgbquant":
        return new RGBQuant(distanceCalculator, colors);

      case "wuquant":
        return new WuQuant(distanceCalculator, colors);

      case "neuquant-float":
        return new NeuQuantFloat(distanceCalculator, colors);

      default:
        throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);
    }
}

var imageQ = __toCommonJS(src_exports), gifframe = {};

const BitmapImage$1 = bitmapimage;

class GifFrame$2 extends BitmapImage$1 {
    constructor(...args) {
        if (super(...args), args[0] instanceof GifFrame$2) {
            const source = args[0];
            this.xOffset = source.xOffset, this.yOffset = source.yOffset, this.disposalMethod = source.disposalMethod, 
            this.delayCentisecs = source.delayCentisecs, this.interlaced = source.interlaced;
        } else {
            const lastArg = args[args.length - 1];
            let options = {};
            "object" != typeof lastArg || lastArg instanceof BitmapImage$1 || (options = lastArg), 
            this.xOffset = options.xOffset || 0, this.yOffset = options.yOffset || 0, this.disposalMethod = void 0 !== options.disposalMethod ? options.disposalMethod : GifFrame$2.DisposeToBackgroundColor, 
            this.delayCentisecs = options.delayCentisecs || 8, this.interlaced = options.interlaced || !1;
        }
    }
    getPalette() {
        const colorSet = new Set, buf = this.bitmap.data;
        let i = 0, usesTransparency = !1;
        for (;i < buf.length; ) {
            if (0 === buf[i + 3]) usesTransparency = !0; else {
                const color = buf.readUInt32BE(i, !0) >> 8 & 0xFFFFFF;
                colorSet.add(color);
            }
            i += 4;
        }
        const colors = new Array(colorSet.size), iter = colorSet.values();
        for (i = 0; i < colors.length; ++i) colors[i] = iter.next().value;
        colors.sort(((a, b) => a - b));
        let indexCount = colors.length;
        return usesTransparency && ++indexCount, {
            colors,
            usesTransparency,
            indexCount
        };
    }
}

GifFrame$2.DisposeToAnything = 0, GifFrame$2.DisposeNothing = 1, GifFrame$2.DisposeToBackgroundColor = 2, 
GifFrame$2.DisposeToPrevious = 3, gifframe.GifFrame = GifFrame$2, function(exports) {
    const fs = require$$1__default.default, ImageQ = imageQ, BitmapImage = bitmapimage, {GifFrame} = gifframe, {GifError} = gif, INVALID_SUFFIXES = [ ".jpg", ".jpeg", ".png", ".bmp" ];
    function _quantize(imageOrImages, method, maxColorIndexes, modifier, dither) {
        const images = Array.isArray(imageOrImages) ? imageOrImages : [ imageOrImages ];
        if (dither) {
            if ([ "FloydSteinberg", "FalseFloydSteinberg", "Stucki", "Atkinson", "Jarvis", "Burkes", "Sierra", "TwoSierra", "SierraLite" ].indexOf(dither.ditherAlgorithm) < 0) throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);
            void 0 === dither.serpentine && (dither.serpentine = !0), void 0 === dither.minimumColorDistanceToDither && (dither.minimumColorDistanceToDither = 0), 
            void 0 === dither.calculateErrorLikeGIMP && (dither.calculateErrorLikeGIMP = !1);
        }
        const distCalculator = new ImageQ.distance.Euclidean, quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);
        let imageMaker;
        imageMaker = dither ? new ImageQ.image.ErrorDiffusionArray(distCalculator, ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm], dither.serpentine, dither.minimumColorDistanceToDither, dither.calculateErrorLikeGIMP) : new ImageQ.image.NearestColor(distCalculator);
        const inputContainers = [];
        images.forEach((image => {
            const imageBuf = image.bitmap.data, inputBuf = new ArrayBuffer(imageBuf.length), inputArray = new Uint32Array(inputBuf);
            for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) inputArray[ai] = imageBuf.readUInt32LE(bi, !0);
            const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(inputArray, image.bitmap.width, image.bitmap.height);
            quantizer.sample(inputContainer), inputContainers.push(inputContainer);
        }));
        const limitedPalette = quantizer.quantizeSync();
        for (let i = 0; i < images.length; ++i) {
            const imageBuf = images[i].bitmap.data, outputArray = imageMaker.quantizeSync(inputContainers[i], limitedPalette).toUint32Array();
            for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) imageBuf.writeUInt32LE(outputArray[ai], bi);
        }
    }
    exports.cloneFrames = function(frames) {
        let clones = [];
        return frames.forEach((frame => {
            clones.push(new GifFrame(frame));
        })), clones;
    }, exports.getColorInfo = function(frames, maxGlobalIndex) {
        let usesTransparency = !1;
        const palettes = [];
        for (let i = 0; i < frames.length; ++i) {
            let palette = frames[i].getPalette();
            if (palette.usesTransparency && (usesTransparency = !0), palette.indexCount > 256) throw new GifError(`Frame ${i} uses more than 256 color indexes`);
            palettes.push(palette);
        }
        if (0 === maxGlobalIndex) return {
            usesTransparency,
            palettes
        };
        const globalColorSet = new Set;
        palettes.forEach((palette => {
            palette.colors.forEach((color => {
                globalColorSet.add(color);
            }));
        }));
        let indexCount = globalColorSet.size;
        if (usesTransparency && ++indexCount, maxGlobalIndex && indexCount > maxGlobalIndex) return {
            usesTransparency,
            palettes
        };
        const colors = new Array(globalColorSet.size), iter = globalColorSet.values();
        for (let i = 0; i < colors.length; ++i) colors[i] = iter.next().value;
        return colors.sort(((a, b) => a - b)), {
            colors,
            indexCount,
            usesTransparency,
            palettes
        };
    }, exports.copyAsJimp = function(jimp, bitmapImageToCopy) {
        return exports.shareAsJimp(jimp, new BitmapImage(bitmapImageToCopy));
    }, exports.getMaxDimensions = function(frames) {
        let maxWidth = 0, maxHeight = 0;
        return frames.forEach((frame => {
            const width = frame.xOffset + frame.bitmap.width;
            width > maxWidth && (maxWidth = width);
            const height = frame.yOffset + frame.bitmap.height;
            height > maxHeight && (maxHeight = height);
        })), {
            maxWidth,
            maxHeight
        };
    }, exports.quantizeDekker = function(imageOrImages, maxColorIndexes, dither) {
        _quantize(imageOrImages, "NeuQuantFloat", maxColorIndexes = maxColorIndexes || 256, 0, dither);
    }, exports.quantizeSorokin = function(imageOrImages, maxColorIndexes, histogram, dither) {
        let histogramID;
        switch (maxColorIndexes = maxColorIndexes || 256, histogram = histogram || "min-pop") {
          case "min-pop":
            histogramID = 2;
            break;

          case "top-pop":
            histogramID = 1;
            break;

          default:
            throw new Error(`Invalid quantizeSorokin histogram '${histogram}'`);
        }
        _quantize(imageOrImages, "RGBQuant", maxColorIndexes, histogramID, dither);
    }, exports.quantizeWu = function(imageOrImages, maxColorIndexes, significantBits, dither) {
        if (maxColorIndexes = maxColorIndexes || 256, (significantBits = significantBits || 5) < 1 || significantBits > 8) throw new Error("Invalid quantization quality");
        _quantize(imageOrImages, "WuQuant", maxColorIndexes, significantBits, dither);
    }, exports.read = function(source, decoder) {
        return Buffer.isBuffer(source) ? decoder.decodeGif(source) : function _readBinary(path) {
            return new Promise(((resolve, reject) => {
                fs.readFile(path, ((err, buffer) => err ? reject(err) : resolve(buffer)));
            }));
        }(source).then((buffer => decoder.decodeGif(buffer)));
    }, exports.shareAsJimp = function(jimp, bitmapImageToShare) {
        const jimpImage = new jimp(bitmapImageToShare.bitmap.width, bitmapImageToShare.bitmap.height, 0);
        return jimpImage.bitmap.data = bitmapImageToShare.bitmap.data, jimpImage;
    }, exports.write = function(path, frames, spec, encoder) {
        const matches = path.match(/\.[a-zA-Z]+$/);
        if (null !== matches && INVALID_SUFFIXES.includes(matches[0].toLowerCase())) throw new Error(`GIF '${path}' has an unexpected suffix`);
        return encoder.encodeGif(frames, spec).then((gif => function _writeBinary(path, buffer) {
            return new Promise(((resolve, reject) => {
                fs.writeFile(path, buffer, (err => err ? reject(err) : resolve()));
            }));
        }(path, gif.buffer).then((() => gif))));
    };
}(gifutil);

const Omggif = omggif, {Gif: Gif$1, GifError: GifError$2} = gif, GifUtil$1 = gifutil, {GifFrame: GifFrame$1} = gifframe;

function _colorLookupLinear(colors, color) {
    const index = colors.indexOf(color);
    return -1 === index ? null : index;
}

function _colorLookupBinary(colors, color) {
    for (var mid, lo = 0, hi = colors.length - 1; lo <= hi; ) if (colors[mid = Math.floor((lo + hi) / 2)] > color) hi = mid - 1; else {
        if (!(colors[mid] < color)) return mid;
        lo = mid + 1;
    }
    return null;
}

function _extendPaletteToPowerOf2(palette) {
    const colors = palette.colors;
    palette.usesTransparency && colors.push(0);
    const colorCount = colors.length;
    let powerOf2 = 2;
    for (;colorCount > powerOf2; ) powerOf2 <<= 1;
    colors.length = powerOf2, colors.fill(0, colorCount);
}

function _getFrameSizeEst(frame, pixelBitWidth) {
    let byteLength = frame.bitmap.width * frame.bitmap.height;
    return byteLength = Math.ceil(byteLength * pixelBitWidth / 8), byteLength += Math.ceil(byteLength / 255), 
    100 + byteLength + 768;
}

function _getPixelBitWidth(palette) {
    let indexCount = palette.indexCount, pixelBitWidth = 0;
    for (--indexCount; indexCount; ) ++pixelBitWidth, indexCount >>= 1;
    return pixelBitWidth > 0 ? pixelBitWidth : 1;
}

function _writeFrame(gifWriter, frameIndex, frame, palette, isLocalPalette) {
    if (frame.interlaced) throw new GifError$2("writing interlaced GIFs is not supported");
    const frameInfo = function _getIndexedImage(frameIndex, frame, palette) {
        const colors = palette.colors, colorToIndexFunc = colors.length <= 8 ? _colorLookupLinear : _colorLookupBinary, colorBuffer = frame.bitmap.data, indexBuffer = new Buffer(colorBuffer.length / 4);
        let transparentIndex = colors.length, i = 0, j = 0;
        for (;i < colorBuffer.length; ) {
            if (0 !== colorBuffer[i + 3]) {
                const color = colorBuffer.readUInt32BE(i, !0) >> 8 & 0xFFFFFF;
                indexBuffer[j] = colorToIndexFunc(colors, color);
            } else indexBuffer[j] = transparentIndex;
            i += 4, ++j;
        }
        if (palette.usesTransparency) {
            if (256 === transparentIndex) throw new GifError$2(`Frame ${frameIndex} already has 256 colorsand so can't use transparency`);
        } else transparentIndex = null;
        return {
            buffer: indexBuffer,
            transparentIndex
        };
    }(frameIndex, frame, palette), options = {
        delay: frame.delayCentisecs,
        disposal: frame.disposalMethod,
        transparent: frameInfo.transparentIndex
    };
    isLocalPalette && (_extendPaletteToPowerOf2(palette), options.palette = palette.colors);
    try {
        let endOfFrame, buffer = gifWriter.getOutputBuffer(), startOfFrame = gifWriter.getOutputBufferPosition(), tryAgain = !0;
        for (;tryAgain; ) if (endOfFrame = gifWriter.addFrame(frame.xOffset, frame.yOffset, frame.bitmap.width, frame.bitmap.height, frameInfo.buffer, options), 
        tryAgain = !1, endOfFrame >= buffer.length - 1) {
            const biggerBuffer = new Buffer(1.5 * buffer.length);
            buffer.copy(biggerBuffer), gifWriter.setOutputBuffer(biggerBuffer), gifWriter.setOutputBufferPosition(startOfFrame), 
            buffer = biggerBuffer, tryAgain = !0;
        }
        return buffer;
    } catch (err) {
        throw new GifError$2(err);
    }
}

gifcodec.GifCodec = class GifCodec$1 {
    constructor(options = {}) {
        this._transparentRGB = null, "number" == typeof options.transparentRGB && 0 !== options.transparentRGB && (this._transparentRGBA = 256 * options.transparentRGB), 
        this._testInitialBufferSize = 0;
    }
    decodeGif(buffer) {
        try {
            let reader;
            try {
                reader = new Omggif.GifReader(buffer);
            } catch (err) {
                throw new GifError$2(err);
            }
            const frameCount = reader.numFrames(), frames = [], spec = {
                width: reader.width,
                height: reader.height,
                loops: reader.loopCount(),
                usesTransparency: !1
            };
            for (let i = 0; i < frameCount; ++i) {
                const frameInfo = this._decodeFrame(reader, i, spec.usesTransparency);
                frames.push(frameInfo.frame), frameInfo.usesTransparency && (spec.usesTransparency = !0);
            }
            return Promise.resolve(new Gif$1(buffer, frames, spec));
        } catch (err) {
            return Promise.reject(err);
        }
    }
    encodeGif(frames, spec = {}) {
        try {
            if (null === frames || 0 === frames.length) throw new GifError$2("there are no frames");
            const dims = GifUtil$1.getMaxDimensions(frames);
            return (spec = Object.assign({}, spec)).width = dims.maxWidth, spec.height = dims.maxHeight, 
            spec.loops = spec.loops || 0, spec.colorScope = spec.colorScope || Gif$1.GlobalColorsPreferred, 
            Promise.resolve(this._encodeGif(frames, spec));
        } catch (err) {
            return Promise.reject(err);
        }
    }
    _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {
        let info, buffer;
        try {
            if (info = reader.frameInfo(frameIndex), buffer = new Buffer(reader.width * reader.height * 4), 
            reader.decodeAndBlitFrameRGBA(frameIndex, buffer), info.width !== reader.width || info.height !== reader.height) {
                if (info.y && (buffer = buffer.slice(info.y * reader.width * 4)), reader.width > info.width) for (let ii = 0; ii < info.height; ++ii) buffer.copy(buffer, ii * info.width * 4, 4 * (info.x + ii * reader.width), 4 * (info.x + ii * reader.width) + 4 * info.width);
                buffer = buffer.slice(0, info.width * info.height * 4);
            }
        } catch (err) {
            throw new GifError$2(err);
        }
        let usesTransparency = !1;
        if (null === this._transparentRGBA) {
            if (!alreadyUsedTransparency) for (let i = 3; i < buffer.length; i += 4) 0 === buffer[i] && (usesTransparency = !0, 
            i = buffer.length);
        } else for (let i = 3; i < buffer.length; i += 4) 0 === buffer[i] && (buffer.writeUInt32BE(this._transparentRGBA, i - 3), 
        usesTransparency = !0);
        return {
            frame: new GifFrame$1(info.width, info.height, buffer, {
                xOffset: info.x,
                yOffset: info.y,
                disposalMethod: info.disposal,
                interlaced: info.interlaced,
                delayCentisecs: info.delay
            }),
            usesTransparency
        };
    }
    _encodeGif(frames, spec) {
        let colorInfo;
        if (spec.colorScope === Gif$1.LocalColorsOnly) colorInfo = GifUtil$1.getColorInfo(frames, 0); else if (colorInfo = GifUtil$1.getColorInfo(frames, 256), 
        !colorInfo.colors) {
            if (spec.colorScope === Gif$1.GlobalColorsOnly) throw new GifError$2("Too many color indexes for global color table");
            spec.colorScope = Gif$1.LocalColorsOnly;
        }
        spec.usesTransparency = colorInfo.usesTransparency;
        const localPalettes = colorInfo.palettes;
        return spec.colorScope === Gif$1.LocalColorsOnly ? function _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {
            const options = {
                loop: spec.loops
            };
            let gifWriter, buffer = new Buffer(bufferSizeEst);
            try {
                gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
            } catch (err) {
                throw new GifError$2(err);
            }
            for (let i = 0; i < frames.length; ++i) buffer = _writeFrame(gifWriter, i, frames[i], localPalettes[i], !0);
            return new Gif$1(buffer.slice(0, gifWriter.end()), frames, spec);
        }(frames, spec, 2000, localPalettes) : function _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {
            const extendedGlobalPalette = {
                colors: globalPalette.colors.slice(),
                usesTransparency: globalPalette.usesTransparency
            };
            _extendPaletteToPowerOf2(extendedGlobalPalette);
            const options = {
                palette: extendedGlobalPalette.colors,
                loop: spec.loops
            };
            let gifWriter, buffer = new Buffer(bufferSizeEst);
            try {
                gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
            } catch (err) {
                throw new GifError$2(err);
            }
            for (let i = 0; i < frames.length; ++i) buffer = _writeFrame(gifWriter, i, frames[i], globalPalette, !1);
            return new Gif$1(buffer.slice(0, gifWriter.end()), frames, spec);
        }(frames, spec, 2000, colorInfo);
    }
    _getSizeEstimateGlobal(globalPalette, frames) {
        if (this._testInitialBufferSize > 0) return this._testInitialBufferSize;
        let sizeEst = 968;
        const pixelBitWidth = _getPixelBitWidth(globalPalette);
        return frames.forEach((frame => {
            sizeEst += _getFrameSizeEst(frame, pixelBitWidth);
        })), sizeEst;
    }
    _getSizeEstimateLocal(palettes, frames) {
        if (this._testInitialBufferSize > 0) return this._testInitialBufferSize;
        let sizeEst = 200;
        for (let i = 0; i < frames.length; ++i) {
            const pixelBitWidth = _getPixelBitWidth(palettes[i]);
            sizeEst += _getFrameSizeEst(frames[i], pixelBitWidth);
        }
        return sizeEst;
    }
};

const BitmapImage = bitmapimage, {Gif, GifError: GifError$1} = gif, {GifCodec} = gifcodec, {GifFrame} = gifframe;

var src = {
    BitmapImage,
    Gif,
    GifCodec,
    GifFrame,
    GifUtil: gifutil,
    GifError: GifError$1
};

!function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _defineProperty2 = _interopRequireDefault(defineProperty.exports), _omggif = _interopRequireDefault(omggif), _gifwrap = src;
    exports.default = function _default() {
        return {
            mime: (0, _defineProperty2.default)({}, "image/gif", [ "gif" ]),
            constants: {
                MIME_GIF: "image/gif"
            },
            decoders: (0, _defineProperty2.default)({}, "image/gif", (function(data) {
                var gifObj = new _omggif.default.GifReader(data), gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);
                return gifObj.decodeAndBlitFrameRGBA(0, gifData), {
                    data: gifData,
                    width: gifObj.width,
                    height: gifObj.height
                };
            })),
            encoders: (0, _defineProperty2.default)({}, "image/gif", (function(data) {
                var bitmap = new _gifwrap.BitmapImage(data.bitmap);
                _gifwrap.GifUtil.quantizeDekker(bitmap, 256);
                var newFrame = new _gifwrap.GifFrame(bitmap);
                return (new _gifwrap.GifCodec).encodeGif([ newFrame ], {}).then((function(newGif) {
                    return newGif.buffer;
                }));
            }))
        };
    };
}(es$m), function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _timm = timm$1, _jpeg = _interopRequireDefault(es$q), _png = _interopRequireDefault(es$p), _bmp = _interopRequireDefault(es$o), _tiff = _interopRequireDefault(es$n), _gif = _interopRequireDefault(es$m);
    exports.default = function _default() {
        return (0, _timm.mergeDeep)((0, _jpeg.default)(), (0, _png.default)(), (0, _bmp.default)(), (0, 
        _tiff.default)(), (0, _gif.default)());
    };
}(es$r);

var es$l = {}, es$k = {};

!function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _typeof2 = _interopRequireDefault(_typeof$1.exports), _utils = es$s;
    exports.default = function _default() {
        return {
            blit: function blit(src, x, y, srcx, srcy, srcw, srch, cb) {
                if (!(src instanceof this.constructor)) return _utils.throwError.call(this, "The source must be a Jimp image", cb);
                if ("number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
                if ("function" == typeof srcx) cb = srcx, srcx = 0, srcy = 0, srcw = src.bitmap.width, 
                srch = src.bitmap.height; else {
                    if ((0, _typeof2.default)(srcx) !== (0, _typeof2.default)(srcy) || (0, _typeof2.default)(srcy) !== (0, 
                    _typeof2.default)(srcw) || (0, _typeof2.default)(srcw) !== (0, _typeof2.default)(srch)) return _utils.throwError.call(this, "srcx, srcy, srcw, srch must be numbers", cb);
                    srcx = srcx || 0, srcy = srcy || 0, srcw = srcw || src.bitmap.width, srch = srch || src.bitmap.height;
                }
                x = Math.round(x), y = Math.round(y), srcx = Math.round(srcx), srcy = Math.round(srcy), 
                srcw = Math.round(srcw), srch = Math.round(srch);
                var maxWidth = this.bitmap.width, maxHeight = this.bitmap.height, baseImage = this;
                return src.scanQuiet(srcx, srcy, srcw, srch, (function(sx, sy, idx) {
                    var xOffset = x + sx - srcx, yOffset = y + sy - srcy;
                    if (xOffset >= 0 && yOffset >= 0 && maxWidth - xOffset > 0 && maxHeight - yOffset > 0) {
                        var dstIdx = baseImage.getPixelIndex(xOffset, yOffset), _src = {
                            r: this.bitmap.data[idx],
                            g: this.bitmap.data[idx + 1],
                            b: this.bitmap.data[idx + 2],
                            a: this.bitmap.data[idx + 3]
                        }, dst = {
                            r: baseImage.bitmap.data[dstIdx],
                            g: baseImage.bitmap.data[dstIdx + 1],
                            b: baseImage.bitmap.data[dstIdx + 2],
                            a: baseImage.bitmap.data[dstIdx + 3]
                        };
                        baseImage.bitmap.data[dstIdx] = (_src.a * (_src.r - dst.r) - dst.r + 255 >> 8) + dst.r, 
                        baseImage.bitmap.data[dstIdx + 1] = (_src.a * (_src.g - dst.g) - dst.g + 255 >> 8) + dst.g, 
                        baseImage.bitmap.data[dstIdx + 2] = (_src.a * (_src.b - dst.b) - dst.b + 255 >> 8) + dst.b, 
                        baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(dst.a + _src.a);
                    }
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            }
        };
    };
}(es$k);

var es$j = {}, blurTables = {};

Object.defineProperty(blurTables, "__esModule", {
    value: !0
}), blurTables.shgTable = blurTables.mulTable = void 0, blurTables.mulTable = [ 1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1 ], 
blurTables.shgTable = [ 0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18 ], 
function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s, _blurTables = blurTables;
    exports.default = function _default() {
        return {
            blur: function blur(r, cb) {
                if ("number" != typeof r) return _utils.throwError.call(this, "r must be a number", cb);
                if (r < 1) return _utils.throwError.call(this, "r must be greater than 0", cb);
                for (var rsum, gsum, bsum, asum, x, y, i, p, p1, p2, yp, yi, yw, pa, wm = this.bitmap.width - 1, hm = this.bitmap.height - 1, rad1 = r + 1, mulSum = _blurTables.mulTable[r], shgSum = _blurTables.shgTable[r], red = [], green = [], blue = [], alpha = [], vmin = [], vmax = [], iterations = 2; iterations-- > 0; ) {
                    for (yi = 0, yw = 0, y = 0; y < this.bitmap.height; y++) {
                        for (rsum = this.bitmap.data[yw] * rad1, gsum = this.bitmap.data[yw + 1] * rad1, 
                        bsum = this.bitmap.data[yw + 2] * rad1, asum = this.bitmap.data[yw + 3] * rad1, 
                        i = 1; i <= r; i++) p = yw + ((i > wm ? wm : i) << 2), rsum += this.bitmap.data[p++], 
                        gsum += this.bitmap.data[p++], bsum += this.bitmap.data[p++], asum += this.bitmap.data[p];
                        for (x = 0; x < this.bitmap.width; x++) red[yi] = rsum, green[yi] = gsum, blue[yi] = bsum, 
                        alpha[yi] = asum, 0 === y && (vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2, vmax[x] = (p = x - r) > 0 ? p << 2 : 0), 
                        p1 = yw + vmin[x], p2 = yw + vmax[x], rsum += this.bitmap.data[p1++] - this.bitmap.data[p2++], 
                        gsum += this.bitmap.data[p1++] - this.bitmap.data[p2++], bsum += this.bitmap.data[p1++] - this.bitmap.data[p2++], 
                        asum += this.bitmap.data[p1] - this.bitmap.data[p2], yi++;
                        yw += this.bitmap.width << 2;
                    }
                    for (x = 0; x < this.bitmap.width; x++) {
                        for (rsum = red[yp = x] * rad1, gsum = green[yp] * rad1, bsum = blue[yp] * rad1, 
                        asum = alpha[yp] * rad1, i = 1; i <= r; i++) rsum += red[yp += i > hm ? 0 : this.bitmap.width], 
                        gsum += green[yp], bsum += blue[yp], asum += alpha[yp];
                        for (yi = x << 2, y = 0; y < this.bitmap.height; y++) pa = asum * mulSum >>> shgSum, 
                        this.bitmap.data[yi + 3] = pa, pa > 255 && (this.bitmap.data[yi + 3] = 255), pa > 0 ? (pa = 255 / pa, 
                        this.bitmap.data[yi] = (rsum * mulSum >>> shgSum) * pa, this.bitmap.data[yi + 1] = (gsum * mulSum >>> shgSum) * pa, 
                        this.bitmap.data[yi + 2] = (bsum * mulSum >>> shgSum) * pa) : (this.bitmap.data[yi + 2] = 0, 
                        this.bitmap.data[yi + 1] = 0, this.bitmap.data[yi] = 0), 0 === x && (vmin[y] = ((p = y + rad1) < hm ? p : hm) * this.bitmap.width, 
                        vmax[y] = (p = y - r) > 0 ? p * this.bitmap.width : 0), p1 = x + vmin[y], p2 = x + vmax[y], 
                        rsum += red[p1] - red[p2], gsum += green[p1] - green[p2], bsum += blue[p1] - blue[p2], 
                        asum += alpha[p1] - alpha[p2], yi += this.bitmap.width << 2;
                    }
                }
                return (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            }
        };
    };
}(es$j);

var es$i = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    exports.default = function _default() {
        return {
            circle: function circle() {
                var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, cb = arguments.length > 1 ? arguments[1] : void 0;
                "function" == typeof options && (cb = options, options = {});
                var radius = options.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2, center = {
                    x: "number" == typeof options.x ? options.x : this.bitmap.width / 2,
                    y: "number" == typeof options.y ? options.y : this.bitmap.height / 2
                };
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    var curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));
                    radius - curR <= 0.0 ? this.bitmap.data[idx + 3] = 0 : radius - curR < 1.0 && (this.bitmap.data[idx + 3] = 255 * (radius - curR));
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            }
        };
    };
}(es$i);

var es$h = {};

!function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _toConsumableArray2 = _interopRequireDefault(toConsumableArray.exports), _tinycolor = _interopRequireDefault(tinycolor.exports), _utils = es$s;
    function applyKernel(im, kernel, x, y) {
        for (var value = [ 0, 0, 0 ], size = (kernel.length - 1) / 2, kx = 0; kx < kernel.length; kx += 1) for (var ky = 0; ky < kernel[kx].length; ky += 1) {
            var idx = im.getPixelIndex(x + kx - size, y + ky - size);
            value[0] += im.bitmap.data[idx] * kernel[kx][ky], value[1] += im.bitmap.data[idx + 1] * kernel[kx][ky], 
            value[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];
        }
        return value;
    }
    var isDef = function isDef(v) {
        return null != v;
    };
    function greyscale(cb) {
        return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
            var grey = parseInt(0.2126 * this.bitmap.data[idx] + 0.7152 * this.bitmap.data[idx + 1] + 0.0722 * this.bitmap.data[idx + 2], 10);
            this.bitmap.data[idx] = grey, this.bitmap.data[idx + 1] = grey, this.bitmap.data[idx + 2] = grey;
        })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
    }
    function mix(clr, clr2) {
        var p = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 50;
        return {
            r: (clr2.r - clr.r) * (p / 100) + clr.r,
            g: (clr2.g - clr.g) * (p / 100) + clr.g,
            b: (clr2.b - clr.b) * (p / 100) + clr.b
        };
    }
    function colorFn(actions, cb) {
        var _this = this;
        return actions && Array.isArray(actions) ? (actions = actions.map((function(action) {
            return "xor" !== action.apply && "mix" !== action.apply || (action.params[0] = (0, 
            _tinycolor.default)(action.params[0]).toRgb()), action;
        })), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
            var clr = {
                r: _this.bitmap.data[idx],
                g: _this.bitmap.data[idx + 1],
                b: _this.bitmap.data[idx + 2]
            }, colorModifier = function colorModifier(i, amount) {
                return _this.constructor.limit255(clr[i] + amount);
            };
            actions.forEach((function(action) {
                if ("mix" === action.apply) clr = mix(clr, action.params[0], action.params[1]); else if ("tint" === action.apply) clr = mix(clr, {
                    r: 255,
                    g: 255,
                    b: 255
                }, action.params[0]); else if ("shade" === action.apply) clr = mix(clr, {
                    r: 0,
                    g: 0,
                    b: 0
                }, action.params[0]); else if ("xor" === action.apply) clr = {
                    r: clr.r ^ action.params[0].r,
                    g: clr.g ^ action.params[0].g,
                    b: clr.b ^ action.params[0].b
                }; else if ("red" === action.apply) clr.r = colorModifier("r", action.params[0]); else if ("green" === action.apply) clr.g = colorModifier("g", action.params[0]); else if ("blue" === action.apply) clr.b = colorModifier("b", action.params[0]); else {
                    var _clr;
                    if ("hue" === action.apply && (action.apply = "spin"), !(clr = (0, _tinycolor.default)(clr))[action.apply]) return _utils.throwError.call(_this, "action " + action.apply + " not supported", cb);
                    clr = (_clr = clr)[action.apply].apply(_clr, (0, _toConsumableArray2.default)(action.params)).toRgb();
                }
            })), _this.bitmap.data[idx] = clr.r, _this.bitmap.data[idx + 1] = clr.g, _this.bitmap.data[idx + 2] = clr.b;
        })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this) : _utils.throwError.call(this, "actions must be an array", cb);
    }
    exports.default = function _default() {
        return {
            brightness: function brightness(val, cb) {
                return "number" != typeof val ? _utils.throwError.call(this, "val must be numbers", cb) : val < -1 || val > 1 ? _utils.throwError.call(this, "val must be a number between -1 and +1", cb) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    val < 0.0 ? (this.bitmap.data[idx] = this.bitmap.data[idx] * (1 + val), this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] * (1 + val), 
                    this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] * (1 + val)) : (this.bitmap.data[idx] = this.bitmap.data[idx] + (255 - this.bitmap.data[idx]) * val, 
                    this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] + (255 - this.bitmap.data[idx + 1]) * val, 
                    this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] + (255 - this.bitmap.data[idx + 2]) * val);
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
            },
            contrast: function contrast(val, cb) {
                if ("number" != typeof val) return _utils.throwError.call(this, "val must be numbers", cb);
                if (val < -1 || val > 1) return _utils.throwError.call(this, "val must be a number between -1 and +1", cb);
                var factor = (val + 1) / (1 - val);
                function adjust(value) {
                    return (value = Math.floor(factor * (value - 127) + 127)) < 0 ? 0 : value > 255 ? 255 : value;
                }
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    this.bitmap.data[idx] = adjust(this.bitmap.data[idx]), this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]), 
                    this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            },
            posterize: function posterize(n, cb) {
                return "number" != typeof n ? _utils.throwError.call(this, "n must be numbers", cb) : (n < 2 && (n = 2), 
                this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    this.bitmap.data[idx] = Math.floor(this.bitmap.data[idx] / 255 * (n - 1)) / (n - 1) * 255, 
                    this.bitmap.data[idx + 1] = Math.floor(this.bitmap.data[idx + 1] / 255 * (n - 1)) / (n - 1) * 255, 
                    this.bitmap.data[idx + 2] = Math.floor(this.bitmap.data[idx + 2] / 255 * (n - 1)) / (n - 1) * 255;
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
            },
            greyscale,
            grayscale: greyscale,
            opacity: function opacity(f, cb) {
                return "number" != typeof f ? _utils.throwError.call(this, "f must be a number", cb) : f < 0 || f > 1 ? _utils.throwError.call(this, "f must be a number from 0 to 1", cb) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    var v = this.bitmap.data[idx + 3] * f;
                    this.bitmap.data[idx + 3] = v;
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
            },
            sepia: function sepia(cb) {
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    var red = this.bitmap.data[idx], green = this.bitmap.data[idx + 1], blue = this.bitmap.data[idx + 2];
                    blue = 0.272 * (red = 0.393 * red + 0.769 * green + 0.189 * blue) + 0.534 * (green = 0.349 * red + 0.686 * green + 0.168 * blue) + 0.131 * blue, 
                    this.bitmap.data[idx] = red < 255 ? red : 255, this.bitmap.data[idx + 1] = green < 255 ? green : 255, 
                    this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            },
            fade: function fade(f, cb) {
                return "number" != typeof f ? _utils.throwError.call(this, "f must be a number", cb) : f < 0 || f > 1 ? _utils.throwError.call(this, "f must be a number from 0 to 1", cb) : (this.opacity(1 - f), 
                (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
            },
            convolution: function convolution(kernel, edgeHandling, cb) {
                "function" == typeof edgeHandling && void 0 === cb && (cb = edgeHandling, edgeHandling = null), 
                edgeHandling || (edgeHandling = this.constructor.EDGE_EXTEND);
                var weight, rSum, gSum, bSum, ri, gi, bi, xi, yi, idxi, newData = Buffer.from(this.bitmap.data), kRows = kernel.length, kCols = kernel[0].length, rowEnd = Math.floor(kRows / 2), colEnd = Math.floor(kCols / 2), rowIni = -rowEnd, colIni = -colEnd;
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    bSum = 0, gSum = 0, rSum = 0;
                    for (var row = rowIni; row <= rowEnd; row++) for (var col = colIni; col <= colEnd; col++) xi = x + col, 
                    yi = y + row, weight = kernel[row + rowEnd][col + colEnd], -1 === (idxi = this.getPixelIndex(xi, yi, edgeHandling)) ? (bi = 0, 
                    gi = 0, ri = 0) : (ri = this.bitmap.data[idxi + 0], gi = this.bitmap.data[idxi + 1], 
                    bi = this.bitmap.data[idxi + 2]), rSum += weight * ri, gSum += weight * gi, bSum += weight * bi;
                    rSum < 0 && (rSum = 0), gSum < 0 && (gSum = 0), bSum < 0 && (bSum = 0), rSum > 255 && (rSum = 255), 
                    gSum > 255 && (gSum = 255), bSum > 255 && (bSum = 255), newData[idx + 0] = rSum, 
                    newData[idx + 1] = gSum, newData[idx + 2] = bSum;
                })), this.bitmap.data = newData, (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
                this;
            },
            opaque: function opaque(cb) {
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    this.bitmap.data[idx + 3] = 255;
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            },
            pixelate: function pixelate(size, x, y, w, h, cb) {
                if ("function" == typeof x) cb = x, h = null, w = null, y = null, x = null; else {
                    if ("number" != typeof size) return _utils.throwError.call(this, "size must be a number", cb);
                    if (isDef(x) && "number" != typeof x) return _utils.throwError.call(this, "x must be a number", cb);
                    if (isDef(y) && "number" != typeof y) return _utils.throwError.call(this, "y must be a number", cb);
                    if (isDef(w) && "number" != typeof w) return _utils.throwError.call(this, "w must be a number", cb);
                    if (isDef(h) && "number" != typeof h) return _utils.throwError.call(this, "h must be a number", cb);
                }
                var kernel = [ [ 1 / 16, 2 / 16, 1 / 16 ], [ 2 / 16, .25, 2 / 16 ], [ 1 / 16, 2 / 16, 1 / 16 ] ];
                x = x || 0, y = y || 0, w = isDef(w) ? w : this.bitmap.width - x, h = isDef(h) ? h : this.bitmap.height - y;
                var source = this.cloneQuiet();
                return this.scanQuiet(x, y, w, h, (function(xx, yx, idx) {
                    xx = size * Math.floor(xx / size), yx = size * Math.floor(yx / size);
                    var value = applyKernel(source, kernel, xx, yx);
                    this.bitmap.data[idx] = value[0], this.bitmap.data[idx + 1] = value[1], this.bitmap.data[idx + 2] = value[2];
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            },
            convolute: function convolute(kernel, x, y, w, h, cb) {
                if (!Array.isArray(kernel)) return _utils.throwError.call(this, "the kernel must be an array", cb);
                if ("function" == typeof x) cb = x, x = null, y = null, w = null, h = null; else {
                    if (isDef(x) && "number" != typeof x) return _utils.throwError.call(this, "x must be a number", cb);
                    if (isDef(y) && "number" != typeof y) return _utils.throwError.call(this, "y must be a number", cb);
                    if (isDef(w) && "number" != typeof w) return _utils.throwError.call(this, "w must be a number", cb);
                    if (isDef(h) && "number" != typeof h) return _utils.throwError.call(this, "h must be a number", cb);
                }
                var ksize = (kernel.length - 1) / 2;
                x = isDef(x) ? x : ksize, y = isDef(y) ? y : ksize, w = isDef(w) ? w : this.bitmap.width - x, 
                h = isDef(h) ? h : this.bitmap.height - y;
                var source = this.cloneQuiet();
                return this.scanQuiet(x, y, w, h, (function(xx, yx, idx) {
                    var value = applyKernel(source, kernel, xx, yx);
                    this.bitmap.data[idx] = this.constructor.limit255(value[0]), this.bitmap.data[idx + 1] = this.constructor.limit255(value[1]), 
                    this.bitmap.data[idx + 2] = this.constructor.limit255(value[2]);
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            },
            color: colorFn,
            colour: colorFn
        };
    };
}(es$h);

var es$g = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    exports.default = function _default() {
        return {
            contain: function contain(w, h, alignBits, mode, cb) {
                if ("number" != typeof w || "number" != typeof h) return _utils.throwError.call(this, "w and h must be numbers", cb);
                "string" == typeof alignBits && ("function" == typeof mode && void 0 === cb && (cb = mode), 
                mode = alignBits, alignBits = null), "function" == typeof alignBits && (void 0 === cb && (cb = alignBits), 
                mode = null, alignBits = null), "function" == typeof mode && void 0 === cb && (cb = mode, 
                mode = null);
                var hbits = 7 & (alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE), vbits = alignBits >> 3;
                if ((0 === hbits || hbits & hbits - 1) && (0 === vbits || vbits & vbits - 1)) return _utils.throwError.call(this, "only use one flag per alignment direction", cb);
                var alignH = hbits >> 1, alignV = vbits >> 1, f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width, c = this.cloneQuiet().scale(f, mode);
                return this.resize(w, h, mode), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    this.bitmap.data.writeUInt32BE(this._background, idx);
                })), this.blit(c, (this.bitmap.width - c.bitmap.width) / 2 * alignH, (this.bitmap.height - c.bitmap.height) / 2 * alignV), 
                (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            }
        };
    };
}(es$g);

var es$f = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    exports.default = function _default() {
        return {
            cover: function cover(w, h, alignBits, mode, cb) {
                if ("number" != typeof w || "number" != typeof h) return _utils.throwError.call(this, "w and h must be numbers", cb);
                alignBits && "function" == typeof alignBits && void 0 === cb ? (cb = alignBits, 
                alignBits = null, mode = null) : "function" == typeof mode && void 0 === cb && (cb = mode, 
                mode = null);
                var hbits = 7 & (alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE), vbits = alignBits >> 3;
                if ((0 === hbits || hbits & hbits - 1) && (0 === vbits || vbits & vbits - 1)) return _utils.throwError.call(this, "only use one flag per alignment direction", cb);
                var alignH = hbits >> 1, alignV = vbits >> 1, f = w / h > this.bitmap.width / this.bitmap.height ? w / this.bitmap.width : h / this.bitmap.height;
                return this.scale(f, mode), this.crop((this.bitmap.width - w) / 2 * alignH, (this.bitmap.height - h) / 2 * alignV, w, h), 
                (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            }
        };
    };
}(es$f);

var es$e = {};

!function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = function pluginCrop(event) {
        return event("crop", (function(x, y, w, h, cb) {
            if ("number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
            if ("number" != typeof w || "number" != typeof h) return _utils.throwError.call(this, "w and h must be numbers", cb);
            if (x = Math.round(x), y = Math.round(y), w = Math.round(w), h = Math.round(h), 
            0 === x && w === this.bitmap.width) {
                var start = w * y + x << 2, end = start + h * w << 2;
                this.bitmap.data = this.bitmap.data.slice(start, end);
            } else {
                var bitmap = Buffer.allocUnsafe(w * h * 4), offset = 0;
                this.scanQuiet(x, y, w, h, (function(x, y, idx) {
                    var data = this.bitmap.data.readUInt32BE(idx, !0);
                    bitmap.writeUInt32BE(data, offset, !0), offset += 4;
                })), this.bitmap.data = bitmap;
            }
            return this.bitmap.width = w, this.bitmap.height = h, (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
            this;
        })), {
            class: {
                autocrop: function autocrop() {
                    for (var cb, w = this.bitmap.width, h = this.bitmap.height, minPixelsPerSide = 1, leaveBorder = 0, tolerance = 0.0002, cropOnlyFrames = !0, cropSymmetric = !1, ignoreSides = {
                        north: !1,
                        south: !1,
                        east: !1,
                        west: !1
                    }, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    for (var a = 0, len = args.length; a < len; a++) if ("number" == typeof args[a] && (tolerance = args[a]), 
                    "boolean" == typeof args[a] && (cropOnlyFrames = args[a]), "function" == typeof args[a] && (cb = args[a]), 
                    "object" === (0, _typeof2.default)(args[a])) {
                        var config = args[a];
                        void 0 !== config.tolerance && (tolerance = config.tolerance), void 0 !== config.cropOnlyFrames && (cropOnlyFrames = config.cropOnlyFrames), 
                        void 0 !== config.cropSymmetric && (cropSymmetric = config.cropSymmetric), void 0 !== config.leaveBorder && (leaveBorder = config.leaveBorder), 
                        void 0 !== config.ignoreSides && (ignoreSides = config.ignoreSides);
                    }
                    var colorTarget = this.getPixelColor(0, 0), rgba1 = this.constructor.intToRGBA(colorTarget), northPixelsToCrop = 0, eastPixelsToCrop = 0, southPixelsToCrop = 0, westPixelsToCrop = 0;
                    if (colorTarget = this.getPixelColor(0, 0), !ignoreSides.north) north: for (var y = 0; y < h - minPixelsPerSide; y++) {
                        for (var x = 0; x < w; x++) {
                            var colorXY = this.getPixelColor(x, y), rgba2 = this.constructor.intToRGBA(colorXY);
                            if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) break north;
                        }
                        northPixelsToCrop++;
                    }
                    if (colorTarget = this.getPixelColor(w, 0), !ignoreSides.east) east: for (var _x = 0; _x < w - minPixelsPerSide; _x++) {
                        for (var _y = 0 + northPixelsToCrop; _y < h; _y++) {
                            var _colorXY = this.getPixelColor(_x, _y), _rgba = this.constructor.intToRGBA(_colorXY);
                            if (this.constructor.colorDiff(rgba1, _rgba) > tolerance) break east;
                        }
                        eastPixelsToCrop++;
                    }
                    if (colorTarget = this.getPixelColor(0, h), !ignoreSides.south) south: for (var _y2 = h - 1; _y2 >= northPixelsToCrop + minPixelsPerSide; _y2--) {
                        for (var _x2 = w - eastPixelsToCrop - 1; _x2 >= 0; _x2--) {
                            var _colorXY2 = this.getPixelColor(_x2, _y2), _rgba2 = this.constructor.intToRGBA(_colorXY2);
                            if (this.constructor.colorDiff(rgba1, _rgba2) > tolerance) break south;
                        }
                        southPixelsToCrop++;
                    }
                    if (colorTarget = this.getPixelColor(w, h), !ignoreSides.west) west: for (var _x3 = w - 1; _x3 >= 0 + eastPixelsToCrop + minPixelsPerSide; _x3--) {
                        for (var _y3 = h - 1; _y3 >= 0 + northPixelsToCrop; _y3--) {
                            var _colorXY3 = this.getPixelColor(_x3, _y3), _rgba3 = this.constructor.intToRGBA(_colorXY3);
                            if (this.constructor.colorDiff(rgba1, _rgba3) > tolerance) break west;
                        }
                        westPixelsToCrop++;
                    }
                    if (westPixelsToCrop -= leaveBorder, eastPixelsToCrop -= leaveBorder, northPixelsToCrop -= leaveBorder, 
                    southPixelsToCrop -= leaveBorder, cropSymmetric) {
                        var horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop), vertical = Math.min(northPixelsToCrop, southPixelsToCrop);
                        westPixelsToCrop = horizontal, eastPixelsToCrop = horizontal, northPixelsToCrop = vertical, 
                        southPixelsToCrop = vertical;
                    }
                    var widthOfRemainingPixels = w - ((westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0) + (eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0)), heightOfRemainingPixels = h - ((southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0) + (northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0));
                    return (cropOnlyFrames ? 0 !== eastPixelsToCrop && 0 !== northPixelsToCrop && 0 !== westPixelsToCrop && 0 !== southPixelsToCrop : 0 !== eastPixelsToCrop || 0 !== northPixelsToCrop || 0 !== westPixelsToCrop || 0 !== southPixelsToCrop) && this.crop(eastPixelsToCrop, northPixelsToCrop, widthOfRemainingPixels, heightOfRemainingPixels), 
                    (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                }
            }
        };
    };
    var _typeof2 = _interopRequireDefault(_typeof$1.exports), _utils = es$s;
}(es$e);

var es$d = {};

!function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _typeof2 = _interopRequireDefault(_typeof$1.exports), _utils = es$s;
    exports.default = function _default() {
        return {
            displace: function displace(map, offset, cb) {
                if ("object" !== (0, _typeof2.default)(map) || map.constructor !== this.constructor) return _utils.throwError.call(this, "The source must be a Jimp image", cb);
                if ("number" != typeof offset) return _utils.throwError.call(this, "factor must be a number", cb);
                var source = this.cloneQuiet();
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    var displacement = map.bitmap.data[idx] / 256 * offset;
                    displacement = Math.round(displacement);
                    var ids = this.getPixelIndex(x + displacement, y);
                    this.bitmap.data[ids] = source.bitmap.data[idx], this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1], 
                    this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            }
        };
    };
}(es$d);

var es$c = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    function dither(cb) {
        var rgb565Matrix = [ 1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6 ];
        return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
            var dither = rgb565Matrix[((3 & y) << 2) + x % 4];
            this.bitmap.data[idx] = Math.min(this.bitmap.data[idx] + dither, 0xff), this.bitmap.data[idx + 1] = Math.min(this.bitmap.data[idx + 1] + dither, 0xff), 
            this.bitmap.data[idx + 2] = Math.min(this.bitmap.data[idx + 2] + dither, 0xff);
        })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
    }
    exports.default = function _default() {
        return {
            dither565: dither,
            dither16: dither
        };
    };
}(es$c);

var es$b = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    exports.default = function _default() {
        return {
            fisheye: function fisheye() {
                var _this = this, options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                    r: 2.5
                }, cb = arguments.length > 1 ? arguments[1] : void 0;
                "function" == typeof options && (cb = options, options = {
                    r: 2.5
                });
                var source = this.cloneQuiet(), _source$bitmap = source.bitmap, width = _source$bitmap.width, height = _source$bitmap.height;
                return source.scanQuiet(0, 0, width, height, (function(x, y) {
                    var hx = x / width, hy = y / height, r = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2)), rn = 2 * Math.pow(r, options.r), cosA = (hx - 0.5) / r, sinA = (hy - 0.5) / r, newX = Math.round((rn * cosA + 0.5) * width), newY = Math.round((rn * sinA + 0.5) * height), color = source.getPixelColor(newX, newY);
                    _this.setPixelColor(color, x, y);
                })), this.setPixelColor(source.getPixelColor(width / 2, height / 2), width / 2, height / 2), 
                (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            }
        };
    };
}(es$b);

var es$a = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    function flipFn(horizontal, vertical, cb) {
        if ("boolean" != typeof horizontal || "boolean" != typeof vertical) return _utils.throwError.call(this, "horizontal and vertical must be Booleans", cb);
        var bitmap = Buffer.alloc(this.bitmap.data.length);
        return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
            var _x = horizontal ? this.bitmap.width - 1 - x : x, _y = vertical ? this.bitmap.height - 1 - y : y, _idx = this.bitmap.width * _y + _x << 2, data = this.bitmap.data.readUInt32BE(idx);
            bitmap.writeUInt32BE(data, _idx);
        })), this.bitmap.data = Buffer.from(bitmap), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
        this;
    }
    exports.default = function _default() {
        return {
            flip: flipFn,
            mirror: flipFn
        };
    };
}(es$a);

var es$9 = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    exports.default = function _default() {
        return {
            gaussian: function gaussian(r, cb) {
                if ("number" != typeof r) return _utils.throwError.call(this, "r must be a number", cb);
                if (r < 1) return _utils.throwError.call(this, "r must be greater than 0", cb);
                for (var rs = Math.ceil(2.57 * r), range = 2 * rs + 1, rr2 = r * r * 2, rr2pi = rr2 * Math.PI, weights = [], y = 0; y < range; y++) {
                    weights[y] = [];
                    for (var x = 0; x < range; x++) {
                        var dsq = Math.pow(x - rs, 2) + Math.pow(y - rs, 2);
                        weights[y][x] = Math.exp(-dsq / rr2) / rr2pi;
                    }
                }
                for (var _y = 0; _y < this.bitmap.height; _y++) for (var _x = 0; _x < this.bitmap.width; _x++) for (var red = 0, green = 0, blue = 0, alpha = 0, wsum = 0, iy = 0; iy < range; iy++) {
                    for (var ix = 0; ix < range; ix++) {
                        var x1 = Math.min(this.bitmap.width - 1, Math.max(0, ix + _x - rs)), y1 = Math.min(this.bitmap.height - 1, Math.max(0, iy + _y - rs)), weight = weights[iy][ix], _idx = y1 * this.bitmap.width + x1 << 2;
                        red += this.bitmap.data[_idx] * weight, green += this.bitmap.data[_idx + 1] * weight, 
                        blue += this.bitmap.data[_idx + 2] * weight, alpha += this.bitmap.data[_idx + 3] * weight, 
                        wsum += weight;
                    }
                    var idx = _y * this.bitmap.width + _x << 2;
                    this.bitmap.data[idx] = Math.round(red / wsum), this.bitmap.data[idx + 1] = Math.round(green / wsum), 
                    this.bitmap.data[idx + 2] = Math.round(blue / wsum), this.bitmap.data[idx + 3] = Math.round(alpha / wsum);
                }
                return (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            }
        };
    };
}(es$9);

var es$8 = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    exports.default = function _default() {
        return {
            invert: function invert(cb) {
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    this.bitmap.data[idx] = 255 - this.bitmap.data[idx], this.bitmap.data[idx + 1] = 255 - this.bitmap.data[idx + 1], 
                    this.bitmap.data[idx + 2] = 255 - this.bitmap.data[idx + 2];
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            }
        };
    };
}(es$8);

var es$7 = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    exports.default = function _default() {
        return {
            mask: function mask(src) {
                var x = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, y = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, cb = arguments.length > 3 ? arguments[3] : void 0;
                if (!(src instanceof this.constructor)) return _utils.throwError.call(this, "The source must be a Jimp image", cb);
                if ("number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
                x = Math.round(x), y = Math.round(y);
                var w = this.bitmap.width, h = this.bitmap.height, baseImage = this;
                return src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, (function(sx, sy, idx) {
                    var destX = x + sx, destY = y + sy;
                    if (destX >= 0 && destY >= 0 && destX < w && destY < h) {
                        var dstIdx = baseImage.getPixelIndex(destX, destY), data = this.bitmap.data, avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;
                        baseImage.bitmap.data[dstIdx + 3] *= avg / 255;
                    }
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            }
        };
    };
}(es$7);

var es$6 = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    function histogram() {
        var histogram = {
            r: new Array(256).fill(0),
            g: new Array(256).fill(0),
            b: new Array(256).fill(0)
        };
        return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, index) {
            histogram.r[this.bitmap.data[index + 0]]++, histogram.g[this.bitmap.data[index + 1]]++, 
            histogram.b[this.bitmap.data[index + 2]]++;
        })), histogram;
    }
    var _normalize = function normalize(value, min, max) {
        return 255 * (value - min) / (max - min);
    }, getBounds = function getBounds(histogramChannel) {
        return [ histogramChannel.findIndex((function(value) {
            return value > 0;
        })), 255 - histogramChannel.slice().reverse().findIndex((function(value) {
            return value > 0;
        })) ];
    };
    exports.default = function _default() {
        return {
            normalize: function normalize(cb) {
                var h = histogram.call(this), bounds = {
                    r: getBounds(h.r),
                    g: getBounds(h.g),
                    b: getBounds(h.b)
                };
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    var r = this.bitmap.data[idx + 0], g = this.bitmap.data[idx + 1], b = this.bitmap.data[idx + 2];
                    this.bitmap.data[idx + 0] = _normalize(r, bounds.r[0], bounds.r[1]), this.bitmap.data[idx + 1] = _normalize(g, bounds.g[0], bounds.g[1]), 
                    this.bitmap.data[idx + 2] = _normalize(b, bounds.b[0], bounds.b[1]);
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            }
        };
    };
}(es$6);

var es$5 = {};

function splitLine(line, idx) {
    if (!(line = line.replace(/\t+/g, " ").trim())) return null;
    var space = line.indexOf(" ");
    if (-1 === space) throw new Error("no named row at line " + idx);
    var key = line.substring(0, space);
    line = (line = (line = (line = line.substring(space + 1)).replace(/letter=[\'\"]\S+[\'\"]/gi, "")).split("=")).map((function(str) {
        return str.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
    }));
    for (var data = [], i = 0; i < line.length; i++) {
        var dt = line[i];
        0 === i ? data.push({
            key: dt[0],
            data: ""
        }) : i === line.length - 1 ? data[data.length - 1].data = parseData(dt[0]) : (data[data.length - 1].data = parseData(dt[0]), 
        data.push({
            key: dt[1],
            data: ""
        }));
    }
    var out = {
        key,
        data: {}
    };
    return data.forEach((function(v) {
        out.data[v.key] = v.data;
    })), out;
}

function parseData(data) {
    return data && 0 !== data.length ? 0 === data.indexOf('"') || 0 === data.indexOf("'") ? data.substring(1, data.length - 1) : -1 !== data.indexOf(",") ? function parseIntList$1(data) {
        return data.split(",").map((function(val) {
            return parseInt(val, 10);
        }));
    }(data) : parseInt(data, 10) : "";
}

var xml2js$1 = {}, defaults = {};

(function() {
    defaults.defaults = {
        0.1: {
            explicitCharkey: !1,
            trim: !0,
            normalize: !0,
            normalizeTags: !1,
            attrkey: "@",
            charkey: "#",
            explicitArray: !1,
            ignoreAttrs: !1,
            mergeAttrs: !1,
            explicitRoot: !1,
            validator: null,
            xmlns: !1,
            explicitChildren: !1,
            childkey: "@@",
            charsAsChildren: !1,
            includeWhiteChars: !1,
            async: !1,
            strict: !0,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            emptyTag: ""
        },
        0.2: {
            explicitCharkey: !1,
            trim: !1,
            normalize: !1,
            normalizeTags: !1,
            attrkey: "$",
            charkey: "_",
            explicitArray: !0,
            ignoreAttrs: !1,
            mergeAttrs: !1,
            explicitRoot: !0,
            validator: null,
            xmlns: !1,
            explicitChildren: !1,
            preserveChildrenOrder: !1,
            childkey: "$$",
            charsAsChildren: !1,
            includeWhiteChars: !1,
            async: !1,
            strict: !0,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            rootName: "root",
            xmldec: {
                version: "1.0",
                encoding: "UTF-8",
                standalone: !0
            },
            doctype: null,
            renderOpts: {
                pretty: !0,
                indent: "  ",
                newline: "\n"
            },
            headless: !1,
            chunkSize: 10000,
            emptyTag: "",
            cdata: !1
        }
    };
}).call(commonjsGlobal);

var builder = {}, lib$1 = {}, Utility = {};

(function() {
    var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
    assign = function() {
        var i, key, len, source, sources, target;
        if (target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [], 
        isFunction(Object.assign)) Object.assign.apply(null, arguments); else for (i = 0, 
        len = sources.length; i < len; i++) if (null != (source = sources[i])) for (key in source) hasProp.call(source, key) && (target[key] = source[key]);
        return target;
    }, isFunction = function(val) {
        return !!val && "[object Function]" === Object.prototype.toString.call(val);
    }, isObject = function(val) {
        var ref;
        return !!val && ("function" == (ref = typeof val) || "object" === ref);
    }, isArray = function(val) {
        return isFunction(Array.isArray) ? Array.isArray(val) : "[object Array]" === Object.prototype.toString.call(val);
    }, isEmpty = function(val) {
        var key;
        if (isArray(val)) return !val.length;
        for (key in val) if (hasProp.call(val, key)) return !1;
        return !0;
    }, isPlainObject = function(val) {
        var ctor, proto;
        return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && "function" == typeof ctor && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    }, getValue = function(obj) {
        return isFunction(obj.valueOf) ? obj.valueOf() : obj;
    }, Utility.assign = assign, Utility.isFunction = isFunction, Utility.isObject = isObject, 
    Utility.isArray = isArray, Utility.isEmpty = isEmpty, Utility.isPlainObject = isPlainObject, 
    Utility.getValue = getValue;
}).call(commonjsGlobal);

var XMLDOMImplementation = {
    exports: {}
};

(function() {
    XMLDOMImplementation.exports = function() {
        function XMLDOMImplementation() {}
        return XMLDOMImplementation.prototype.hasFeature = function(feature, version) {
            return !0;
        }, XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
            throw new Error("This DOM method is not implemented.");
        }, XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
            throw new Error("This DOM method is not implemented.");
        }, XMLDOMImplementation.prototype.createHTMLDocument = function(title) {
            throw new Error("This DOM method is not implemented.");
        }, XMLDOMImplementation.prototype.getFeature = function(feature, version) {
            throw new Error("This DOM method is not implemented.");
        }, XMLDOMImplementation;
    }();
}).call(commonjsGlobal);

var XMLDocument = {
    exports: {}
}, XMLDOMConfiguration = {
    exports: {}
}, XMLDOMErrorHandler = {
    exports: {}
};

(function() {
    XMLDOMErrorHandler.exports = function() {
        function XMLDOMErrorHandler() {}
        return XMLDOMErrorHandler.prototype.handleError = function(error) {
            throw new Error(error);
        }, XMLDOMErrorHandler;
    }();
}).call(commonjsGlobal);

var XMLDOMStringList = {
    exports: {}
};

(function() {
    XMLDOMStringList.exports = function() {
        function XMLDOMStringList(arr) {
            this.arr = arr || [];
        }
        return Object.defineProperty(XMLDOMStringList.prototype, "length", {
            get: function() {
                return this.arr.length;
            }
        }), XMLDOMStringList.prototype.item = function(index) {
            return this.arr[index] || null;
        }, XMLDOMStringList.prototype.contains = function(str) {
            return -1 !== this.arr.indexOf(str);
        }, XMLDOMStringList;
    }();
}).call(commonjsGlobal), function() {
    var XMLDOMErrorHandler$1, XMLDOMStringList$1;
    XMLDOMErrorHandler$1 = XMLDOMErrorHandler.exports, XMLDOMStringList$1 = XMLDOMStringList.exports, 
    XMLDOMConfiguration.exports = function() {
        function XMLDOMConfiguration() {
            this.defaultParams = {
                "canonical-form": !1,
                "cdata-sections": !1,
                comments: !1,
                "datatype-normalization": !1,
                "element-content-whitespace": !0,
                entities: !0,
                "error-handler": new XMLDOMErrorHandler$1,
                infoset: !0,
                "validate-if-schema": !1,
                namespaces: !0,
                "namespace-declarations": !0,
                "normalize-characters": !1,
                "schema-location": "",
                "schema-type": "",
                "split-cdata-sections": !0,
                validate: !1,
                "well-formed": !0
            }, this.params = Object.create(this.defaultParams);
        }
        return Object.defineProperty(XMLDOMConfiguration.prototype, "parameterNames", {
            get: function() {
                return new XMLDOMStringList$1(Object.keys(this.defaultParams));
            }
        }), XMLDOMConfiguration.prototype.getParameter = function(name) {
            return this.params.hasOwnProperty(name) ? this.params[name] : null;
        }, XMLDOMConfiguration.prototype.canSetParameter = function(name, value) {
            return !0;
        }, XMLDOMConfiguration.prototype.setParameter = function(name, value) {
            return null != value ? this.params[name] = value : delete this.params[name];
        }, XMLDOMConfiguration;
    }();
}.call(commonjsGlobal);

var XMLNode = {
    exports: {}
}, XMLElement = {
    exports: {}
}, NodeType = {
    exports: {}
};

(function() {
    NodeType.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205
    };
}).call(commonjsGlobal);

var XMLAttribute = {
    exports: {}
};

(function() {
    var NodeType$1;
    NodeType$1 = NodeType.exports, XMLAttribute.exports = function() {
        function XMLAttribute(parent, name, value) {
            if (this.parent = parent, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), 
            null == name) throw new Error("Missing attribute name. " + this.debugInfo(name));
            this.name = this.stringify.name(name), this.value = this.stringify.attValue(value), 
            this.type = NodeType$1.Attribute, this.isId = !1, this.schemaTypeInfo = null;
        }
        return Object.defineProperty(XMLAttribute.prototype, "nodeType", {
            get: function() {
                return this.type;
            }
        }), Object.defineProperty(XMLAttribute.prototype, "ownerElement", {
            get: function() {
                return this.parent;
            }
        }), Object.defineProperty(XMLAttribute.prototype, "textContent", {
            get: function() {
                return this.value;
            },
            set: function(value) {
                return this.value = value || "";
            }
        }), Object.defineProperty(XMLAttribute.prototype, "namespaceURI", {
            get: function() {
                return "";
            }
        }), Object.defineProperty(XMLAttribute.prototype, "prefix", {
            get: function() {
                return "";
            }
        }), Object.defineProperty(XMLAttribute.prototype, "localName", {
            get: function() {
                return this.name;
            }
        }), Object.defineProperty(XMLAttribute.prototype, "specified", {
            get: function() {
                return !0;
            }
        }), XMLAttribute.prototype.clone = function() {
            return Object.create(this);
        }, XMLAttribute.prototype.toString = function(options) {
            return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
        }, XMLAttribute.prototype.debugInfo = function(name) {
            return null == (name = name || this.name) ? "parent: <" + this.parent.name + ">" : "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
        }, XMLAttribute.prototype.isEqualNode = function(node) {
            return node.namespaceURI === this.namespaceURI && node.prefix === this.prefix && node.localName === this.localName && node.value === this.value;
        }, XMLAttribute;
    }();
}).call(commonjsGlobal);

var XMLNamedNodeMap = {
    exports: {}
};

(function() {
    XMLNamedNodeMap.exports = function() {
        function XMLNamedNodeMap(nodes) {
            this.nodes = nodes;
        }
        return Object.defineProperty(XMLNamedNodeMap.prototype, "length", {
            get: function() {
                return Object.keys(this.nodes).length || 0;
            }
        }), XMLNamedNodeMap.prototype.clone = function() {
            return this.nodes = null;
        }, XMLNamedNodeMap.prototype.getNamedItem = function(name) {
            return this.nodes[name];
        }, XMLNamedNodeMap.prototype.setNamedItem = function(node) {
            var oldNode;
            return oldNode = this.nodes[node.nodeName], this.nodes[node.nodeName] = node, oldNode || null;
        }, XMLNamedNodeMap.prototype.removeNamedItem = function(name) {
            var oldNode;
            return oldNode = this.nodes[name], delete this.nodes[name], oldNode || null;
        }, XMLNamedNodeMap.prototype.item = function(index) {
            return this.nodes[Object.keys(this.nodes)[index]] || null;
        }, XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
        }, XMLNamedNodeMap.prototype.setNamedItemNS = function(node) {
            throw new Error("This DOM method is not implemented.");
        }, XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
        }, XMLNamedNodeMap;
    }();
}).call(commonjsGlobal), function() {
    var NodeType$1, XMLAttribute$1, XMLNamedNodeMap$1, XMLNode$1, getValue, isFunction, isObject, ref, hasProp = {}.hasOwnProperty;
    isObject = (ref = Utility).isObject, isFunction = ref.isFunction, getValue = ref.getValue, 
    XMLNode$1 = XMLNode.exports, NodeType$1 = NodeType.exports, XMLAttribute$1 = XMLAttribute.exports, 
    XMLNamedNodeMap$1 = XMLNamedNodeMap.exports, XMLElement.exports = function(superClass) {
        function XMLElement(parent, name, attributes) {
            var child, j, len, ref1;
            if (XMLElement.__super__.constructor.call(this, parent), null == name) throw new Error("Missing element name. " + this.debugInfo());
            if (this.name = this.stringify.name(name), this.type = NodeType$1.Element, this.attribs = {}, 
            this.schemaTypeInfo = null, null != attributes && this.attribute(attributes), parent.type === NodeType$1.Document && (this.isRoot = !0, 
            this.documentObject = parent, parent.rootObject = this, parent.children)) for (j = 0, 
            len = (ref1 = parent.children).length; j < len; j++) if ((child = ref1[j]).type === NodeType$1.DocType) {
                child.name = this.name;
                break;
            }
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLElement, superClass), Object.defineProperty(XMLElement.prototype, "tagName", {
            get: function() {
                return this.name;
            }
        }), Object.defineProperty(XMLElement.prototype, "namespaceURI", {
            get: function() {
                return "";
            }
        }), Object.defineProperty(XMLElement.prototype, "prefix", {
            get: function() {
                return "";
            }
        }), Object.defineProperty(XMLElement.prototype, "localName", {
            get: function() {
                return this.name;
            }
        }), Object.defineProperty(XMLElement.prototype, "id", {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        }), Object.defineProperty(XMLElement.prototype, "className", {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        }), Object.defineProperty(XMLElement.prototype, "classList", {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        }), Object.defineProperty(XMLElement.prototype, "attributes", {
            get: function() {
                return this.attributeMap && this.attributeMap.nodes || (this.attributeMap = new XMLNamedNodeMap$1(this.attribs)), 
                this.attributeMap;
            }
        }), XMLElement.prototype.clone = function() {
            var att, attName, clonedSelf, ref1;
            for (attName in (clonedSelf = Object.create(this)).isRoot && (clonedSelf.documentObject = null), 
            clonedSelf.attribs = {}, ref1 = this.attribs) hasProp.call(ref1, attName) && (att = ref1[attName], 
            clonedSelf.attribs[attName] = att.clone());
            return clonedSelf.children = [], this.children.forEach((function(child) {
                var clonedChild;
                return (clonedChild = child.clone()).parent = clonedSelf, clonedSelf.children.push(clonedChild);
            })), clonedSelf;
        }, XMLElement.prototype.attribute = function(name, value) {
            var attName, attValue;
            if (null != name && (name = getValue(name)), isObject(name)) for (attName in name) hasProp.call(name, attName) && (attValue = name[attName], 
            this.attribute(attName, attValue)); else isFunction(value) && (value = value.apply()), 
            this.options.keepNullAttributes && null == value ? this.attribs[name] = new XMLAttribute$1(this, name, "") : null != value && (this.attribs[name] = new XMLAttribute$1(this, name, value));
            return this;
        }, XMLElement.prototype.removeAttribute = function(name) {
            var attName, j, len;
            if (null == name) throw new Error("Missing attribute name. " + this.debugInfo());
            if (name = getValue(name), Array.isArray(name)) for (j = 0, len = name.length; j < len; j++) attName = name[j], 
            delete this.attribs[attName]; else delete this.attribs[name];
            return this;
        }, XMLElement.prototype.toString = function(options) {
            return this.options.writer.element(this, this.options.writer.filterOptions(options));
        }, XMLElement.prototype.att = function(name, value) {
            return this.attribute(name, value);
        }, XMLElement.prototype.a = function(name, value) {
            return this.attribute(name, value);
        }, XMLElement.prototype.getAttribute = function(name) {
            return this.attribs.hasOwnProperty(name) ? this.attribs[name].value : null;
        }, XMLElement.prototype.setAttribute = function(name, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.getAttributeNode = function(name) {
            return this.attribs.hasOwnProperty(name) ? this.attribs[name] : null;
        }, XMLElement.prototype.setAttributeNode = function(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.removeAttributeNode = function(oldAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.getElementsByTagName = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.setAttributeNodeNS = function(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.hasAttribute = function(name) {
            return this.attribs.hasOwnProperty(name);
        }, XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.setIdAttribute = function(name, isId) {
            return this.attribs.hasOwnProperty(name) ? this.attribs[name].isId : isId;
        }, XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.getElementsByTagName = function(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.getElementsByClassName = function(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLElement.prototype.isEqualNode = function(node) {
            var i, j, ref1;
            if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return !1;
            if (node.namespaceURI !== this.namespaceURI) return !1;
            if (node.prefix !== this.prefix) return !1;
            if (node.localName !== this.localName) return !1;
            if (node.attribs.length !== this.attribs.length) return !1;
            for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) if (!this.attribs[i].isEqualNode(node.attribs[i])) return !1;
            return !0;
        }, XMLElement;
    }(XMLNode$1);
}.call(commonjsGlobal);

var XMLCData = {
    exports: {}
}, XMLCharacterData = {
    exports: {}
};

(function() {
    var XMLNode$1, hasProp = {}.hasOwnProperty;
    XMLNode$1 = XMLNode.exports, XMLCharacterData.exports = function(superClass) {
        function XMLCharacterData(parent) {
            XMLCharacterData.__super__.constructor.call(this, parent), this.value = "";
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLCharacterData, superClass), Object.defineProperty(XMLCharacterData.prototype, "data", {
            get: function() {
                return this.value;
            },
            set: function(value) {
                return this.value = value || "";
            }
        }), Object.defineProperty(XMLCharacterData.prototype, "length", {
            get: function() {
                return this.value.length;
            }
        }), Object.defineProperty(XMLCharacterData.prototype, "textContent", {
            get: function() {
                return this.value;
            },
            set: function(value) {
                return this.value = value || "";
            }
        }), XMLCharacterData.prototype.clone = function() {
            return Object.create(this);
        }, XMLCharacterData.prototype.substringData = function(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLCharacterData.prototype.appendData = function(arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLCharacterData.prototype.insertData = function(offset, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLCharacterData.prototype.deleteData = function(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLCharacterData.prototype.replaceData = function(offset, count, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLCharacterData.prototype.isEqualNode = function(node) {
            return !!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node) && node.data === this.data;
        }, XMLCharacterData;
    }(XMLNode$1);
}).call(commonjsGlobal), function() {
    var NodeType$1, XMLCharacterData$1, hasProp = {}.hasOwnProperty;
    NodeType$1 = NodeType.exports, XMLCharacterData$1 = XMLCharacterData.exports, XMLCData.exports = function(superClass) {
        function XMLCData(parent, text) {
            if (XMLCData.__super__.constructor.call(this, parent), null == text) throw new Error("Missing CDATA text. " + this.debugInfo());
            this.name = "#cdata-section", this.type = NodeType$1.CData, this.value = this.stringify.cdata(text);
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLCData, superClass), XMLCData.prototype.clone = function() {
            return Object.create(this);
        }, XMLCData.prototype.toString = function(options) {
            return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
        }, XMLCData;
    }(XMLCharacterData$1);
}.call(commonjsGlobal);

var XMLComment = {
    exports: {}
};

(function() {
    var NodeType$1, XMLCharacterData$1, hasProp = {}.hasOwnProperty;
    NodeType$1 = NodeType.exports, XMLCharacterData$1 = XMLCharacterData.exports, XMLComment.exports = function(superClass) {
        function XMLComment(parent, text) {
            if (XMLComment.__super__.constructor.call(this, parent), null == text) throw new Error("Missing comment text. " + this.debugInfo());
            this.name = "#comment", this.type = NodeType$1.Comment, this.value = this.stringify.comment(text);
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLComment, superClass), XMLComment.prototype.clone = function() {
            return Object.create(this);
        }, XMLComment.prototype.toString = function(options) {
            return this.options.writer.comment(this, this.options.writer.filterOptions(options));
        }, XMLComment;
    }(XMLCharacterData$1);
}).call(commonjsGlobal);

var XMLDeclaration = {
    exports: {}
};

(function() {
    var NodeType$1, XMLNode$1, isObject, hasProp = {}.hasOwnProperty;
    isObject = Utility.isObject, XMLNode$1 = XMLNode.exports, NodeType$1 = NodeType.exports, 
    XMLDeclaration.exports = function(superClass) {
        function XMLDeclaration(parent, version, encoding, standalone) {
            var ref;
            XMLDeclaration.__super__.constructor.call(this, parent), isObject(version) && (version = (ref = version).version, 
            encoding = ref.encoding, standalone = ref.standalone), version || (version = "1.0"), 
            this.type = NodeType$1.Declaration, this.version = this.stringify.xmlVersion(version), 
            null != encoding && (this.encoding = this.stringify.xmlEncoding(encoding)), null != standalone && (this.standalone = this.stringify.xmlStandalone(standalone));
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLDeclaration, superClass), XMLDeclaration.prototype.toString = function(options) {
            return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
        }, XMLDeclaration;
    }(XMLNode$1);
}).call(commonjsGlobal);

var XMLDocType = {
    exports: {}
}, XMLDTDAttList = {
    exports: {}
};

(function() {
    var NodeType$1, XMLNode$1, hasProp = {}.hasOwnProperty;
    XMLNode$1 = XMLNode.exports, NodeType$1 = NodeType.exports, XMLDTDAttList.exports = function(superClass) {
        function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            if (XMLDTDAttList.__super__.constructor.call(this, parent), null == elementName) throw new Error("Missing DTD element name. " + this.debugInfo());
            if (null == attributeName) throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
            if (!attributeType) throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
            if (!defaultValueType) throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
            if (0 !== defaultValueType.indexOf("#") && (defaultValueType = "#" + defaultValueType), 
            !defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
            if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
            this.elementName = this.stringify.name(elementName), this.type = NodeType$1.AttributeDeclaration, 
            this.attributeName = this.stringify.name(attributeName), this.attributeType = this.stringify.dtdAttType(attributeType), 
            defaultValue && (this.defaultValue = this.stringify.dtdAttDefault(defaultValue)), 
            this.defaultValueType = defaultValueType;
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLDTDAttList, superClass), XMLDTDAttList.prototype.toString = function(options) {
            return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
        }, XMLDTDAttList;
    }(XMLNode$1);
}).call(commonjsGlobal);

var XMLDTDEntity = {
    exports: {}
};

(function() {
    var NodeType$1, XMLNode$1, isObject, hasProp = {}.hasOwnProperty;
    isObject = Utility.isObject, XMLNode$1 = XMLNode.exports, NodeType$1 = NodeType.exports, 
    XMLDTDEntity.exports = function(superClass) {
        function XMLDTDEntity(parent, pe, name, value) {
            if (XMLDTDEntity.__super__.constructor.call(this, parent), null == name) throw new Error("Missing DTD entity name. " + this.debugInfo(name));
            if (null == value) throw new Error("Missing DTD entity value. " + this.debugInfo(name));
            if (this.pe = !!pe, this.name = this.stringify.name(name), this.type = NodeType$1.EntityDeclaration, 
            isObject(value)) {
                if (!value.pubID && !value.sysID) throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
                if (value.pubID && !value.sysID) throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
                if (this.internal = !1, null != value.pubID && (this.pubID = this.stringify.dtdPubID(value.pubID)), 
                null != value.sysID && (this.sysID = this.stringify.dtdSysID(value.sysID)), null != value.nData && (this.nData = this.stringify.dtdNData(value.nData)), 
                this.pe && this.nData) throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
            } else this.value = this.stringify.dtdEntityValue(value), this.internal = !0;
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLDTDEntity, superClass), Object.defineProperty(XMLDTDEntity.prototype, "publicId", {
            get: function() {
                return this.pubID;
            }
        }), Object.defineProperty(XMLDTDEntity.prototype, "systemId", {
            get: function() {
                return this.sysID;
            }
        }), Object.defineProperty(XMLDTDEntity.prototype, "notationName", {
            get: function() {
                return this.nData || null;
            }
        }), Object.defineProperty(XMLDTDEntity.prototype, "inputEncoding", {
            get: function() {
                return null;
            }
        }), Object.defineProperty(XMLDTDEntity.prototype, "xmlEncoding", {
            get: function() {
                return null;
            }
        }), Object.defineProperty(XMLDTDEntity.prototype, "xmlVersion", {
            get: function() {
                return null;
            }
        }), XMLDTDEntity.prototype.toString = function(options) {
            return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
        }, XMLDTDEntity;
    }(XMLNode$1);
}).call(commonjsGlobal);

var XMLDTDElement = {
    exports: {}
};

(function() {
    var NodeType$1, XMLNode$1, hasProp = {}.hasOwnProperty;
    XMLNode$1 = XMLNode.exports, NodeType$1 = NodeType.exports, XMLDTDElement.exports = function(superClass) {
        function XMLDTDElement(parent, name, value) {
            if (XMLDTDElement.__super__.constructor.call(this, parent), null == name) throw new Error("Missing DTD element name. " + this.debugInfo());
            value || (value = "(#PCDATA)"), Array.isArray(value) && (value = "(" + value.join(",") + ")"), 
            this.name = this.stringify.name(name), this.type = NodeType$1.ElementDeclaration, 
            this.value = this.stringify.dtdElementValue(value);
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLDTDElement, superClass), XMLDTDElement.prototype.toString = function(options) {
            return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
        }, XMLDTDElement;
    }(XMLNode$1);
}).call(commonjsGlobal);

var XMLDTDNotation = {
    exports: {}
};

(function() {
    var NodeType$1, XMLNode$1, hasProp = {}.hasOwnProperty;
    XMLNode$1 = XMLNode.exports, NodeType$1 = NodeType.exports, XMLDTDNotation.exports = function(superClass) {
        function XMLDTDNotation(parent, name, value) {
            if (XMLDTDNotation.__super__.constructor.call(this, parent), null == name) throw new Error("Missing DTD notation name. " + this.debugInfo(name));
            if (!value.pubID && !value.sysID) throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
            this.name = this.stringify.name(name), this.type = NodeType$1.NotationDeclaration, 
            null != value.pubID && (this.pubID = this.stringify.dtdPubID(value.pubID)), null != value.sysID && (this.sysID = this.stringify.dtdSysID(value.sysID));
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLDTDNotation, superClass), Object.defineProperty(XMLDTDNotation.prototype, "publicId", {
            get: function() {
                return this.pubID;
            }
        }), Object.defineProperty(XMLDTDNotation.prototype, "systemId", {
            get: function() {
                return this.sysID;
            }
        }), XMLDTDNotation.prototype.toString = function(options) {
            return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
        }, XMLDTDNotation;
    }(XMLNode$1);
}).call(commonjsGlobal), function() {
    var NodeType$1, XMLDTDAttList$1, XMLDTDElement$1, XMLDTDEntity$1, XMLDTDNotation$1, XMLNamedNodeMap$1, XMLNode$1, isObject, hasProp = {}.hasOwnProperty;
    isObject = Utility.isObject, XMLNode$1 = XMLNode.exports, NodeType$1 = NodeType.exports, 
    XMLDTDAttList$1 = XMLDTDAttList.exports, XMLDTDEntity$1 = XMLDTDEntity.exports, 
    XMLDTDElement$1 = XMLDTDElement.exports, XMLDTDNotation$1 = XMLDTDNotation.exports, 
    XMLNamedNodeMap$1 = XMLNamedNodeMap.exports, XMLDocType.exports = function(superClass) {
        function XMLDocType(parent, pubID, sysID) {
            var child, i, len, ref, ref1, ref2;
            if (XMLDocType.__super__.constructor.call(this, parent), this.type = NodeType$1.DocType, 
            parent.children) for (i = 0, len = (ref = parent.children).length; i < len; i++) if ((child = ref[i]).type === NodeType$1.Element) {
                this.name = child.name;
                break;
            }
            this.documentObject = parent, isObject(pubID) && (pubID = (ref1 = pubID).pubID, 
            sysID = ref1.sysID), null == sysID && (sysID = (ref2 = [ pubID, sysID ])[0], pubID = ref2[1]), 
            null != pubID && (this.pubID = this.stringify.dtdPubID(pubID)), null != sysID && (this.sysID = this.stringify.dtdSysID(sysID));
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLDocType, superClass), Object.defineProperty(XMLDocType.prototype, "entities", {
            get: function() {
                var child, i, len, nodes, ref;
                for (nodes = {}, i = 0, len = (ref = this.children).length; i < len; i++) (child = ref[i]).type !== NodeType$1.EntityDeclaration || child.pe || (nodes[child.name] = child);
                return new XMLNamedNodeMap$1(nodes);
            }
        }), Object.defineProperty(XMLDocType.prototype, "notations", {
            get: function() {
                var child, i, len, nodes, ref;
                for (nodes = {}, i = 0, len = (ref = this.children).length; i < len; i++) (child = ref[i]).type === NodeType$1.NotationDeclaration && (nodes[child.name] = child);
                return new XMLNamedNodeMap$1(nodes);
            }
        }), Object.defineProperty(XMLDocType.prototype, "publicId", {
            get: function() {
                return this.pubID;
            }
        }), Object.defineProperty(XMLDocType.prototype, "systemId", {
            get: function() {
                return this.sysID;
            }
        }), Object.defineProperty(XMLDocType.prototype, "internalSubset", {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        }), XMLDocType.prototype.element = function(name, value) {
            var child;
            return child = new XMLDTDElement$1(this, name, value), this.children.push(child), 
            this;
        }, XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            var child;
            return child = new XMLDTDAttList$1(this, elementName, attributeName, attributeType, defaultValueType, defaultValue), 
            this.children.push(child), this;
        }, XMLDocType.prototype.entity = function(name, value) {
            var child;
            return child = new XMLDTDEntity$1(this, !1, name, value), this.children.push(child), 
            this;
        }, XMLDocType.prototype.pEntity = function(name, value) {
            var child;
            return child = new XMLDTDEntity$1(this, !0, name, value), this.children.push(child), 
            this;
        }, XMLDocType.prototype.notation = function(name, value) {
            var child;
            return child = new XMLDTDNotation$1(this, name, value), this.children.push(child), 
            this;
        }, XMLDocType.prototype.toString = function(options) {
            return this.options.writer.docType(this, this.options.writer.filterOptions(options));
        }, XMLDocType.prototype.ele = function(name, value) {
            return this.element(name, value);
        }, XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        }, XMLDocType.prototype.ent = function(name, value) {
            return this.entity(name, value);
        }, XMLDocType.prototype.pent = function(name, value) {
            return this.pEntity(name, value);
        }, XMLDocType.prototype.not = function(name, value) {
            return this.notation(name, value);
        }, XMLDocType.prototype.up = function() {
            return this.root() || this.documentObject;
        }, XMLDocType.prototype.isEqualNode = function(node) {
            return !!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node) && node.name === this.name && node.publicId === this.publicId && node.systemId === this.systemId;
        }, XMLDocType;
    }(XMLNode$1);
}.call(commonjsGlobal);

var XMLRaw = {
    exports: {}
};

(function() {
    var NodeType$1, XMLNode$1, hasProp = {}.hasOwnProperty;
    NodeType$1 = NodeType.exports, XMLNode$1 = XMLNode.exports, XMLRaw.exports = function(superClass) {
        function XMLRaw(parent, text) {
            if (XMLRaw.__super__.constructor.call(this, parent), null == text) throw new Error("Missing raw text. " + this.debugInfo());
            this.type = NodeType$1.Raw, this.value = this.stringify.raw(text);
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLRaw, superClass), XMLRaw.prototype.clone = function() {
            return Object.create(this);
        }, XMLRaw.prototype.toString = function(options) {
            return this.options.writer.raw(this, this.options.writer.filterOptions(options));
        }, XMLRaw;
    }(XMLNode$1);
}).call(commonjsGlobal);

var XMLText = {
    exports: {}
};

(function() {
    var NodeType$1, XMLCharacterData$1, hasProp = {}.hasOwnProperty;
    NodeType$1 = NodeType.exports, XMLCharacterData$1 = XMLCharacterData.exports, XMLText.exports = function(superClass) {
        function XMLText(parent, text) {
            if (XMLText.__super__.constructor.call(this, parent), null == text) throw new Error("Missing element text. " + this.debugInfo());
            this.name = "#text", this.type = NodeType$1.Text, this.value = this.stringify.text(text);
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLText, superClass), Object.defineProperty(XMLText.prototype, "isElementContentWhitespace", {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        }), Object.defineProperty(XMLText.prototype, "wholeText", {
            get: function() {
                var next, prev, str;
                for (str = "", prev = this.previousSibling; prev; ) str = prev.data + str, prev = prev.previousSibling;
                for (str += this.data, next = this.nextSibling; next; ) str += next.data, next = next.nextSibling;
                return str;
            }
        }), XMLText.prototype.clone = function() {
            return Object.create(this);
        }, XMLText.prototype.toString = function(options) {
            return this.options.writer.text(this, this.options.writer.filterOptions(options));
        }, XMLText.prototype.splitText = function(offset) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLText.prototype.replaceWholeText = function(content) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLText;
    }(XMLCharacterData$1);
}).call(commonjsGlobal);

var XMLProcessingInstruction = {
    exports: {}
};

(function() {
    var NodeType$1, XMLCharacterData$1, hasProp = {}.hasOwnProperty;
    NodeType$1 = NodeType.exports, XMLCharacterData$1 = XMLCharacterData.exports, XMLProcessingInstruction.exports = function(superClass) {
        function XMLProcessingInstruction(parent, target, value) {
            if (XMLProcessingInstruction.__super__.constructor.call(this, parent), null == target) throw new Error("Missing instruction target. " + this.debugInfo());
            this.type = NodeType$1.ProcessingInstruction, this.target = this.stringify.insTarget(target), 
            this.name = this.target, value && (this.value = this.stringify.insValue(value));
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLProcessingInstruction, superClass), XMLProcessingInstruction.prototype.clone = function() {
            return Object.create(this);
        }, XMLProcessingInstruction.prototype.toString = function(options) {
            return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
        }, XMLProcessingInstruction.prototype.isEqualNode = function(node) {
            return !!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node) && node.target === this.target;
        }, XMLProcessingInstruction;
    }(XMLCharacterData$1);
}).call(commonjsGlobal);

var XMLDummy = {
    exports: {}
};

(function() {
    var NodeType$1, XMLNode$1, hasProp = {}.hasOwnProperty;
    XMLNode$1 = XMLNode.exports, NodeType$1 = NodeType.exports, XMLDummy.exports = function(superClass) {
        function XMLDummy(parent) {
            XMLDummy.__super__.constructor.call(this, parent), this.type = NodeType$1.Dummy;
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLDummy, superClass), XMLDummy.prototype.clone = function() {
            return Object.create(this);
        }, XMLDummy.prototype.toString = function(options) {
            return "";
        }, XMLDummy;
    }(XMLNode$1);
}).call(commonjsGlobal);

var XMLNodeList = {
    exports: {}
};

(function() {
    XMLNodeList.exports = function() {
        function XMLNodeList(nodes) {
            this.nodes = nodes;
        }
        return Object.defineProperty(XMLNodeList.prototype, "length", {
            get: function() {
                return this.nodes.length || 0;
            }
        }), XMLNodeList.prototype.clone = function() {
            return this.nodes = null;
        }, XMLNodeList.prototype.item = function(index) {
            return this.nodes[index] || null;
        }, XMLNodeList;
    }();
}).call(commonjsGlobal);

var DocumentPosition = {
    exports: {}
};

(function() {
    DocumentPosition.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32
    };
}).call(commonjsGlobal), function() {
    var DocumentPosition$1, NodeType$1, XMLCData$1, XMLComment$1, XMLDeclaration$1, XMLDocType$1, XMLDummy$1, XMLElement$1, XMLNodeList$1, XMLProcessingInstruction$1, XMLRaw$1, XMLText$1, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
    isObject = (ref1 = Utility).isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, 
    getValue = ref1.getValue, XMLElement$1 = null, XMLCData$1 = null, XMLComment$1 = null, 
    XMLDeclaration$1 = null, XMLDocType$1 = null, XMLRaw$1 = null, XMLText$1 = null, 
    XMLProcessingInstruction$1 = null, XMLDummy$1 = null, NodeType$1 = null, XMLNodeList$1 = null, 
    DocumentPosition$1 = null, XMLNode.exports = function() {
        function XMLNode(parent1) {
            this.parent = parent1, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), 
            this.value = null, this.children = [], this.baseURI = null, XMLElement$1 || (XMLElement$1 = XMLElement.exports, 
            XMLCData$1 = XMLCData.exports, XMLComment$1 = XMLComment.exports, XMLDeclaration$1 = XMLDeclaration.exports, 
            XMLDocType$1 = XMLDocType.exports, XMLRaw$1 = XMLRaw.exports, XMLText$1 = XMLText.exports, 
            XMLProcessingInstruction$1 = XMLProcessingInstruction.exports, XMLDummy$1 = XMLDummy.exports, 
            NodeType$1 = NodeType.exports, XMLNodeList$1 = XMLNodeList.exports, DocumentPosition$1 = DocumentPosition.exports);
        }
        return Object.defineProperty(XMLNode.prototype, "nodeName", {
            get: function() {
                return this.name;
            }
        }), Object.defineProperty(XMLNode.prototype, "nodeType", {
            get: function() {
                return this.type;
            }
        }), Object.defineProperty(XMLNode.prototype, "nodeValue", {
            get: function() {
                return this.value;
            }
        }), Object.defineProperty(XMLNode.prototype, "parentNode", {
            get: function() {
                return this.parent;
            }
        }), Object.defineProperty(XMLNode.prototype, "childNodes", {
            get: function() {
                return this.childNodeList && this.childNodeList.nodes || (this.childNodeList = new XMLNodeList$1(this.children)), 
                this.childNodeList;
            }
        }), Object.defineProperty(XMLNode.prototype, "firstChild", {
            get: function() {
                return this.children[0] || null;
            }
        }), Object.defineProperty(XMLNode.prototype, "lastChild", {
            get: function() {
                return this.children[this.children.length - 1] || null;
            }
        }), Object.defineProperty(XMLNode.prototype, "previousSibling", {
            get: function() {
                var i;
                return i = this.parent.children.indexOf(this), this.parent.children[i - 1] || null;
            }
        }), Object.defineProperty(XMLNode.prototype, "nextSibling", {
            get: function() {
                var i;
                return i = this.parent.children.indexOf(this), this.parent.children[i + 1] || null;
            }
        }), Object.defineProperty(XMLNode.prototype, "ownerDocument", {
            get: function() {
                return this.document() || null;
            }
        }), Object.defineProperty(XMLNode.prototype, "textContent", {
            get: function() {
                var child, j, len, ref2, str;
                if (this.nodeType === NodeType$1.Element || this.nodeType === NodeType$1.DocumentFragment) {
                    for (str = "", j = 0, len = (ref2 = this.children).length; j < len; j++) (child = ref2[j]).textContent && (str += child.textContent);
                    return str;
                }
                return null;
            },
            set: function(value) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        }), XMLNode.prototype.setParent = function(parent) {
            var child, j, len, ref2, results;
            for (this.parent = parent, parent && (this.options = parent.options, this.stringify = parent.stringify), 
            results = [], j = 0, len = (ref2 = this.children).length; j < len; j++) child = ref2[j], 
            results.push(child.setParent(this));
            return results;
        }, XMLNode.prototype.element = function(name, attributes, text) {
            var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
            if (lastChild = null, null === attributes && null == text && (attributes = (ref2 = [ {}, null ])[0], 
            text = ref2[1]), null == attributes && (attributes = {}), attributes = getValue(attributes), 
            isObject(attributes) || (text = (ref3 = [ attributes, text ])[0], attributes = ref3[1]), 
            null != name && (name = getValue(name)), Array.isArray(name)) for (j = 0, len = name.length; j < len; j++) item = name[j], 
            lastChild = this.element(item); else if (isFunction(name)) lastChild = this.element(name.apply()); else if (isObject(name)) {
                for (key in name) if (hasProp.call(name, key)) if (val = name[key], isFunction(val) && (val = val.apply()), 
                !this.options.ignoreDecorators && this.stringify.convertAttKey && 0 === key.indexOf(this.stringify.convertAttKey)) lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val); else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) lastChild = this.dummy(); else if (isObject(val) && isEmpty(val)) lastChild = this.element(key); else if (this.options.keepNullNodes || null != val) if (!this.options.separateArrayItems && Array.isArray(val)) for (k = 0, 
                len1 = val.length; k < len1; k++) item = val[k], (childNode = {})[key] = item, lastChild = this.element(childNode); else isObject(val) ? !this.options.ignoreDecorators && this.stringify.convertTextKey && 0 === key.indexOf(this.stringify.convertTextKey) ? lastChild = this.element(val) : (lastChild = this.element(key)).element(val) : lastChild = this.element(key, val); else lastChild = this.dummy();
            } else lastChild = this.options.keepNullNodes || null !== text ? !this.options.ignoreDecorators && this.stringify.convertTextKey && 0 === name.indexOf(this.stringify.convertTextKey) ? this.text(text) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && 0 === name.indexOf(this.stringify.convertCDataKey) ? this.cdata(text) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && 0 === name.indexOf(this.stringify.convertCommentKey) ? this.comment(text) : !this.options.ignoreDecorators && this.stringify.convertRawKey && 0 === name.indexOf(this.stringify.convertRawKey) ? this.raw(text) : !this.options.ignoreDecorators && this.stringify.convertPIKey && 0 === name.indexOf(this.stringify.convertPIKey) ? this.instruction(name.substr(this.stringify.convertPIKey.length), text) : this.node(name, attributes, text) : this.dummy();
            if (null == lastChild) throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
            return lastChild;
        }, XMLNode.prototype.insertBefore = function(name, attributes, text) {
            var child, i, newChild, refChild, removed;
            if (null != name ? name.type : void 0) return refChild = attributes, (newChild = name).setParent(this), 
            refChild ? (i = children.indexOf(refChild), removed = children.splice(i), children.push(newChild), 
            Array.prototype.push.apply(children, removed)) : children.push(newChild), newChild;
            if (this.isRoot) throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
            return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i), 
            child = this.parent.element(name, attributes, text), Array.prototype.push.apply(this.parent.children, removed), 
            child;
        }, XMLNode.prototype.insertAfter = function(name, attributes, text) {
            var child, i, removed;
            if (this.isRoot) throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
            return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i + 1), 
            child = this.parent.element(name, attributes, text), Array.prototype.push.apply(this.parent.children, removed), 
            child;
        }, XMLNode.prototype.remove = function() {
            var i;
            if (this.isRoot) throw new Error("Cannot remove the root element. " + this.debugInfo());
            return i = this.parent.children.indexOf(this), [].splice.apply(this.parent.children, [ i, i - i + 1 ].concat([])), 
            this.parent;
        }, XMLNode.prototype.node = function(name, attributes, text) {
            var child, ref2;
            return null != name && (name = getValue(name)), attributes || (attributes = {}), 
            attributes = getValue(attributes), isObject(attributes) || (text = (ref2 = [ attributes, text ])[0], 
            attributes = ref2[1]), child = new XMLElement$1(this, name, attributes), null != text && child.text(text), 
            this.children.push(child), child;
        }, XMLNode.prototype.text = function(value) {
            var child;
            return isObject(value) && this.element(value), child = new XMLText$1(this, value), 
            this.children.push(child), this;
        }, XMLNode.prototype.cdata = function(value) {
            var child;
            return child = new XMLCData$1(this, value), this.children.push(child), this;
        }, XMLNode.prototype.comment = function(value) {
            var child;
            return child = new XMLComment$1(this, value), this.children.push(child), this;
        }, XMLNode.prototype.commentBefore = function(value) {
            var i, removed;
            return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i), 
            this.parent.comment(value), Array.prototype.push.apply(this.parent.children, removed), 
            this;
        }, XMLNode.prototype.commentAfter = function(value) {
            var i, removed;
            return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i + 1), 
            this.parent.comment(value), Array.prototype.push.apply(this.parent.children, removed), 
            this;
        }, XMLNode.prototype.raw = function(value) {
            var child;
            return child = new XMLRaw$1(this, value), this.children.push(child), this;
        }, XMLNode.prototype.dummy = function() {
            return new XMLDummy$1(this);
        }, XMLNode.prototype.instruction = function(target, value) {
            var insTarget, insValue, instruction, j, len;
            if (null != target && (target = getValue(target)), null != value && (value = getValue(value)), 
            Array.isArray(target)) for (j = 0, len = target.length; j < len; j++) insTarget = target[j], 
            this.instruction(insTarget); else if (isObject(target)) for (insTarget in target) hasProp.call(target, insTarget) && (insValue = target[insTarget], 
            this.instruction(insTarget, insValue)); else isFunction(value) && (value = value.apply()), 
            instruction = new XMLProcessingInstruction$1(this, target, value), this.children.push(instruction);
            return this;
        }, XMLNode.prototype.instructionBefore = function(target, value) {
            var i, removed;
            return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i), 
            this.parent.instruction(target, value), Array.prototype.push.apply(this.parent.children, removed), 
            this;
        }, XMLNode.prototype.instructionAfter = function(target, value) {
            var i, removed;
            return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i + 1), 
            this.parent.instruction(target, value), Array.prototype.push.apply(this.parent.children, removed), 
            this;
        }, XMLNode.prototype.declaration = function(version, encoding, standalone) {
            var doc, xmldec;
            return doc = this.document(), xmldec = new XMLDeclaration$1(doc, version, encoding, standalone), 
            0 === doc.children.length ? doc.children.unshift(xmldec) : doc.children[0].type === NodeType$1.Declaration ? doc.children[0] = xmldec : doc.children.unshift(xmldec), 
            doc.root() || doc;
        }, XMLNode.prototype.dtd = function(pubID, sysID) {
            var doc, doctype, i, j, k, len, len1, ref2, ref3;
            for (doc = this.document(), doctype = new XMLDocType$1(doc, pubID, sysID), i = j = 0, 
            len = (ref2 = doc.children).length; j < len; i = ++j) if (ref2[i].type === NodeType$1.DocType) return doc.children[i] = doctype, 
            doctype;
            for (i = k = 0, len1 = (ref3 = doc.children).length; k < len1; i = ++k) if (ref3[i].isRoot) return doc.children.splice(i, 0, doctype), 
            doctype;
            return doc.children.push(doctype), doctype;
        }, XMLNode.prototype.up = function() {
            if (this.isRoot) throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
            return this.parent;
        }, XMLNode.prototype.root = function() {
            var node;
            for (node = this; node; ) {
                if (node.type === NodeType$1.Document) return node.rootObject;
                if (node.isRoot) return node;
                node = node.parent;
            }
        }, XMLNode.prototype.document = function() {
            var node;
            for (node = this; node; ) {
                if (node.type === NodeType$1.Document) return node;
                node = node.parent;
            }
        }, XMLNode.prototype.end = function(options) {
            return this.document().end(options);
        }, XMLNode.prototype.prev = function() {
            var i;
            if ((i = this.parent.children.indexOf(this)) < 1) throw new Error("Already at the first node. " + this.debugInfo());
            return this.parent.children[i - 1];
        }, XMLNode.prototype.next = function() {
            var i;
            if (-1 === (i = this.parent.children.indexOf(this)) || i === this.parent.children.length - 1) throw new Error("Already at the last node. " + this.debugInfo());
            return this.parent.children[i + 1];
        }, XMLNode.prototype.importDocument = function(doc) {
            var clonedRoot;
            return (clonedRoot = doc.root().clone()).parent = this, clonedRoot.isRoot = !1, 
            this.children.push(clonedRoot), this;
        }, XMLNode.prototype.debugInfo = function(name) {
            var ref2, ref3;
            return null != (name = name || this.name) || (null != (ref2 = this.parent) ? ref2.name : void 0) ? null == name ? "parent: <" + this.parent.name + ">" : (null != (ref3 = this.parent) ? ref3.name : void 0) ? "node: <" + name + ">, parent: <" + this.parent.name + ">" : "node: <" + name + ">" : "";
        }, XMLNode.prototype.ele = function(name, attributes, text) {
            return this.element(name, attributes, text);
        }, XMLNode.prototype.nod = function(name, attributes, text) {
            return this.node(name, attributes, text);
        }, XMLNode.prototype.txt = function(value) {
            return this.text(value);
        }, XMLNode.prototype.dat = function(value) {
            return this.cdata(value);
        }, XMLNode.prototype.com = function(value) {
            return this.comment(value);
        }, XMLNode.prototype.ins = function(target, value) {
            return this.instruction(target, value);
        }, XMLNode.prototype.doc = function() {
            return this.document();
        }, XMLNode.prototype.dec = function(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
        }, XMLNode.prototype.e = function(name, attributes, text) {
            return this.element(name, attributes, text);
        }, XMLNode.prototype.n = function(name, attributes, text) {
            return this.node(name, attributes, text);
        }, XMLNode.prototype.t = function(value) {
            return this.text(value);
        }, XMLNode.prototype.d = function(value) {
            return this.cdata(value);
        }, XMLNode.prototype.c = function(value) {
            return this.comment(value);
        }, XMLNode.prototype.r = function(value) {
            return this.raw(value);
        }, XMLNode.prototype.i = function(target, value) {
            return this.instruction(target, value);
        }, XMLNode.prototype.u = function() {
            return this.up();
        }, XMLNode.prototype.importXMLBuilder = function(doc) {
            return this.importDocument(doc);
        }, XMLNode.prototype.replaceChild = function(newChild, oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLNode.prototype.removeChild = function(oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLNode.prototype.appendChild = function(newChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLNode.prototype.hasChildNodes = function() {
            return 0 !== this.children.length;
        }, XMLNode.prototype.cloneNode = function(deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLNode.prototype.normalize = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLNode.prototype.isSupported = function(feature, version) {
            return !0;
        }, XMLNode.prototype.hasAttributes = function() {
            return 0 !== this.attribs.length;
        }, XMLNode.prototype.compareDocumentPosition = function(other) {
            var res;
            return this === other ? 0 : this.document() !== other.document() ? (res = DocumentPosition$1.Disconnected | DocumentPosition$1.ImplementationSpecific, 
            Math.random() < 0.5 ? res |= DocumentPosition$1.Preceding : res |= DocumentPosition$1.Following, 
            res) : this.isAncestor(other) ? DocumentPosition$1.Contains | DocumentPosition$1.Preceding : this.isDescendant(other) ? DocumentPosition$1.Contains | DocumentPosition$1.Following : this.isPreceding(other) ? DocumentPosition$1.Preceding : DocumentPosition$1.Following;
        }, XMLNode.prototype.isSameNode = function(other) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLNode.prototype.lookupPrefix = function(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLNode.prototype.lookupNamespaceURI = function(prefix) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLNode.prototype.isEqualNode = function(node) {
            var i, j, ref2;
            if (node.nodeType !== this.nodeType) return !1;
            if (node.children.length !== this.children.length) return !1;
            for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) if (!this.children[i].isEqualNode(node.children[i])) return !1;
            return !0;
        }, XMLNode.prototype.getFeature = function(feature, version) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLNode.prototype.setUserData = function(key, data, handler) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLNode.prototype.getUserData = function(key) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLNode.prototype.contains = function(other) {
            return !!other && (other === this || this.isDescendant(other));
        }, XMLNode.prototype.isDescendant = function(node) {
            var child, j, len, ref2;
            for (j = 0, len = (ref2 = this.children).length; j < len; j++) {
                if (node === (child = ref2[j])) return !0;
                if (child.isDescendant(node)) return !0;
            }
            return !1;
        }, XMLNode.prototype.isAncestor = function(node) {
            return node.isDescendant(this);
        }, XMLNode.prototype.isPreceding = function(node) {
            var nodePos, thisPos;
            return nodePos = this.treePosition(node), thisPos = this.treePosition(this), -1 !== nodePos && -1 !== thisPos && nodePos < thisPos;
        }, XMLNode.prototype.isFollowing = function(node) {
            var nodePos, thisPos;
            return nodePos = this.treePosition(node), thisPos = this.treePosition(this), -1 !== nodePos && -1 !== thisPos && nodePos > thisPos;
        }, XMLNode.prototype.treePosition = function(node) {
            var found, pos;
            return pos = 0, found = !1, this.foreachTreeNode(this.document(), (function(childNode) {
                if (pos++, !found && childNode === node) return found = !0;
            })), found ? pos : -1;
        }, XMLNode.prototype.foreachTreeNode = function(node, func) {
            var child, j, len, ref2, res;
            for (node || (node = this.document()), j = 0, len = (ref2 = node.children).length; j < len; j++) {
                if (res = func(child = ref2[j])) return res;
                if (res = this.foreachTreeNode(child, func)) return res;
            }
        }, XMLNode;
    }();
}.call(commonjsGlobal);

var XMLStringifier = {
    exports: {}
};

(function() {
    var bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    }, hasProp = {}.hasOwnProperty;
    XMLStringifier.exports = function() {
        function XMLStringifier(options) {
            var key, ref, value;
            for (key in this.assertLegalName = bind(this.assertLegalName, this), this.assertLegalChar = bind(this.assertLegalChar, this), 
            options || (options = {}), this.options = options, this.options.version || (this.options.version = "1.0"), 
            ref = options.stringify || {}) hasProp.call(ref, key) && (value = ref[key], this[key] = value);
        }
        return XMLStringifier.prototype.name = function(val) {
            return this.options.noValidation ? val : this.assertLegalName("" + val || "");
        }, XMLStringifier.prototype.text = function(val) {
            return this.options.noValidation ? val : this.assertLegalChar(this.textEscape("" + val || ""));
        }, XMLStringifier.prototype.cdata = function(val) {
            return this.options.noValidation ? val : (val = (val = "" + val || "").replace("]]>", "]]]]><![CDATA[>"), 
            this.assertLegalChar(val));
        }, XMLStringifier.prototype.comment = function(val) {
            if (this.options.noValidation) return val;
            if ((val = "" + val || "").match(/--/)) throw new Error("Comment text cannot contain double-hypen: " + val);
            return this.assertLegalChar(val);
        }, XMLStringifier.prototype.raw = function(val) {
            return this.options.noValidation ? val : "" + val || "";
        }, XMLStringifier.prototype.attValue = function(val) {
            return this.options.noValidation ? val : this.assertLegalChar(this.attEscape(val = "" + val || ""));
        }, XMLStringifier.prototype.insTarget = function(val) {
            return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
        }, XMLStringifier.prototype.insValue = function(val) {
            if (this.options.noValidation) return val;
            if ((val = "" + val || "").match(/\?>/)) throw new Error("Invalid processing instruction value: " + val);
            return this.assertLegalChar(val);
        }, XMLStringifier.prototype.xmlVersion = function(val) {
            if (this.options.noValidation) return val;
            if (!(val = "" + val || "").match(/1\.[0-9]+/)) throw new Error("Invalid version number: " + val);
            return val;
        }, XMLStringifier.prototype.xmlEncoding = function(val) {
            if (this.options.noValidation) return val;
            if (!(val = "" + val || "").match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) throw new Error("Invalid encoding: " + val);
            return this.assertLegalChar(val);
        }, XMLStringifier.prototype.xmlStandalone = function(val) {
            return this.options.noValidation ? val : val ? "yes" : "no";
        }, XMLStringifier.prototype.dtdPubID = function(val) {
            return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
        }, XMLStringifier.prototype.dtdSysID = function(val) {
            return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
        }, XMLStringifier.prototype.dtdElementValue = function(val) {
            return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
        }, XMLStringifier.prototype.dtdAttType = function(val) {
            return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
        }, XMLStringifier.prototype.dtdAttDefault = function(val) {
            return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
        }, XMLStringifier.prototype.dtdEntityValue = function(val) {
            return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
        }, XMLStringifier.prototype.dtdNData = function(val) {
            return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
        }, XMLStringifier.prototype.convertAttKey = "@", XMLStringifier.prototype.convertPIKey = "?", 
        XMLStringifier.prototype.convertTextKey = "#text", XMLStringifier.prototype.convertCDataKey = "#cdata", 
        XMLStringifier.prototype.convertCommentKey = "#comment", XMLStringifier.prototype.convertRawKey = "#raw", 
        XMLStringifier.prototype.assertLegalChar = function(str) {
            var regex, res;
            if (this.options.noValidation) return str;
            if (regex = "", "1.0" === this.options.version) {
                if (regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, 
                res = str.match(regex)) throw new Error("Invalid character in string: " + str + " at index " + res.index);
            } else if ("1.1" === this.options.version && (regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, 
            res = str.match(regex))) throw new Error("Invalid character in string: " + str + " at index " + res.index);
            return str;
        }, XMLStringifier.prototype.assertLegalName = function(str) {
            var regex;
            if (this.options.noValidation) return str;
            if (this.assertLegalChar(str), regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/, 
            !str.match(regex)) throw new Error("Invalid character in name");
            return str;
        }, XMLStringifier.prototype.textEscape = function(str) {
            var ampregex;
            return this.options.noValidation ? str : (ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, 
            str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;"));
        }, XMLStringifier.prototype.attEscape = function(str) {
            var ampregex;
            return this.options.noValidation ? str : (ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, 
            str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;"));
        }, XMLStringifier;
    }();
}).call(commonjsGlobal);

var XMLStringWriter = {
    exports: {}
}, XMLWriterBase = {
    exports: {}
}, WriterState = {
    exports: {}
};

(function() {
    WriterState.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3
    };
}).call(commonjsGlobal), function() {
    var NodeType$1, WriterState$1, assign, hasProp = {}.hasOwnProperty;
    assign = Utility.assign, NodeType$1 = NodeType.exports, WriterState$1 = WriterState.exports, 
    XMLWriterBase.exports = function() {
        function XMLWriterBase(options) {
            var key, ref, value;
            for (key in options || (options = {}), this.options = options, ref = options.writer || {}) hasProp.call(ref, key) && (value = ref[key], 
            this["_" + key] = this[key], this[key] = value);
        }
        return XMLWriterBase.prototype.filterOptions = function(options) {
            var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
            return options || (options = {}), options = assign({}, this.options, options), (filteredOptions = {
                writer: this
            }).pretty = options.pretty || !1, filteredOptions.allowEmpty = options.allowEmpty || !1, 
            filteredOptions.indent = null != (ref = options.indent) ? ref : "  ", filteredOptions.newline = null != (ref1 = options.newline) ? ref1 : "\n", 
            filteredOptions.offset = null != (ref2 = options.offset) ? ref2 : 0, filteredOptions.dontPrettyTextNodes = null != (ref3 = null != (ref4 = options.dontPrettyTextNodes) ? ref4 : options.dontprettytextnodes) ? ref3 : 0, 
            filteredOptions.spaceBeforeSlash = null != (ref5 = null != (ref6 = options.spaceBeforeSlash) ? ref6 : options.spacebeforeslash) ? ref5 : "", 
            !0 === filteredOptions.spaceBeforeSlash && (filteredOptions.spaceBeforeSlash = " "), 
            filteredOptions.suppressPrettyCount = 0, filteredOptions.user = {}, filteredOptions.state = WriterState$1.None, 
            filteredOptions;
        }, XMLWriterBase.prototype.indent = function(node, options, level) {
            var indentLevel;
            return !options.pretty || options.suppressPrettyCount ? "" : options.pretty && (indentLevel = (level || 0) + options.offset + 1) > 0 ? new Array(indentLevel).join(options.indent) : "";
        }, XMLWriterBase.prototype.endline = function(node, options, level) {
            return !options.pretty || options.suppressPrettyCount ? "" : options.newline;
        }, XMLWriterBase.prototype.attribute = function(att, options, level) {
            var r;
            return this.openAttribute(att, options, level), r = " " + att.name + '="' + att.value + '"', 
            this.closeAttribute(att, options, level), r;
        }, XMLWriterBase.prototype.cdata = function(node, options, level) {
            var r;
            return this.openNode(node, options, level), options.state = WriterState$1.OpenTag, 
            r = this.indent(node, options, level) + "<![CDATA[", options.state = WriterState$1.InsideTag, 
            r += node.value, options.state = WriterState$1.CloseTag, r += "]]>" + this.endline(node, options, level), 
            options.state = WriterState$1.None, this.closeNode(node, options, level), r;
        }, XMLWriterBase.prototype.comment = function(node, options, level) {
            var r;
            return this.openNode(node, options, level), options.state = WriterState$1.OpenTag, 
            r = this.indent(node, options, level) + "\x3c!-- ", options.state = WriterState$1.InsideTag, 
            r += node.value, options.state = WriterState$1.CloseTag, r += " --\x3e" + this.endline(node, options, level), 
            options.state = WriterState$1.None, this.closeNode(node, options, level), r;
        }, XMLWriterBase.prototype.declaration = function(node, options, level) {
            var r;
            return this.openNode(node, options, level), options.state = WriterState$1.OpenTag, 
            r = this.indent(node, options, level) + "<?xml", options.state = WriterState$1.InsideTag, 
            r += ' version="' + node.version + '"', null != node.encoding && (r += ' encoding="' + node.encoding + '"'), 
            null != node.standalone && (r += ' standalone="' + node.standalone + '"'), options.state = WriterState$1.CloseTag, 
            r += options.spaceBeforeSlash + "?>", r += this.endline(node, options, level), options.state = WriterState$1.None, 
            this.closeNode(node, options, level), r;
        }, XMLWriterBase.prototype.docType = function(node, options, level) {
            var child, i, len, r, ref;
            if (level || (level = 0), this.openNode(node, options, level), options.state = WriterState$1.OpenTag, 
            r = this.indent(node, options, level), r += "<!DOCTYPE " + node.root().name, node.pubID && node.sysID ? r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"' : node.sysID && (r += ' SYSTEM "' + node.sysID + '"'), 
            node.children.length > 0) {
                for (r += " [", r += this.endline(node, options, level), options.state = WriterState$1.InsideTag, 
                i = 0, len = (ref = node.children).length; i < len; i++) child = ref[i], r += this.writeChildNode(child, options, level + 1);
                options.state = WriterState$1.CloseTag, r += "]";
            }
            return options.state = WriterState$1.CloseTag, r += options.spaceBeforeSlash + ">", 
            r += this.endline(node, options, level), options.state = WriterState$1.None, this.closeNode(node, options, level), 
            r;
        }, XMLWriterBase.prototype.element = function(node, options, level) {
            var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
            for (name in level || (level = 0), prettySuppressed = !1, r = "", this.openNode(node, options, level), 
            options.state = WriterState$1.OpenTag, r += this.indent(node, options, level) + "<" + node.name, 
            ref = node.attribs) hasProp.call(ref, name) && (att = ref[name], r += this.attribute(att, options, level));
            if (firstChildNode = 0 === (childNodeCount = node.children.length) ? null : node.children[0], 
            0 === childNodeCount || node.children.every((function(e) {
                return (e.type === NodeType$1.Text || e.type === NodeType$1.Raw) && "" === e.value;
            }))) options.allowEmpty ? (r += ">", options.state = WriterState$1.CloseTag, r += "</" + node.name + ">" + this.endline(node, options, level)) : (options.state = WriterState$1.CloseTag, 
            r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level)); else if (!options.pretty || 1 !== childNodeCount || firstChildNode.type !== NodeType$1.Text && firstChildNode.type !== NodeType$1.Raw || null == firstChildNode.value) {
                if (options.dontPrettyTextNodes) for (i = 0, len = (ref1 = node.children).length; i < len; i++) if (((child = ref1[i]).type === NodeType$1.Text || child.type === NodeType$1.Raw) && null != child.value) {
                    options.suppressPrettyCount++, prettySuppressed = !0;
                    break;
                }
                for (r += ">" + this.endline(node, options, level), options.state = WriterState$1.InsideTag, 
                j = 0, len1 = (ref2 = node.children).length; j < len1; j++) child = ref2[j], r += this.writeChildNode(child, options, level + 1);
                options.state = WriterState$1.CloseTag, r += this.indent(node, options, level) + "</" + node.name + ">", 
                prettySuppressed && options.suppressPrettyCount--, r += this.endline(node, options, level), 
                options.state = WriterState$1.None;
            } else r += ">", options.state = WriterState$1.InsideTag, options.suppressPrettyCount++, 
            prettySuppressed = !0, r += this.writeChildNode(firstChildNode, options, level + 1), 
            options.suppressPrettyCount--, prettySuppressed = !1, options.state = WriterState$1.CloseTag, 
            r += "</" + node.name + ">" + this.endline(node, options, level);
            return this.closeNode(node, options, level), r;
        }, XMLWriterBase.prototype.writeChildNode = function(node, options, level) {
            switch (node.type) {
              case NodeType$1.CData:
                return this.cdata(node, options, level);

              case NodeType$1.Comment:
                return this.comment(node, options, level);

              case NodeType$1.Element:
                return this.element(node, options, level);

              case NodeType$1.Raw:
                return this.raw(node, options, level);

              case NodeType$1.Text:
                return this.text(node, options, level);

              case NodeType$1.ProcessingInstruction:
                return this.processingInstruction(node, options, level);

              case NodeType$1.Dummy:
                return "";

              case NodeType$1.Declaration:
                return this.declaration(node, options, level);

              case NodeType$1.DocType:
                return this.docType(node, options, level);

              case NodeType$1.AttributeDeclaration:
                return this.dtdAttList(node, options, level);

              case NodeType$1.ElementDeclaration:
                return this.dtdElement(node, options, level);

              case NodeType$1.EntityDeclaration:
                return this.dtdEntity(node, options, level);

              case NodeType$1.NotationDeclaration:
                return this.dtdNotation(node, options, level);

              default:
                throw new Error("Unknown XML node type: " + node.constructor.name);
            }
        }, XMLWriterBase.prototype.processingInstruction = function(node, options, level) {
            var r;
            return this.openNode(node, options, level), options.state = WriterState$1.OpenTag, 
            r = this.indent(node, options, level) + "<?", options.state = WriterState$1.InsideTag, 
            r += node.target, node.value && (r += " " + node.value), options.state = WriterState$1.CloseTag, 
            r += options.spaceBeforeSlash + "?>", r += this.endline(node, options, level), options.state = WriterState$1.None, 
            this.closeNode(node, options, level), r;
        }, XMLWriterBase.prototype.raw = function(node, options, level) {
            var r;
            return this.openNode(node, options, level), options.state = WriterState$1.OpenTag, 
            r = this.indent(node, options, level), options.state = WriterState$1.InsideTag, 
            r += node.value, options.state = WriterState$1.CloseTag, r += this.endline(node, options, level), 
            options.state = WriterState$1.None, this.closeNode(node, options, level), r;
        }, XMLWriterBase.prototype.text = function(node, options, level) {
            var r;
            return this.openNode(node, options, level), options.state = WriterState$1.OpenTag, 
            r = this.indent(node, options, level), options.state = WriterState$1.InsideTag, 
            r += node.value, options.state = WriterState$1.CloseTag, r += this.endline(node, options, level), 
            options.state = WriterState$1.None, this.closeNode(node, options, level), r;
        }, XMLWriterBase.prototype.dtdAttList = function(node, options, level) {
            var r;
            return this.openNode(node, options, level), options.state = WriterState$1.OpenTag, 
            r = this.indent(node, options, level) + "<!ATTLIST", options.state = WriterState$1.InsideTag, 
            r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType, 
            "#DEFAULT" !== node.defaultValueType && (r += " " + node.defaultValueType), node.defaultValue && (r += ' "' + node.defaultValue + '"'), 
            options.state = WriterState$1.CloseTag, r += options.spaceBeforeSlash + ">" + this.endline(node, options, level), 
            options.state = WriterState$1.None, this.closeNode(node, options, level), r;
        }, XMLWriterBase.prototype.dtdElement = function(node, options, level) {
            var r;
            return this.openNode(node, options, level), options.state = WriterState$1.OpenTag, 
            r = this.indent(node, options, level) + "<!ELEMENT", options.state = WriterState$1.InsideTag, 
            r += " " + node.name + " " + node.value, options.state = WriterState$1.CloseTag, 
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level), options.state = WriterState$1.None, 
            this.closeNode(node, options, level), r;
        }, XMLWriterBase.prototype.dtdEntity = function(node, options, level) {
            var r;
            return this.openNode(node, options, level), options.state = WriterState$1.OpenTag, 
            r = this.indent(node, options, level) + "<!ENTITY", options.state = WriterState$1.InsideTag, 
            node.pe && (r += " %"), r += " " + node.name, node.value ? r += ' "' + node.value + '"' : (node.pubID && node.sysID ? r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"' : node.sysID && (r += ' SYSTEM "' + node.sysID + '"'), 
            node.nData && (r += " NDATA " + node.nData)), options.state = WriterState$1.CloseTag, 
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level), options.state = WriterState$1.None, 
            this.closeNode(node, options, level), r;
        }, XMLWriterBase.prototype.dtdNotation = function(node, options, level) {
            var r;
            return this.openNode(node, options, level), options.state = WriterState$1.OpenTag, 
            r = this.indent(node, options, level) + "<!NOTATION", options.state = WriterState$1.InsideTag, 
            r += " " + node.name, node.pubID && node.sysID ? r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"' : node.pubID ? r += ' PUBLIC "' + node.pubID + '"' : node.sysID && (r += ' SYSTEM "' + node.sysID + '"'), 
            options.state = WriterState$1.CloseTag, r += options.spaceBeforeSlash + ">" + this.endline(node, options, level), 
            options.state = WriterState$1.None, this.closeNode(node, options, level), r;
        }, XMLWriterBase.prototype.openNode = function(node, options, level) {}, XMLWriterBase.prototype.closeNode = function(node, options, level) {}, 
        XMLWriterBase.prototype.openAttribute = function(att, options, level) {}, XMLWriterBase.prototype.closeAttribute = function(att, options, level) {}, 
        XMLWriterBase;
    }();
}.call(commonjsGlobal), function() {
    var XMLWriterBase$1, hasProp = {}.hasOwnProperty;
    XMLWriterBase$1 = XMLWriterBase.exports, XMLStringWriter.exports = function(superClass) {
        function XMLStringWriter(options) {
            XMLStringWriter.__super__.constructor.call(this, options);
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLStringWriter, superClass), XMLStringWriter.prototype.document = function(doc, options) {
            var child, i, len, r, ref;
            for (options = this.filterOptions(options), r = "", i = 0, len = (ref = doc.children).length; i < len; i++) child = ref[i], 
            r += this.writeChildNode(child, options, 0);
            return options.pretty && r.slice(-options.newline.length) === options.newline && (r = r.slice(0, -options.newline.length)), 
            r;
        }, XMLStringWriter;
    }(XMLWriterBase$1);
}.call(commonjsGlobal), function() {
    var NodeType$1, XMLDOMConfiguration$1, XMLDOMImplementation$1, XMLNode$1, XMLStringWriter$1, XMLStringifier$1, isPlainObject, hasProp = {}.hasOwnProperty;
    isPlainObject = Utility.isPlainObject, XMLDOMImplementation$1 = XMLDOMImplementation.exports, 
    XMLDOMConfiguration$1 = XMLDOMConfiguration.exports, XMLNode$1 = XMLNode.exports, 
    NodeType$1 = NodeType.exports, XMLStringifier$1 = XMLStringifier.exports, XMLStringWriter$1 = XMLStringWriter.exports, 
    XMLDocument.exports = function(superClass) {
        function XMLDocument(options) {
            XMLDocument.__super__.constructor.call(this, null), this.name = "#document", this.type = NodeType$1.Document, 
            this.documentURI = null, this.domConfig = new XMLDOMConfiguration$1, options || (options = {}), 
            options.writer || (options.writer = new XMLStringWriter$1), this.options = options, 
            this.stringify = new XMLStringifier$1(options);
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLDocument, superClass), Object.defineProperty(XMLDocument.prototype, "implementation", {
            value: new XMLDOMImplementation$1
        }), Object.defineProperty(XMLDocument.prototype, "doctype", {
            get: function() {
                var child, i, len, ref;
                for (i = 0, len = (ref = this.children).length; i < len; i++) if ((child = ref[i]).type === NodeType$1.DocType) return child;
                return null;
            }
        }), Object.defineProperty(XMLDocument.prototype, "documentElement", {
            get: function() {
                return this.rootObject || null;
            }
        }), Object.defineProperty(XMLDocument.prototype, "inputEncoding", {
            get: function() {
                return null;
            }
        }), Object.defineProperty(XMLDocument.prototype, "strictErrorChecking", {
            get: function() {
                return !1;
            }
        }), Object.defineProperty(XMLDocument.prototype, "xmlEncoding", {
            get: function() {
                return 0 !== this.children.length && this.children[0].type === NodeType$1.Declaration ? this.children[0].encoding : null;
            }
        }), Object.defineProperty(XMLDocument.prototype, "xmlStandalone", {
            get: function() {
                return 0 !== this.children.length && this.children[0].type === NodeType$1.Declaration && "yes" === this.children[0].standalone;
            }
        }), Object.defineProperty(XMLDocument.prototype, "xmlVersion", {
            get: function() {
                return 0 !== this.children.length && this.children[0].type === NodeType$1.Declaration ? this.children[0].version : "1.0";
            }
        }), Object.defineProperty(XMLDocument.prototype, "URL", {
            get: function() {
                return this.documentURI;
            }
        }), Object.defineProperty(XMLDocument.prototype, "origin", {
            get: function() {
                return null;
            }
        }), Object.defineProperty(XMLDocument.prototype, "compatMode", {
            get: function() {
                return null;
            }
        }), Object.defineProperty(XMLDocument.prototype, "characterSet", {
            get: function() {
                return null;
            }
        }), Object.defineProperty(XMLDocument.prototype, "contentType", {
            get: function() {
                return null;
            }
        }), XMLDocument.prototype.end = function(writer) {
            var writerOptions;
            return writerOptions = {}, writer ? isPlainObject(writer) && (writerOptions = writer, 
            writer = this.options.writer) : writer = this.options.writer, writer.document(this, writer.filterOptions(writerOptions));
        }, XMLDocument.prototype.toString = function(options) {
            return this.options.writer.document(this, this.options.writer.filterOptions(options));
        }, XMLDocument.prototype.createElement = function(tagName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.createDocumentFragment = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.createTextNode = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.createComment = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.createCDATASection = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.createProcessingInstruction = function(target, data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.createAttribute = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.createEntityReference = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.getElementsByTagName = function(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.importNode = function(importedNode, deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.getElementById = function(elementId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.adoptNode = function(source) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.normalizeDocument = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.getElementsByClassName = function(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.createEvent = function(eventInterface) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.createRange = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, XMLDocument;
    }(XMLNode$1);
}.call(commonjsGlobal);

var XMLDocumentCB = {
    exports: {}
};

(function() {
    var NodeType$1, WriterState$1, XMLAttribute$1, XMLCData$1, XMLComment$1, XMLDTDAttList$1, XMLDTDElement$1, XMLDTDEntity$1, XMLDTDNotation$1, XMLDeclaration$1, XMLDocType$1, XMLDocument$1, XMLElement$1, XMLProcessingInstruction$1, XMLRaw$1, XMLStringWriter$1, XMLStringifier$1, XMLText$1, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
    isObject = (ref = Utility).isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, 
    getValue = ref.getValue, NodeType$1 = NodeType.exports, XMLDocument$1 = XMLDocument.exports, 
    XMLElement$1 = XMLElement.exports, XMLCData$1 = XMLCData.exports, XMLComment$1 = XMLComment.exports, 
    XMLRaw$1 = XMLRaw.exports, XMLText$1 = XMLText.exports, XMLProcessingInstruction$1 = XMLProcessingInstruction.exports, 
    XMLDeclaration$1 = XMLDeclaration.exports, XMLDocType$1 = XMLDocType.exports, XMLDTDAttList$1 = XMLDTDAttList.exports, 
    XMLDTDEntity$1 = XMLDTDEntity.exports, XMLDTDElement$1 = XMLDTDElement.exports, 
    XMLDTDNotation$1 = XMLDTDNotation.exports, XMLAttribute$1 = XMLAttribute.exports, 
    XMLStringifier$1 = XMLStringifier.exports, XMLStringWriter$1 = XMLStringWriter.exports, 
    WriterState$1 = WriterState.exports, XMLDocumentCB.exports = function() {
        function XMLDocumentCB(options, onData, onEnd) {
            var writerOptions;
            this.name = "?xml", this.type = NodeType$1.Document, options || (options = {}), 
            writerOptions = {}, options.writer ? isPlainObject(options.writer) && (writerOptions = options.writer, 
            options.writer = new XMLStringWriter$1) : options.writer = new XMLStringWriter$1, 
            this.options = options, this.writer = options.writer, this.writerOptions = this.writer.filterOptions(writerOptions), 
            this.stringify = new XMLStringifier$1(options), this.onDataCallback = onData || function() {}, 
            this.onEndCallback = onEnd || function() {}, this.currentNode = null, this.currentLevel = -1, 
            this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null;
        }
        return XMLDocumentCB.prototype.createChildNode = function(node) {
            var att, attName, attributes, child, i, len, ref1, ref2;
            switch (node.type) {
              case NodeType$1.CData:
                this.cdata(node.value);
                break;

              case NodeType$1.Comment:
                this.comment(node.value);
                break;

              case NodeType$1.Element:
                for (attName in attributes = {}, ref1 = node.attribs) hasProp.call(ref1, attName) && (att = ref1[attName], 
                attributes[attName] = att.value);
                this.node(node.name, attributes);
                break;

              case NodeType$1.Dummy:
                this.dummy();
                break;

              case NodeType$1.Raw:
                this.raw(node.value);
                break;

              case NodeType$1.Text:
                this.text(node.value);
                break;

              case NodeType$1.ProcessingInstruction:
                this.instruction(node.target, node.value);
                break;

              default:
                throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
            }
            for (i = 0, len = (ref2 = node.children).length; i < len; i++) child = ref2[i], 
            this.createChildNode(child), child.type === NodeType$1.Element && this.up();
            return this;
        }, XMLDocumentCB.prototype.dummy = function() {
            return this;
        }, XMLDocumentCB.prototype.node = function(name, attributes, text) {
            var ref1;
            if (null == name) throw new Error("Missing node name.");
            if (this.root && -1 === this.currentLevel) throw new Error("Document can only have one root node. " + this.debugInfo(name));
            return this.openCurrent(), name = getValue(name), null == attributes && (attributes = {}), 
            attributes = getValue(attributes), isObject(attributes) || (text = (ref1 = [ attributes, text ])[0], 
            attributes = ref1[1]), this.currentNode = new XMLElement$1(this, name, attributes), 
            this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, 
            null != text && this.text(text), this;
        }, XMLDocumentCB.prototype.element = function(name, attributes, text) {
            var child, i, len, oldValidationFlag, ref1, root;
            if (this.currentNode && this.currentNode.type === NodeType$1.DocType) this.dtdElement.apply(this, arguments); else if (Array.isArray(name) || isObject(name) || isFunction(name)) for (oldValidationFlag = this.options.noValidation, 
            this.options.noValidation = !0, (root = new XMLDocument$1(this.options).element("TEMP_ROOT")).element(name), 
            this.options.noValidation = oldValidationFlag, i = 0, len = (ref1 = root.children).length; i < len; i++) child = ref1[i], 
            this.createChildNode(child), child.type === NodeType$1.Element && this.up(); else this.node(name, attributes, text);
            return this;
        }, XMLDocumentCB.prototype.attribute = function(name, value) {
            var attName, attValue;
            if (!this.currentNode || this.currentNode.children) throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
            if (null != name && (name = getValue(name)), isObject(name)) for (attName in name) hasProp.call(name, attName) && (attValue = name[attName], 
            this.attribute(attName, attValue)); else isFunction(value) && (value = value.apply()), 
            this.options.keepNullAttributes && null == value ? this.currentNode.attribs[name] = new XMLAttribute$1(this, name, "") : null != value && (this.currentNode.attribs[name] = new XMLAttribute$1(this, name, value));
            return this;
        }, XMLDocumentCB.prototype.text = function(value) {
            var node;
            return this.openCurrent(), node = new XMLText$1(this, value), this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), 
            this;
        }, XMLDocumentCB.prototype.cdata = function(value) {
            var node;
            return this.openCurrent(), node = new XMLCData$1(this, value), this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), 
            this;
        }, XMLDocumentCB.prototype.comment = function(value) {
            var node;
            return this.openCurrent(), node = new XMLComment$1(this, value), this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), 
            this;
        }, XMLDocumentCB.prototype.raw = function(value) {
            var node;
            return this.openCurrent(), node = new XMLRaw$1(this, value), this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), 
            this;
        }, XMLDocumentCB.prototype.instruction = function(target, value) {
            var i, insTarget, insValue, len, node;
            if (this.openCurrent(), null != target && (target = getValue(target)), null != value && (value = getValue(value)), 
            Array.isArray(target)) for (i = 0, len = target.length; i < len; i++) insTarget = target[i], 
            this.instruction(insTarget); else if (isObject(target)) for (insTarget in target) hasProp.call(target, insTarget) && (insValue = target[insTarget], 
            this.instruction(insTarget, insValue)); else isFunction(value) && (value = value.apply()), 
            node = new XMLProcessingInstruction$1(this, target, value), this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        }, XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
            var node;
            if (this.openCurrent(), this.documentStarted) throw new Error("declaration() must be the first node.");
            return node = new XMLDeclaration$1(this, version, encoding, standalone), this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), 
            this;
        }, XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
            if (this.openCurrent(), null == root) throw new Error("Missing root node name.");
            if (this.root) throw new Error("dtd() must come before the root node.");
            return this.currentNode = new XMLDocType$1(this, pubID, sysID), this.currentNode.rootNodeName = root, 
            this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, 
            this;
        }, XMLDocumentCB.prototype.dtdElement = function(name, value) {
            var node;
            return this.openCurrent(), node = new XMLDTDElement$1(this, name, value), this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), 
            this;
        }, XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            var node;
            return this.openCurrent(), node = new XMLDTDAttList$1(this, elementName, attributeName, attributeType, defaultValueType, defaultValue), 
            this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), 
            this;
        }, XMLDocumentCB.prototype.entity = function(name, value) {
            var node;
            return this.openCurrent(), node = new XMLDTDEntity$1(this, !1, name, value), this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), 
            this;
        }, XMLDocumentCB.prototype.pEntity = function(name, value) {
            var node;
            return this.openCurrent(), node = new XMLDTDEntity$1(this, !0, name, value), this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), 
            this;
        }, XMLDocumentCB.prototype.notation = function(name, value) {
            var node;
            return this.openCurrent(), node = new XMLDTDNotation$1(this, name, value), this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), 
            this;
        }, XMLDocumentCB.prototype.up = function() {
            if (this.currentLevel < 0) throw new Error("The document node has no parent.");
            return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), 
            this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], 
            this.currentLevel--, this;
        }, XMLDocumentCB.prototype.end = function() {
            for (;this.currentLevel >= 0; ) this.up();
            return this.onEnd();
        }, XMLDocumentCB.prototype.openCurrent = function() {
            if (this.currentNode) return this.currentNode.children = !0, this.openNode(this.currentNode);
        }, XMLDocumentCB.prototype.openNode = function(node) {
            var att, chunk, name, ref1;
            if (!node.isOpen) {
                if (this.root || 0 !== this.currentLevel || node.type !== NodeType$1.Element || (this.root = node), 
                chunk = "", node.type === NodeType$1.Element) {
                    for (name in this.writerOptions.state = WriterState$1.OpenTag, chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name, 
                    ref1 = node.attribs) hasProp.call(ref1, name) && (att = ref1[name], chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel));
                    chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel), 
                    this.writerOptions.state = WriterState$1.InsideTag;
                } else this.writerOptions.state = WriterState$1.OpenTag, chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName, 
                node.pubID && node.sysID ? chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"' : node.sysID && (chunk += ' SYSTEM "' + node.sysID + '"'), 
                node.children ? (chunk += " [", this.writerOptions.state = WriterState$1.InsideTag) : (this.writerOptions.state = WriterState$1.CloseTag, 
                chunk += ">"), chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
                return this.onData(chunk, this.currentLevel), node.isOpen = !0;
            }
        }, XMLDocumentCB.prototype.closeNode = function(node) {
            var chunk;
            if (!node.isClosed) return this.writerOptions.state = WriterState$1.CloseTag, chunk = node.type === NodeType$1.Element ? this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel) : this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel), 
            this.writerOptions.state = WriterState$1.None, this.onData(chunk, this.currentLevel), 
            node.isClosed = !0;
        }, XMLDocumentCB.prototype.onData = function(chunk, level) {
            return this.documentStarted = !0, this.onDataCallback(chunk, level + 1);
        }, XMLDocumentCB.prototype.onEnd = function() {
            return this.documentCompleted = !0, this.onEndCallback();
        }, XMLDocumentCB.prototype.debugInfo = function(name) {
            return null == name ? "" : "node: <" + name + ">";
        }, XMLDocumentCB.prototype.ele = function() {
            return this.element.apply(this, arguments);
        }, XMLDocumentCB.prototype.nod = function(name, attributes, text) {
            return this.node(name, attributes, text);
        }, XMLDocumentCB.prototype.txt = function(value) {
            return this.text(value);
        }, XMLDocumentCB.prototype.dat = function(value) {
            return this.cdata(value);
        }, XMLDocumentCB.prototype.com = function(value) {
            return this.comment(value);
        }, XMLDocumentCB.prototype.ins = function(target, value) {
            return this.instruction(target, value);
        }, XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
        }, XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
            return this.doctype(root, pubID, sysID);
        }, XMLDocumentCB.prototype.e = function(name, attributes, text) {
            return this.element(name, attributes, text);
        }, XMLDocumentCB.prototype.n = function(name, attributes, text) {
            return this.node(name, attributes, text);
        }, XMLDocumentCB.prototype.t = function(value) {
            return this.text(value);
        }, XMLDocumentCB.prototype.d = function(value) {
            return this.cdata(value);
        }, XMLDocumentCB.prototype.c = function(value) {
            return this.comment(value);
        }, XMLDocumentCB.prototype.r = function(value) {
            return this.raw(value);
        }, XMLDocumentCB.prototype.i = function(target, value) {
            return this.instruction(target, value);
        }, XMLDocumentCB.prototype.att = function() {
            return this.currentNode && this.currentNode.type === NodeType$1.DocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
        }, XMLDocumentCB.prototype.a = function() {
            return this.currentNode && this.currentNode.type === NodeType$1.DocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
        }, XMLDocumentCB.prototype.ent = function(name, value) {
            return this.entity(name, value);
        }, XMLDocumentCB.prototype.pent = function(name, value) {
            return this.pEntity(name, value);
        }, XMLDocumentCB.prototype.not = function(name, value) {
            return this.notation(name, value);
        }, XMLDocumentCB;
    }();
}).call(commonjsGlobal);

var XMLStreamWriter = {
    exports: {}
};

(function() {
    var NodeType$1, WriterState$1, XMLWriterBase$1, hasProp = {}.hasOwnProperty;
    NodeType$1 = NodeType.exports, XMLWriterBase$1 = XMLWriterBase.exports, WriterState$1 = WriterState.exports, 
    XMLStreamWriter.exports = function(superClass) {
        function XMLStreamWriter(stream, options) {
            this.stream = stream, XMLStreamWriter.__super__.constructor.call(this, options);
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(XMLStreamWriter, superClass), XMLStreamWriter.prototype.endline = function(node, options, level) {
            return node.isLastRootNode && options.state === WriterState$1.CloseTag ? "" : XMLStreamWriter.__super__.endline.call(this, node, options, level);
        }, XMLStreamWriter.prototype.document = function(doc, options) {
            var child, i, j, k, len, len1, ref, ref1, results;
            for (i = j = 0, len = (ref = doc.children).length; j < len; i = ++j) (child = ref[i]).isLastRootNode = i === doc.children.length - 1;
            for (options = this.filterOptions(options), results = [], k = 0, len1 = (ref1 = doc.children).length; k < len1; k++) child = ref1[k], 
            results.push(this.writeChildNode(child, options, 0));
            return results;
        }, XMLStreamWriter.prototype.attribute = function(att, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
        }, XMLStreamWriter.prototype.cdata = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));
        }, XMLStreamWriter.prototype.comment = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));
        }, XMLStreamWriter.prototype.declaration = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));
        }, XMLStreamWriter.prototype.docType = function(node, options, level) {
            var child, j, len, ref;
            if (level || (level = 0), this.openNode(node, options, level), options.state = WriterState$1.OpenTag, 
            this.stream.write(this.indent(node, options, level)), this.stream.write("<!DOCTYPE " + node.root().name), 
            node.pubID && node.sysID ? this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"') : node.sysID && this.stream.write(' SYSTEM "' + node.sysID + '"'), 
            node.children.length > 0) {
                for (this.stream.write(" ["), this.stream.write(this.endline(node, options, level)), 
                options.state = WriterState$1.InsideTag, j = 0, len = (ref = node.children).length; j < len; j++) child = ref[j], 
                this.writeChildNode(child, options, level + 1);
                options.state = WriterState$1.CloseTag, this.stream.write("]");
            }
            return options.state = WriterState$1.CloseTag, this.stream.write(options.spaceBeforeSlash + ">"), 
            this.stream.write(this.endline(node, options, level)), options.state = WriterState$1.None, 
            this.closeNode(node, options, level);
        }, XMLStreamWriter.prototype.element = function(node, options, level) {
            var att, child, childNodeCount, firstChildNode, j, len, name, ref, ref1;
            for (name in level || (level = 0), this.openNode(node, options, level), options.state = WriterState$1.OpenTag, 
            this.stream.write(this.indent(node, options, level) + "<" + node.name), ref = node.attribs) hasProp.call(ref, name) && (att = ref[name], 
            this.attribute(att, options, level));
            if (firstChildNode = 0 === (childNodeCount = node.children.length) ? null : node.children[0], 
            0 === childNodeCount || node.children.every((function(e) {
                return (e.type === NodeType$1.Text || e.type === NodeType$1.Raw) && "" === e.value;
            }))) options.allowEmpty ? (this.stream.write(">"), options.state = WriterState$1.CloseTag, 
            this.stream.write("</" + node.name + ">")) : (options.state = WriterState$1.CloseTag, 
            this.stream.write(options.spaceBeforeSlash + "/>")); else if (!options.pretty || 1 !== childNodeCount || firstChildNode.type !== NodeType$1.Text && firstChildNode.type !== NodeType$1.Raw || null == firstChildNode.value) {
                for (this.stream.write(">" + this.endline(node, options, level)), options.state = WriterState$1.InsideTag, 
                j = 0, len = (ref1 = node.children).length; j < len; j++) child = ref1[j], this.writeChildNode(child, options, level + 1);
                options.state = WriterState$1.CloseTag, this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
            } else this.stream.write(">"), options.state = WriterState$1.InsideTag, options.suppressPrettyCount++, 
            this.writeChildNode(firstChildNode, options, level + 1), options.suppressPrettyCount--, 
            options.state = WriterState$1.CloseTag, this.stream.write("</" + node.name + ">");
            return this.stream.write(this.endline(node, options, level)), options.state = WriterState$1.None, 
            this.closeNode(node, options, level);
        }, XMLStreamWriter.prototype.processingInstruction = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));
        }, XMLStreamWriter.prototype.raw = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));
        }, XMLStreamWriter.prototype.text = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));
        }, XMLStreamWriter.prototype.dtdAttList = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));
        }, XMLStreamWriter.prototype.dtdElement = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));
        }, XMLStreamWriter.prototype.dtdEntity = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));
        }, XMLStreamWriter.prototype.dtdNotation = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));
        }, XMLStreamWriter;
    }(XMLWriterBase$1);
}).call(commonjsGlobal), function() {
    var NodeType$1, WriterState$1, XMLDOMImplementation$1, XMLDocument$1, XMLDocumentCB$1, XMLStreamWriter$1, XMLStringWriter$1, assign, isFunction, ref;
    assign = (ref = Utility).assign, isFunction = ref.isFunction, XMLDOMImplementation$1 = XMLDOMImplementation.exports, 
    XMLDocument$1 = XMLDocument.exports, XMLDocumentCB$1 = XMLDocumentCB.exports, XMLStringWriter$1 = XMLStringWriter.exports, 
    XMLStreamWriter$1 = XMLStreamWriter.exports, NodeType$1 = NodeType.exports, WriterState$1 = WriterState.exports, 
    lib$1.create = function(name, xmldec, doctype, options) {
        var doc, root;
        if (null == name) throw new Error("Root element needs a name.");
        return options = assign({}, xmldec, doctype, options), root = (doc = new XMLDocument$1(options)).element(name), 
        options.headless || (doc.declaration(options), null == options.pubID && null == options.sysID || doc.dtd(options)), 
        root;
    }, lib$1.begin = function(options, onData, onEnd) {
        var ref1;
        return isFunction(options) && (onData = (ref1 = [ options, onData ])[0], onEnd = ref1[1], 
        options = {}), onData ? new XMLDocumentCB$1(options, onData, onEnd) : new XMLDocument$1(options);
    }, lib$1.stringWriter = function(options) {
        return new XMLStringWriter$1(options);
    }, lib$1.streamWriter = function(stream, options) {
        return new XMLStreamWriter$1(stream, options);
    }, lib$1.implementation = new XMLDOMImplementation$1, lib$1.nodeType = NodeType$1, 
    lib$1.writerState = WriterState$1;
}.call(commonjsGlobal), function() {
    var builder$1, defaults$1, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
    builder$1 = lib$1, defaults$1 = defaults.defaults, requiresCDATA = function(entry) {
        return "string" == typeof entry && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
    }, wrapCDATA = function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
    }, escapeCDATA = function(entry) {
        return entry.replace("]]>", "]]]]><![CDATA[>");
    }, builder.Builder = function() {
        function Builder(opts) {
            var key, ref, value;
            for (key in this.options = {}, ref = defaults$1[.2]) hasProp.call(ref, key) && (value = ref[key], 
            this.options[key] = value);
            for (key in opts) hasProp.call(opts, key) && (value = opts[key], this.options[key] = value);
        }
        return Builder.prototype.buildObject = function(rootObj) {
            var attrkey, charkey, render, rootElement, rootName, _this;
            return attrkey = this.options.attrkey, charkey = this.options.charkey, 1 === Object.keys(rootObj).length && this.options.rootName === defaults$1[.2].rootName ? rootObj = rootObj[rootName = Object.keys(rootObj)[0]] : rootName = this.options.rootName, 
            _this = this, render = function(element, obj) {
                var attr, child, entry, index, key, value;
                if ("object" != typeof obj) _this.options.cdata && requiresCDATA(obj) ? element.raw(wrapCDATA(obj)) : element.txt(obj); else if (Array.isArray(obj)) {
                    for (index in obj) if (hasProp.call(obj, index)) for (key in child = obj[index]) entry = child[key], 
                    element = render(element.ele(key), entry).up();
                } else for (key in obj) if (hasProp.call(obj, key)) if (child = obj[key], key === attrkey) {
                    if ("object" == typeof child) for (attr in child) value = child[attr], element = element.att(attr, value);
                } else if (key === charkey) element = _this.options.cdata && requiresCDATA(child) ? element.raw(wrapCDATA(child)) : element.txt(child); else if (Array.isArray(child)) for (index in child) hasProp.call(child, index) && (element = "string" == typeof (entry = child[index]) ? _this.options.cdata && requiresCDATA(entry) ? element.ele(key).raw(wrapCDATA(entry)).up() : element.ele(key, entry).up() : render(element.ele(key), entry).up()); else "object" == typeof child ? element = render(element.ele(key), child).up() : "string" == typeof child && _this.options.cdata && requiresCDATA(child) ? element = element.ele(key).raw(wrapCDATA(child)).up() : (null == child && (child = ""), 
                element = element.ele(key, child.toString()).up());
                return element;
            }, rootElement = builder$1.create(rootName, this.options.xmldec, this.options.doctype, {
                headless: this.options.headless,
                allowSurrogateChars: this.options.allowSurrogateChars
            }), render(rootElement, rootObj).end(this.options.renderOpts);
        }, Builder;
    }();
}.call(commonjsGlobal);

var parser = {}, sax = {};

!function(sax) {
    sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
    }, sax.SAXParser = SAXParser, sax.SAXStream = SAXStream, sax.createStream = function createStream(strict, opt) {
        return new SAXStream(strict, opt);
    }, sax.MAX_BUFFER_LENGTH = 65536;
    var Stream, buffers = [ "comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script" ];
    function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);
        !function clearBuffers(parser) {
            for (var i = 0, l = buffers.length; i < l; i++) parser[buffers[i]] = "";
        }(this), this.q = this.c = "", this.bufferCheckPosition = sax.MAX_BUFFER_LENGTH, 
        this.opt = opt || {}, this.opt.lowercase = this.opt.lowercase || this.opt.lowercasetags, 
        this.looseCase = this.opt.lowercase ? "toLowerCase" : "toUpperCase", this.tags = [], 
        this.closed = this.closedRoot = this.sawRoot = !1, this.tag = this.error = null, 
        this.strict = !!strict, this.noscript = !(!strict && !this.opt.noscript), this.state = S.BEGIN, 
        this.strictEntities = this.opt.strictEntities, this.ENTITIES = this.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES), 
        this.attribList = [], this.opt.xmlns && (this.ns = Object.create(rootNS)), this.trackPosition = !1 !== this.opt.position, 
        this.trackPosition && (this.position = this.line = this.column = 0), emit(this, "onready");
    }
    sax.EVENTS = [ "text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace" ], 
    Object.create || (Object.create = function(o) {
        function F() {}
        return F.prototype = o, new F;
    }), Object.keys || (Object.keys = function(o) {
        var a = [];
        for (var i in o) o.hasOwnProperty(i) && a.push(i);
        return a;
    }), SAXParser.prototype = {
        end: function() {
            end(this);
        },
        write: function write(chunk) {
            if (this.error) throw this.error;
            if (this.closed) return error(this, "Cannot write after close. Assign an onready handler.");
            if (null === chunk) return end(this);
            "object" == typeof chunk && (chunk = chunk.toString());
            for (var i = 0, c = ""; c = charAt(chunk, i++), this.c = c, c; ) switch (this.trackPosition && (this.position++, 
            "\n" === c ? (this.line++, this.column = 0) : this.column++), this.state) {
              case S.BEGIN:
                if (this.state = S.BEGIN_WHITESPACE, "\ufeff" === c) continue;
                beginWhiteSpace(this, c);
                continue;

              case S.BEGIN_WHITESPACE:
                beginWhiteSpace(this, c);
                continue;

              case S.TEXT:
                if (this.sawRoot && !this.closedRoot) {
                    for (var starti = i - 1; c && "<" !== c && "&" !== c; ) (c = charAt(chunk, i++)) && this.trackPosition && (this.position++, 
                    "\n" === c ? (this.line++, this.column = 0) : this.column++);
                    this.textNode += chunk.substring(starti, i - 1);
                }
                "<" !== c || this.sawRoot && this.closedRoot && !this.strict ? (isWhitespace(c) || this.sawRoot && !this.closedRoot || strictFail(this, "Text data outside of root node."), 
                "&" === c ? this.state = S.TEXT_ENTITY : this.textNode += c) : (this.state = S.OPEN_WAKA, 
                this.startTagPosition = this.position);
                continue;

              case S.SCRIPT:
                "<" === c ? this.state = S.SCRIPT_ENDING : this.script += c;
                continue;

              case S.SCRIPT_ENDING:
                "/" === c ? this.state = S.CLOSE_TAG : (this.script += "<" + c, this.state = S.SCRIPT);
                continue;

              case S.OPEN_WAKA:
                if ("!" === c) this.state = S.SGML_DECL, this.sgmlDecl = ""; else if (isWhitespace(c)) ; else if (isMatch(nameStart, c)) this.state = S.OPEN_TAG, 
                this.tagName = c; else if ("/" === c) this.state = S.CLOSE_TAG, this.tagName = ""; else if ("?" === c) this.state = S.PROC_INST, 
                this.procInstName = this.procInstBody = ""; else {
                    if (strictFail(this, "Unencoded <"), this.startTagPosition + 1 < this.position) {
                        var pad = this.position - this.startTagPosition;
                        c = new Array(pad).join(" ") + c;
                    }
                    this.textNode += "<" + c, this.state = S.TEXT;
                }
                continue;

              case S.SGML_DECL:
                "[CDATA[" === (this.sgmlDecl + c).toUpperCase() ? (emitNode(this, "onopencdata"), 
                this.state = S.CDATA, this.sgmlDecl = "", this.cdata = "") : this.sgmlDecl + c === "--" ? (this.state = S.COMMENT, 
                this.comment = "", this.sgmlDecl = "") : "DOCTYPE" === (this.sgmlDecl + c).toUpperCase() ? (this.state = S.DOCTYPE, 
                (this.doctype || this.sawRoot) && strictFail(this, "Inappropriately located doctype declaration"), 
                this.doctype = "", this.sgmlDecl = "") : ">" === c ? (emitNode(this, "onsgmldeclaration", this.sgmlDecl), 
                this.sgmlDecl = "", this.state = S.TEXT) : isQuote(c) ? (this.state = S.SGML_DECL_QUOTED, 
                this.sgmlDecl += c) : this.sgmlDecl += c;
                continue;

              case S.SGML_DECL_QUOTED:
                c === this.q && (this.state = S.SGML_DECL, this.q = ""), this.sgmlDecl += c;
                continue;

              case S.DOCTYPE:
                ">" === c ? (this.state = S.TEXT, emitNode(this, "ondoctype", this.doctype), this.doctype = !0) : (this.doctype += c, 
                "[" === c ? this.state = S.DOCTYPE_DTD : isQuote(c) && (this.state = S.DOCTYPE_QUOTED, 
                this.q = c));
                continue;

              case S.DOCTYPE_QUOTED:
                this.doctype += c, c === this.q && (this.q = "", this.state = S.DOCTYPE);
                continue;

              case S.DOCTYPE_DTD:
                this.doctype += c, "]" === c ? this.state = S.DOCTYPE : isQuote(c) && (this.state = S.DOCTYPE_DTD_QUOTED, 
                this.q = c);
                continue;

              case S.DOCTYPE_DTD_QUOTED:
                this.doctype += c, c === this.q && (this.state = S.DOCTYPE_DTD, this.q = "");
                continue;

              case S.COMMENT:
                "-" === c ? this.state = S.COMMENT_ENDING : this.comment += c;
                continue;

              case S.COMMENT_ENDING:
                "-" === c ? (this.state = S.COMMENT_ENDED, this.comment = textopts(this.opt, this.comment), 
                this.comment && emitNode(this, "oncomment", this.comment), this.comment = "") : (this.comment += "-" + c, 
                this.state = S.COMMENT);
                continue;

              case S.COMMENT_ENDED:
                ">" !== c ? (strictFail(this, "Malformed comment"), this.comment += "--" + c, this.state = S.COMMENT) : this.state = S.TEXT;
                continue;

              case S.CDATA:
                "]" === c ? this.state = S.CDATA_ENDING : this.cdata += c;
                continue;

              case S.CDATA_ENDING:
                "]" === c ? this.state = S.CDATA_ENDING_2 : (this.cdata += "]" + c, this.state = S.CDATA);
                continue;

              case S.CDATA_ENDING_2:
                ">" === c ? (this.cdata && emitNode(this, "oncdata", this.cdata), emitNode(this, "onclosecdata"), 
                this.cdata = "", this.state = S.TEXT) : "]" === c ? this.cdata += "]" : (this.cdata += "]]" + c, 
                this.state = S.CDATA);
                continue;

              case S.PROC_INST:
                "?" === c ? this.state = S.PROC_INST_ENDING : isWhitespace(c) ? this.state = S.PROC_INST_BODY : this.procInstName += c;
                continue;

              case S.PROC_INST_BODY:
                if (!this.procInstBody && isWhitespace(c)) continue;
                "?" === c ? this.state = S.PROC_INST_ENDING : this.procInstBody += c;
                continue;

              case S.PROC_INST_ENDING:
                ">" === c ? (emitNode(this, "onprocessinginstruction", {
                    name: this.procInstName,
                    body: this.procInstBody
                }), this.procInstName = this.procInstBody = "", this.state = S.TEXT) : (this.procInstBody += "?" + c, 
                this.state = S.PROC_INST_BODY);
                continue;

              case S.OPEN_TAG:
                isMatch(nameBody, c) ? this.tagName += c : (newTag(this), ">" === c ? openTag(this) : "/" === c ? this.state = S.OPEN_TAG_SLASH : (isWhitespace(c) || strictFail(this, "Invalid character in tag name"), 
                this.state = S.ATTRIB));
                continue;

              case S.OPEN_TAG_SLASH:
                ">" === c ? (openTag(this, !0), closeTag(this)) : (strictFail(this, "Forward-slash in opening tag not followed by >"), 
                this.state = S.ATTRIB);
                continue;

              case S.ATTRIB:
                if (isWhitespace(c)) continue;
                ">" === c ? openTag(this) : "/" === c ? this.state = S.OPEN_TAG_SLASH : isMatch(nameStart, c) ? (this.attribName = c, 
                this.attribValue = "", this.state = S.ATTRIB_NAME) : strictFail(this, "Invalid attribute name");
                continue;

              case S.ATTRIB_NAME:
                "=" === c ? this.state = S.ATTRIB_VALUE : ">" === c ? (strictFail(this, "Attribute without value"), 
                this.attribValue = this.attribName, attrib(this), openTag(this)) : isWhitespace(c) ? this.state = S.ATTRIB_NAME_SAW_WHITE : isMatch(nameBody, c) ? this.attribName += c : strictFail(this, "Invalid attribute name");
                continue;

              case S.ATTRIB_NAME_SAW_WHITE:
                if ("=" === c) this.state = S.ATTRIB_VALUE; else {
                    if (isWhitespace(c)) continue;
                    strictFail(this, "Attribute without value"), this.tag.attributes[this.attribName] = "", 
                    this.attribValue = "", emitNode(this, "onattribute", {
                        name: this.attribName,
                        value: ""
                    }), this.attribName = "", ">" === c ? openTag(this) : isMatch(nameStart, c) ? (this.attribName = c, 
                    this.state = S.ATTRIB_NAME) : (strictFail(this, "Invalid attribute name"), this.state = S.ATTRIB);
                }
                continue;

              case S.ATTRIB_VALUE:
                if (isWhitespace(c)) continue;
                isQuote(c) ? (this.q = c, this.state = S.ATTRIB_VALUE_QUOTED) : (strictFail(this, "Unquoted attribute value"), 
                this.state = S.ATTRIB_VALUE_UNQUOTED, this.attribValue = c);
                continue;

              case S.ATTRIB_VALUE_QUOTED:
                if (c !== this.q) {
                    "&" === c ? this.state = S.ATTRIB_VALUE_ENTITY_Q : this.attribValue += c;
                    continue;
                }
                attrib(this), this.q = "", this.state = S.ATTRIB_VALUE_CLOSED;
                continue;

              case S.ATTRIB_VALUE_CLOSED:
                isWhitespace(c) ? this.state = S.ATTRIB : ">" === c ? openTag(this) : "/" === c ? this.state = S.OPEN_TAG_SLASH : isMatch(nameStart, c) ? (strictFail(this, "No whitespace between attributes"), 
                this.attribName = c, this.attribValue = "", this.state = S.ATTRIB_NAME) : strictFail(this, "Invalid attribute name");
                continue;

              case S.ATTRIB_VALUE_UNQUOTED:
                if (!isAttribEnd(c)) {
                    "&" === c ? this.state = S.ATTRIB_VALUE_ENTITY_U : this.attribValue += c;
                    continue;
                }
                attrib(this), ">" === c ? openTag(this) : this.state = S.ATTRIB;
                continue;

              case S.CLOSE_TAG:
                if (this.tagName) ">" === c ? closeTag(this) : isMatch(nameBody, c) ? this.tagName += c : this.script ? (this.script += "</" + this.tagName, 
                this.tagName = "", this.state = S.SCRIPT) : (isWhitespace(c) || strictFail(this, "Invalid tagname in closing tag"), 
                this.state = S.CLOSE_TAG_SAW_WHITE); else {
                    if (isWhitespace(c)) continue;
                    notMatch(nameStart, c) ? this.script ? (this.script += "</" + c, this.state = S.SCRIPT) : strictFail(this, "Invalid tagname in closing tag.") : this.tagName = c;
                }
                continue;

              case S.CLOSE_TAG_SAW_WHITE:
                if (isWhitespace(c)) continue;
                ">" === c ? closeTag(this) : strictFail(this, "Invalid characters in closing tag");
                continue;

              case S.TEXT_ENTITY:
              case S.ATTRIB_VALUE_ENTITY_Q:
              case S.ATTRIB_VALUE_ENTITY_U:
                var returnState, buffer;
                switch (this.state) {
                  case S.TEXT_ENTITY:
                    returnState = S.TEXT, buffer = "textNode";
                    break;

                  case S.ATTRIB_VALUE_ENTITY_Q:
                    returnState = S.ATTRIB_VALUE_QUOTED, buffer = "attribValue";
                    break;

                  case S.ATTRIB_VALUE_ENTITY_U:
                    returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = "attribValue";
                }
                ";" === c ? (this[buffer] += parseEntity(this), this.entity = "", this.state = returnState) : isMatch(this.entity.length ? entityBody : entityStart, c) ? this.entity += c : (strictFail(this, "Invalid character in entity name"), 
                this[buffer] += "&" + this.entity + c, this.entity = "", this.state = returnState);
                continue;

              default:
                throw new Error(this, "Unknown state: " + this.state);
            }
            return this.position >= this.bufferCheckPosition && function checkBufferLength(parser) {
                for (var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10), maxActual = 0, i = 0, l = buffers.length; i < l; i++) {
                    var len = parser[buffers[i]].length;
                    if (len > maxAllowed) switch (buffers[i]) {
                      case "textNode":
                        closeText(parser);
                        break;

                      case "cdata":
                        emitNode(parser, "oncdata", parser.cdata), parser.cdata = "";
                        break;

                      case "script":
                        emitNode(parser, "onscript", parser.script), parser.script = "";
                        break;

                      default:
                        error(parser, "Max buffer length exceeded: " + buffers[i]);
                    }
                    maxActual = Math.max(maxActual, len);
                }
                var m = sax.MAX_BUFFER_LENGTH - maxActual;
                parser.bufferCheckPosition = m + parser.position;
            }(this), this;
        }
        /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */ ,
        resume: function() {
            return this.error = null, this;
        },
        close: function() {
            return this.write(null);
        },
        flush: function() {
            !function flushBuffers(parser) {
                closeText(parser), "" !== parser.cdata && (emitNode(parser, "oncdata", parser.cdata), 
                parser.cdata = ""), "" !== parser.script && (emitNode(parser, "onscript", parser.script), 
                parser.script = "");
            }(this);
        }
    };
    try {
        Stream = require("stream").Stream;
    } catch (ex) {
        Stream = function() {};
    }
    var streamWraps = sax.EVENTS.filter((function(ev) {
        return "error" !== ev && "end" !== ev;
    }));
    function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);
        Stream.apply(this), this._parser = new SAXParser(strict, opt), this.writable = !0, 
        this.readable = !0;
        var me = this;
        this._parser.onend = function() {
            me.emit("end");
        }, this._parser.onerror = function(er) {
            me.emit("error", er), me._parser.error = null;
        }, this._decoder = null, streamWraps.forEach((function(ev) {
            Object.defineProperty(me, "on" + ev, {
                get: function() {
                    return me._parser["on" + ev];
                },
                set: function(h) {
                    if (!h) return me.removeAllListeners(ev), me._parser["on" + ev] = h, h;
                    me.on(ev, h);
                },
                enumerable: !0,
                configurable: !1
            });
        }));
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
            value: SAXStream
        }
    }), SAXStream.prototype.write = function(data) {
        if ("function" == typeof Buffer && "function" == typeof Buffer.isBuffer && Buffer.isBuffer(data)) {
            if (!this._decoder) {
                var SD = require$$0__default$4.default.StringDecoder;
                this._decoder = new SD("utf8");
            }
            data = this._decoder.write(data);
        }
        return this._parser.write(data.toString()), this.emit("data", data), !0;
    }, SAXStream.prototype.end = function(chunk) {
        return chunk && chunk.length && this.write(chunk), this._parser.end(), !0;
    }, SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        return me._parser["on" + ev] || -1 === streamWraps.indexOf(ev) || (me._parser["on" + ev] = function() {
            var args = 1 === arguments.length ? [ arguments[0] ] : Array.apply(null, arguments);
            args.splice(0, 0, ev), me.emit.apply(me, args);
        }), Stream.prototype.on.call(me, ev, handler);
    };
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace", rootNS = {
        xml: XML_NAMESPACE,
        xmlns: "http://www.w3.org/2000/xmlns/"
    }, nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
        return " " === c || "\n" === c || "\r" === c || "\t" === c;
    }
    function isQuote(c) {
        return '"' === c || "'" === c;
    }
    function isAttribEnd(c) {
        return ">" === c || isWhitespace(c);
    }
    function isMatch(regex, c) {
        return regex.test(c);
    }
    function notMatch(regex, c) {
        return !isMatch(regex, c);
    }
    var stringFromCharCode, floor, fromCodePoint, S = 0;
    for (var s in sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++
    }, sax.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
    }, sax.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
    }, Object.keys(sax.ENTITIES).forEach((function(key) {
        var e = sax.ENTITIES[key], s = "number" == typeof e ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s;
    })), sax.STATE) sax.STATE[sax.STATE[s]] = s;
    function emit(parser, event, data) {
        parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
        parser.textNode && closeText(parser), emit(parser, nodeType, data);
    }
    function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode), parser.textNode && emit(parser, "ontext", parser.textNode), 
        parser.textNode = "";
    }
    function textopts(opt, text) {
        return opt.trim && (text = text.trim()), opt.normalize && (text = text.replace(/\s+/g, " ")), 
        text;
    }
    function error(parser, er) {
        return closeText(parser), parser.trackPosition && (er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c), 
        er = new Error(er), parser.error = er, emit(parser, "onerror", er), parser;
    }
    function end(parser) {
        return parser.sawRoot && !parser.closedRoot && strictFail(parser, "Unclosed root tag"), 
        parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT && error(parser, "Unexpected end"), 
        closeText(parser), parser.c = "", parser.closed = !0, emit(parser, "onend"), SAXParser.call(parser, parser.strict, parser.opt), 
        parser;
    }
    function strictFail(parser, message) {
        if ("object" != typeof parser || !(parser instanceof SAXParser)) throw new Error("bad call to strictFail");
        parser.strict && error(parser, message);
    }
    function newTag(parser) {
        parser.strict || (parser.tagName = parser.tagName[parser.looseCase]());
        var parent = parser.tags[parser.tags.length - 1] || parser, tag = parser.tag = {
            name: parser.tagName,
            attributes: {}
        };
        parser.opt.xmlns && (tag.ns = parent.ns), parser.attribList.length = 0, emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
        var qualName = name.indexOf(":") < 0 ? [ "", name ] : name.split(":"), prefix = qualName[0], local = qualName[1];
        return attribute && "xmlns" === name && (prefix = "xmlns", local = ""), {
            prefix,
            local
        };
    }
    function attrib(parser) {
        if (parser.strict || (parser.attribName = parser.attribName[parser.looseCase]()), 
        -1 !== parser.attribList.indexOf(parser.attribName) || parser.tag.attributes.hasOwnProperty(parser.attribName)) parser.attribName = parser.attribValue = ""; else {
            if (parser.opt.xmlns) {
                var qn = qname(parser.attribName, !0), prefix = qn.prefix, local = qn.local;
                if ("xmlns" === prefix) if ("xml" === local && parser.attribValue !== XML_NAMESPACE) strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue); else if ("xmlns" === local && "http://www.w3.org/2000/xmlns/" !== parser.attribValue) strictFail(parser, "xmlns: prefix must be bound to http://www.w3.org/2000/xmlns/\nActual: " + parser.attribValue); else {
                    var tag = parser.tag, parent = parser.tags[parser.tags.length - 1] || parser;
                    tag.ns === parent.ns && (tag.ns = Object.create(parent.ns)), tag.ns[local] = parser.attribValue;
                }
                parser.attribList.push([ parser.attribName, parser.attribValue ]);
            } else parser.tag.attributes[parser.attribName] = parser.attribValue, emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: parser.attribValue
            });
            parser.attribName = parser.attribValue = "";
        }
    }
    function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
            var tag = parser.tag, qn = qname(parser.tagName);
            tag.prefix = qn.prefix, tag.local = qn.local, tag.uri = tag.ns[qn.prefix] || "", 
            tag.prefix && !tag.uri && (strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName)), 
            tag.uri = qn.prefix);
            var parent = parser.tags[parser.tags.length - 1] || parser;
            tag.ns && parent.ns !== tag.ns && Object.keys(tag.ns).forEach((function(p) {
                emitNode(parser, "onopennamespace", {
                    prefix: p,
                    uri: tag.ns[p]
                });
            }));
            for (var i = 0, l = parser.attribList.length; i < l; i++) {
                var nv = parser.attribList[i], name = nv[0], value = nv[1], qualName = qname(name, !0), prefix = qualName.prefix, local = qualName.local, uri = "" === prefix ? "" : tag.ns[prefix] || "", a = {
                    name,
                    value,
                    prefix,
                    local,
                    uri
                };
                prefix && "xmlns" !== prefix && !uri && (strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix)), 
                a.uri = prefix), parser.tag.attributes[name] = a, emitNode(parser, "onattribute", a);
            }
            parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing, parser.sawRoot = !0, parser.tags.push(parser.tag), 
        emitNode(parser, "onopentag", parser.tag), selfClosing || (parser.noscript || "script" !== parser.tagName.toLowerCase() ? parser.state = S.TEXT : parser.state = S.SCRIPT, 
        parser.tag = null, parser.tagName = ""), parser.attribName = parser.attribValue = "", 
        parser.attribList.length = 0;
    }
    function closeTag(parser) {
        if (!parser.tagName) return strictFail(parser, "Weird empty close tag."), parser.textNode += "</>", 
        void (parser.state = S.TEXT);
        if (parser.script) {
            if ("script" !== parser.tagName) return parser.script += "</" + parser.tagName + ">", 
            parser.tagName = "", void (parser.state = S.SCRIPT);
            emitNode(parser, "onscript", parser.script), parser.script = "";
        }
        var t = parser.tags.length, tagName = parser.tagName;
        parser.strict || (tagName = tagName[parser.looseCase]());
        for (var closeTo = tagName; t-- && parser.tags[t].name !== closeTo; ) strictFail(parser, "Unexpected close tag");
        if (t < 0) return strictFail(parser, "Unmatched closing tag: " + parser.tagName), 
        parser.textNode += "</" + parser.tagName + ">", void (parser.state = S.TEXT);
        parser.tagName = tagName;
        for (var s = parser.tags.length; s-- > t; ) {
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name, emitNode(parser, "onclosetag", parser.tagName);
            var x = {};
            for (var i in tag.ns) x[i] = tag.ns[i];
            var parent = parser.tags[parser.tags.length - 1] || parser;
            parser.opt.xmlns && tag.ns !== parent.ns && Object.keys(tag.ns).forEach((function(p) {
                var n = tag.ns[p];
                emitNode(parser, "onclosenamespace", {
                    prefix: p,
                    uri: n
                });
            }));
        }
        0 === t && (parser.closedRoot = !0), parser.tagName = parser.attribValue = parser.attribName = "", 
        parser.attribList.length = 0, parser.state = S.TEXT;
    }
    function parseEntity(parser) {
        var num, entity = parser.entity, entityLC = entity.toLowerCase(), numStr = "";
        return parser.ENTITIES[entity] ? parser.ENTITIES[entity] : parser.ENTITIES[entityLC] ? parser.ENTITIES[entityLC] : ("#" === (entity = entityLC).charAt(0) && ("x" === entity.charAt(1) ? (entity = entity.slice(2), 
        numStr = (num = parseInt(entity, 16)).toString(16)) : (entity = entity.slice(1), 
        numStr = (num = parseInt(entity, 10)).toString(10))), entity = entity.replace(/^0+/, ""), 
        isNaN(num) || numStr.toLowerCase() !== entity ? (strictFail(parser, "Invalid character entity"), 
        "&" + parser.entity + ";") : String.fromCodePoint(num));
    }
    function beginWhiteSpace(parser, c) {
        "<" === c ? (parser.state = S.OPEN_WAKA, parser.startTagPosition = parser.position) : isWhitespace(c) || (strictFail(parser, "Non-whitespace before first tag."), 
        parser.textNode = c, parser.state = S.TEXT);
    }
    function charAt(chunk, i) {
        var result = "";
        return i < chunk.length && (result = chunk.charAt(i)), result;
    }
    S = sax.STATE, String.fromCodePoint || (stringFromCharCode = String.fromCharCode, 
    floor = Math.floor, fromCodePoint = function() {
        var highSurrogate, lowSurrogate, MAX_SIZE = 0x4000, codeUnits = [], index = -1, length = arguments.length;
        if (!length) return "";
        for (var result = ""; ++index < length; ) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) !== codePoint) throw RangeError("Invalid code point: " + codePoint);
            codePoint <= 0xFFFF ? codeUnits.push(codePoint) : (highSurrogate = 0xD800 + ((codePoint -= 0x10000) >> 10), 
            lowSurrogate = codePoint % 0x400 + 0xDC00, codeUnits.push(highSurrogate, lowSurrogate)), 
            (index + 1 === length || codeUnits.length > MAX_SIZE) && (result += stringFromCharCode.apply(null, codeUnits), 
            codeUnits.length = 0);
        }
        return result;
    }, Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
        value: fromCodePoint,
        configurable: !0,
        writable: !0
    }) : String.fromCodePoint = fromCodePoint);
}(sax);

var bom = {};

(function() {
    bom.stripBOM = function(str) {
        return "\ufeff" === str[0] ? str.substring(1) : str;
    };
}).call(commonjsGlobal);

var exports, processors = {};

(function() {
    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/), processors.normalize = function(str) {
        return str.toLowerCase();
    }, processors.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
    }, processors.stripPrefix = function(str) {
        return str.replace(prefixMatch, "");
    }, processors.parseNumbers = function(str) {
        return isNaN(str) || (str = str % 1 == 0 ? parseInt(str, 10) : parseFloat(str)), 
        str;
    }, processors.parseBooleans = function(str) {
        return /^(?:true|false)$/i.test(str) && (str = "true" === str.toLowerCase()), str;
    };
}).call(commonjsGlobal), exports = parser, function() {
    var bom$1, defaults$1, events, isEmpty, processItem, processors$1, sax$1, setImmediate, bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    }, hasProp = {}.hasOwnProperty;
    sax$1 = sax, events = require$$14__default.default, bom$1 = bom, processors$1 = processors, 
    setImmediate = require$$4__default$1.default.setImmediate, defaults$1 = defaults.defaults, 
    isEmpty = function(thing) {
        return "object" == typeof thing && null != thing && 0 === Object.keys(thing).length;
    }, processItem = function(processors, item, key) {
        var i, len;
        for (i = 0, len = processors.length; i < len; i++) item = (0, processors[i])(item, key);
        return item;
    }, exports.Parser = function(superClass) {
        function Parser(opts) {
            var key, ref, value;
            if (this.parseStringPromise = bind(this.parseStringPromise, this), this.parseString = bind(this.parseString, this), 
            this.reset = bind(this.reset, this), this.assignOrPush = bind(this.assignOrPush, this), 
            this.processAsync = bind(this.processAsync, this), !(this instanceof exports.Parser)) return new exports.Parser(opts);
            for (key in this.options = {}, ref = defaults$1[.2]) hasProp.call(ref, key) && (value = ref[key], 
            this.options[key] = value);
            for (key in opts) hasProp.call(opts, key) && (value = opts[key], this.options[key] = value);
            this.options.xmlns && (this.options.xmlnskey = this.options.attrkey + "ns"), this.options.normalizeTags && (this.options.tagNameProcessors || (this.options.tagNameProcessors = []), 
            this.options.tagNameProcessors.unshift(processors$1.normalize)), this.reset();
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(Parser, superClass), Parser.prototype.processAsync = function() {
            var chunk, err;
            try {
                return this.remaining.length <= this.options.chunkSize ? (chunk = this.remaining, 
                this.remaining = "", this.saxParser = this.saxParser.write(chunk), this.saxParser.close()) : (chunk = this.remaining.substr(0, this.options.chunkSize), 
                this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length), 
                this.saxParser = this.saxParser.write(chunk), setImmediate(this.processAsync));
            } catch (error1) {
                if (err = error1, !this.saxParser.errThrown) return this.saxParser.errThrown = !0, 
                this.emit(err);
            }
        }, Parser.prototype.assignOrPush = function(obj, key, newValue) {
            return key in obj ? (obj[key] instanceof Array || (obj[key] = [ obj[key] ]), obj[key].push(newValue)) : this.options.explicitArray ? obj[key] = [ newValue ] : obj[key] = newValue;
        }, Parser.prototype.reset = function() {
            var attrkey, charkey, ontext, stack, _this;
            return this.removeAllListeners(), this.saxParser = sax$1.parser(this.options.strict, {
                trim: !1,
                normalize: !1,
                xmlns: this.options.xmlns
            }), this.saxParser.errThrown = !1, this.saxParser.onerror = (_this = this, function(error) {
                if (_this.saxParser.resume(), !_this.saxParser.errThrown) return _this.saxParser.errThrown = !0, 
                _this.emit("error", error);
            }), this.saxParser.onend = function(_this) {
                return function() {
                    if (!_this.saxParser.ended) return _this.saxParser.ended = !0, _this.emit("end", _this.resultObject);
                };
            }(this), this.saxParser.ended = !1, this.EXPLICIT_CHARKEY = this.options.explicitCharkey, 
            this.resultObject = null, stack = [], attrkey = this.options.attrkey, charkey = this.options.charkey, 
            this.saxParser.onopentag = function(_this) {
                return function(node) {
                    var key, newValue, obj, processedKey, ref;
                    if ((obj = {})[charkey] = "", !_this.options.ignoreAttrs) for (key in ref = node.attributes) hasProp.call(ref, key) && (attrkey in obj || _this.options.mergeAttrs || (obj[attrkey] = {}), 
                    newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key], 
                    processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key, 
                    _this.options.mergeAttrs ? _this.assignOrPush(obj, processedKey, newValue) : obj[attrkey][processedKey] = newValue);
                    return obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name, 
                    _this.options.xmlns && (obj[_this.options.xmlnskey] = {
                        uri: node.uri,
                        local: node.local
                    }), stack.push(obj);
                };
            }(this), this.saxParser.onclosetag = function(_this) {
                return function() {
                    var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                    if (obj = stack.pop(), nodeName = obj["#name"], _this.options.explicitChildren && _this.options.preserveChildrenOrder || delete obj["#name"], 
                    !0 === obj.cdata && (cdata = obj.cdata, delete obj.cdata), s = stack[stack.length - 1], 
                    obj[charkey].match(/^\s*$/) && !cdata ? (emptyStr = obj[charkey], delete obj[charkey]) : (_this.options.trim && (obj[charkey] = obj[charkey].trim()), 
                    _this.options.normalize && (obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim()), 
                    obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey], 
                    1 === Object.keys(obj).length && charkey in obj && !_this.EXPLICIT_CHARKEY && (obj = obj[charkey])), 
                    isEmpty(obj) && (obj = "" !== _this.options.emptyTag ? _this.options.emptyTag : emptyStr), 
                    null != _this.options.validator && (xpath = "/" + function() {
                        var i, len, results;
                        for (results = [], i = 0, len = stack.length; i < len; i++) node = stack[i], results.push(node["#name"]);
                        return results;
                    }().concat(nodeName).join("/"), function() {
                        var err;
                        try {
                            obj = _this.options.validator(xpath, s && s[nodeName], obj);
                        } catch (error1) {
                            return err = error1, _this.emit("error", err);
                        }
                    }()), _this.options.explicitChildren && !_this.options.mergeAttrs && "object" == typeof obj) if (_this.options.preserveChildrenOrder) {
                        if (s) {
                            for (key in s[_this.options.childkey] = s[_this.options.childkey] || [], objClone = {}, 
                            obj) hasProp.call(obj, key) && (objClone[key] = obj[key]);
                            s[_this.options.childkey].push(objClone), delete obj["#name"], 1 === Object.keys(obj).length && charkey in obj && !_this.EXPLICIT_CHARKEY && (obj = obj[charkey]);
                        }
                    } else node = {}, _this.options.attrkey in obj && (node[_this.options.attrkey] = obj[_this.options.attrkey], 
                    delete obj[_this.options.attrkey]), !_this.options.charsAsChildren && _this.options.charkey in obj && (node[_this.options.charkey] = obj[_this.options.charkey], 
                    delete obj[_this.options.charkey]), Object.getOwnPropertyNames(obj).length > 0 && (node[_this.options.childkey] = obj), 
                    obj = node;
                    return stack.length > 0 ? _this.assignOrPush(s, nodeName, obj) : (_this.options.explicitRoot && (old = obj, 
                    (obj = {})[nodeName] = old), _this.resultObject = obj, _this.saxParser.ended = !0, 
                    _this.emit("end", _this.resultObject));
                };
            }(this), ontext = function(_this) {
                return function(text) {
                    var charChild, s;
                    if (s = stack[stack.length - 1]) return s[charkey] += text, _this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || "" !== text.replace(/\\n/g, "").trim()) && (s[_this.options.childkey] = s[_this.options.childkey] || [], 
                    (charChild = {
                        "#name": "__text__"
                    })[charkey] = text, _this.options.normalize && (charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim()), 
                    s[_this.options.childkey].push(charChild)), s;
                };
            }(this), this.saxParser.ontext = ontext, this.saxParser.oncdata = function(text) {
                var s;
                if (s = ontext(text)) return s.cdata = !0;
            };
        }, Parser.prototype.parseString = function(str, cb) {
            var err;
            null != cb && "function" == typeof cb && (this.on("end", (function(result) {
                return this.reset(), cb(null, result);
            })), this.on("error", (function(err) {
                return this.reset(), cb(err);
            })));
            try {
                return "" === (str = str.toString()).trim() ? (this.emit("end", null), !0) : (str = bom$1.stripBOM(str), 
                this.options.async ? (this.remaining = str, setImmediate(this.processAsync), this.saxParser) : this.saxParser.write(str).close());
            } catch (error1) {
                if (err = error1, !this.saxParser.errThrown && !this.saxParser.ended) return this.emit("error", err), 
                this.saxParser.errThrown = !0;
                if (this.saxParser.ended) throw err;
            }
        }, Parser.prototype.parseStringPromise = function(str) {
            return new Promise((_this = this, function(resolve, reject) {
                return _this.parseString(str, (function(err, value) {
                    return err ? reject(err) : resolve(value);
                }));
            }));
            var _this;
        }, Parser;
    }(events), exports.parseString = function(str, a, b) {
        var cb, options;
        return null != b ? ("function" == typeof b && (cb = b), "object" == typeof a && (options = a)) : ("function" == typeof a && (cb = a), 
        options = {}), new exports.Parser(options).parseString(str, cb);
    }, exports.parseStringPromise = function(str, a) {
        var options;
        return "object" == typeof a && (options = a), new exports.Parser(options).parseStringPromise(str);
    };
}.call(commonjsGlobal), function() {
    var builder$1, defaults$1, parser$1, processors$1, hasProp = {}.hasOwnProperty;
    defaults$1 = defaults, builder$1 = builder, parser$1 = parser, processors$1 = processors, 
    xml2js$1.defaults = defaults$1.defaults, xml2js$1.processors = processors$1, xml2js$1.ValidationError = function(superClass) {
        function ValidationError(message) {
            this.message = message;
        }
        return function(child, parent) {
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype;
        }(ValidationError, Error), ValidationError;
    }(), xml2js$1.Builder = builder$1.Builder, xml2js$1.Parser = parser$1.Parser, xml2js$1.parseString = parser$1.parseString, 
    xml2js$1.parseStringPromise = parser$1.parseStringPromise;
}.call(commonjsGlobal);

var xml2js = xml2js$1, parseAttributes = function parseAttributes(obj) {
    for (var k in "chasrset" in obj && (obj.charset = obj.chasrset, delete obj.chasrset), 
    obj) "face" !== k && "charset" !== k && (obj[k] = "padding" === k || "spacing" === k ? obj[k].split(",").map((function(val) {
        return parseInt(val, 10);
    })) : parseInt(obj[k], 10));
    return obj;
}, HEADER$1 = [ 66, 77, 70 ];

function readBlock(target, buf, i) {
    if (i > buf.length - 1) return 0;
    var blockID = buf.readUInt8(i++), blockSize = buf.readInt32LE(i);
    switch (i += 4, blockID) {
      case 1:
        target.info = function readInfo(buf, i) {
            var info = {};
            info.size = buf.readInt16LE(i);
            var bitField = buf.readUInt8(i + 2);
            return info.smooth = bitField >> 7 & 1, info.unicode = bitField >> 6 & 1, info.italic = bitField >> 5 & 1, 
            info.bold = bitField >> 4 & 1, bitField >> 3 & 1 && (info.fixedHeight = 1), info.charset = buf.readUInt8(i + 3) || "", 
            info.stretchH = buf.readUInt16LE(i + 4), info.aa = buf.readUInt8(i + 6), info.padding = [ buf.readInt8(i + 7), buf.readInt8(i + 8), buf.readInt8(i + 9), buf.readInt8(i + 10) ], 
            info.spacing = [ buf.readInt8(i + 11), buf.readInt8(i + 12) ], info.outline = buf.readUInt8(i + 13), 
            info.face = function readStringNT(buf, offset) {
                return readNameNT(buf, offset).toString("utf8");
            }(buf, i + 14), info;
        }(buf, i);
        break;

      case 2:
        target.common = function readCommon(buf, i) {
            var common = {};
            return common.lineHeight = buf.readUInt16LE(i), common.base = buf.readUInt16LE(i + 2), 
            common.scaleW = buf.readUInt16LE(i + 4), common.scaleH = buf.readUInt16LE(i + 6), 
            common.pages = buf.readUInt16LE(i + 8), buf.readUInt8(i + 10), common.packed = 0, 
            common.alphaChnl = buf.readUInt8(i + 11), common.redChnl = buf.readUInt8(i + 12), 
            common.greenChnl = buf.readUInt8(i + 13), common.blueChnl = buf.readUInt8(i + 14), 
            common;
        }(buf, i);
        break;

      case 3:
        target.pages = function readPages(buf, i, size) {
            for (var pages = [], text = readNameNT(buf, i), len = text.length + 1, count = size / len, c = 0; c < count; c++) pages[c] = buf.slice(i, i + text.length).toString("utf8"), 
            i += len;
            return pages;
        }(buf, i, blockSize);
        break;

      case 4:
        target.chars = function readChars(buf, i, blockSize) {
            for (var chars = [], count = blockSize / 20, c = 0; c < count; c++) {
                var char = {}, off = 20 * c;
                char.id = buf.readUInt32LE(i + 0 + off), char.x = buf.readUInt16LE(i + 4 + off), 
                char.y = buf.readUInt16LE(i + 6 + off), char.width = buf.readUInt16LE(i + 8 + off), 
                char.height = buf.readUInt16LE(i + 10 + off), char.xoffset = buf.readInt16LE(i + 12 + off), 
                char.yoffset = buf.readInt16LE(i + 14 + off), char.xadvance = buf.readInt16LE(i + 16 + off), 
                char.page = buf.readUInt8(i + 18 + off), char.chnl = buf.readUInt8(i + 19 + off), 
                chars[c] = char;
            }
            return chars;
        }(buf, i, blockSize);
        break;

      case 5:
        target.kernings = function readKernings(buf, i, blockSize) {
            for (var kernings = [], count = blockSize / 10, c = 0; c < count; c++) {
                var kern = {}, off = 10 * c;
                kern.first = buf.readUInt32LE(i + 0 + off), kern.second = buf.readUInt32LE(i + 4 + off), 
                kern.amount = buf.readInt16LE(i + 8 + off), kernings[c] = kern;
            }
            return kernings;
        }(buf, i, blockSize);
    }
    return 5 + blockSize;
}

function readNameNT(buf, offset) {
    for (var pos = offset; pos < buf.length && 0x00 !== buf[pos]; pos++) ;
    return buf.slice(offset, pos);
}

var fs$1 = require$$1__default.default;

function Mime() {
    this.types = Object.create(null), this.extensions = Object.create(null);
}

Mime.prototype.define = function(map) {
    for (var type in map) {
        for (var exts = map[type], i = 0; i < exts.length; i++) process.env.DEBUG_MIME && this.types[exts[i]] && console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type), 
        this.types[exts[i]] = type;
        this.extensions[type] || (this.extensions[type] = exts[0]);
    }
}, Mime.prototype.load = function(file) {
    this._loading = file;
    var map = {};
    fs$1.readFileSync(file, "ascii").split(/[\r\n]+/).forEach((function(line) {
        var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
        map[fields.shift()] = fields;
    })), this.define(map), this._loading = null;
}, Mime.prototype.lookup = function(path, fallback) {
    var ext = path.replace(/^.*[\.\/\\]/, "").toLowerCase();
    return this.types[ext] || fallback || this.default_type;
}, Mime.prototype.extension = function(mimeType) {
    var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
    return this.extensions[type];
};

var mime$1 = new Mime;

mime$1.define({
    "application/andrew-inset": [ "ez" ],
    "application/applixware": [ "aw" ],
    "application/atom+xml": [ "atom" ],
    "application/atomcat+xml": [ "atomcat" ],
    "application/atomsvc+xml": [ "atomsvc" ],
    "application/bdoc": [ "bdoc" ],
    "application/ccxml+xml": [ "ccxml" ],
    "application/cdmi-capability": [ "cdmia" ],
    "application/cdmi-container": [ "cdmic" ],
    "application/cdmi-domain": [ "cdmid" ],
    "application/cdmi-object": [ "cdmio" ],
    "application/cdmi-queue": [ "cdmiq" ],
    "application/cu-seeme": [ "cu" ],
    "application/dash+xml": [ "mpd" ],
    "application/davmount+xml": [ "davmount" ],
    "application/docbook+xml": [ "dbk" ],
    "application/dssc+der": [ "dssc" ],
    "application/dssc+xml": [ "xdssc" ],
    "application/ecmascript": [ "ecma" ],
    "application/emma+xml": [ "emma" ],
    "application/epub+zip": [ "epub" ],
    "application/exi": [ "exi" ],
    "application/font-tdpfr": [ "pfr" ],
    "application/font-woff": [],
    "application/font-woff2": [],
    "application/geo+json": [ "geojson" ],
    "application/gml+xml": [ "gml" ],
    "application/gpx+xml": [ "gpx" ],
    "application/gxf": [ "gxf" ],
    "application/gzip": [ "gz" ],
    "application/hyperstudio": [ "stk" ],
    "application/inkml+xml": [ "ink", "inkml" ],
    "application/ipfix": [ "ipfix" ],
    "application/java-archive": [ "jar", "war", "ear" ],
    "application/java-serialized-object": [ "ser" ],
    "application/java-vm": [ "class" ],
    "application/javascript": [ "js", "mjs" ],
    "application/json": [ "json", "map" ],
    "application/json5": [ "json5" ],
    "application/jsonml+json": [ "jsonml" ],
    "application/ld+json": [ "jsonld" ],
    "application/lost+xml": [ "lostxml" ],
    "application/mac-binhex40": [ "hqx" ],
    "application/mac-compactpro": [ "cpt" ],
    "application/mads+xml": [ "mads" ],
    "application/manifest+json": [ "webmanifest" ],
    "application/marc": [ "mrc" ],
    "application/marcxml+xml": [ "mrcx" ],
    "application/mathematica": [ "ma", "nb", "mb" ],
    "application/mathml+xml": [ "mathml" ],
    "application/mbox": [ "mbox" ],
    "application/mediaservercontrol+xml": [ "mscml" ],
    "application/metalink+xml": [ "metalink" ],
    "application/metalink4+xml": [ "meta4" ],
    "application/mets+xml": [ "mets" ],
    "application/mods+xml": [ "mods" ],
    "application/mp21": [ "m21", "mp21" ],
    "application/mp4": [ "mp4s", "m4p" ],
    "application/msword": [ "doc", "dot" ],
    "application/mxf": [ "mxf" ],
    "application/octet-stream": [ "bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer" ],
    "application/oda": [ "oda" ],
    "application/oebps-package+xml": [ "opf" ],
    "application/ogg": [ "ogx" ],
    "application/omdoc+xml": [ "omdoc" ],
    "application/onenote": [ "onetoc", "onetoc2", "onetmp", "onepkg" ],
    "application/oxps": [ "oxps" ],
    "application/patch-ops-error+xml": [ "xer" ],
    "application/pdf": [ "pdf" ],
    "application/pgp-encrypted": [ "pgp" ],
    "application/pgp-signature": [ "asc", "sig" ],
    "application/pics-rules": [ "prf" ],
    "application/pkcs10": [ "p10" ],
    "application/pkcs7-mime": [ "p7m", "p7c" ],
    "application/pkcs7-signature": [ "p7s" ],
    "application/pkcs8": [ "p8" ],
    "application/pkix-attr-cert": [ "ac" ],
    "application/pkix-cert": [ "cer" ],
    "application/pkix-crl": [ "crl" ],
    "application/pkix-pkipath": [ "pkipath" ],
    "application/pkixcmp": [ "pki" ],
    "application/pls+xml": [ "pls" ],
    "application/postscript": [ "ai", "eps", "ps" ],
    "application/prs.cww": [ "cww" ],
    "application/pskc+xml": [ "pskcxml" ],
    "application/raml+yaml": [ "raml" ],
    "application/rdf+xml": [ "rdf" ],
    "application/reginfo+xml": [ "rif" ],
    "application/relax-ng-compact-syntax": [ "rnc" ],
    "application/resource-lists+xml": [ "rl" ],
    "application/resource-lists-diff+xml": [ "rld" ],
    "application/rls-services+xml": [ "rs" ],
    "application/rpki-ghostbusters": [ "gbr" ],
    "application/rpki-manifest": [ "mft" ],
    "application/rpki-roa": [ "roa" ],
    "application/rsd+xml": [ "rsd" ],
    "application/rss+xml": [ "rss" ],
    "application/rtf": [ "rtf" ],
    "application/sbml+xml": [ "sbml" ],
    "application/scvp-cv-request": [ "scq" ],
    "application/scvp-cv-response": [ "scs" ],
    "application/scvp-vp-request": [ "spq" ],
    "application/scvp-vp-response": [ "spp" ],
    "application/sdp": [ "sdp" ],
    "application/set-payment-initiation": [ "setpay" ],
    "application/set-registration-initiation": [ "setreg" ],
    "application/shf+xml": [ "shf" ],
    "application/smil+xml": [ "smi", "smil" ],
    "application/sparql-query": [ "rq" ],
    "application/sparql-results+xml": [ "srx" ],
    "application/srgs": [ "gram" ],
    "application/srgs+xml": [ "grxml" ],
    "application/sru+xml": [ "sru" ],
    "application/ssdl+xml": [ "ssdl" ],
    "application/ssml+xml": [ "ssml" ],
    "application/tei+xml": [ "tei", "teicorpus" ],
    "application/thraud+xml": [ "tfi" ],
    "application/timestamped-data": [ "tsd" ],
    "application/vnd.3gpp.pic-bw-large": [ "plb" ],
    "application/vnd.3gpp.pic-bw-small": [ "psb" ],
    "application/vnd.3gpp.pic-bw-var": [ "pvb" ],
    "application/vnd.3gpp2.tcap": [ "tcap" ],
    "application/vnd.3m.post-it-notes": [ "pwn" ],
    "application/vnd.accpac.simply.aso": [ "aso" ],
    "application/vnd.accpac.simply.imp": [ "imp" ],
    "application/vnd.acucobol": [ "acu" ],
    "application/vnd.acucorp": [ "atc", "acutc" ],
    "application/vnd.adobe.air-application-installer-package+zip": [ "air" ],
    "application/vnd.adobe.formscentral.fcdt": [ "fcdt" ],
    "application/vnd.adobe.fxp": [ "fxp", "fxpl" ],
    "application/vnd.adobe.xdp+xml": [ "xdp" ],
    "application/vnd.adobe.xfdf": [ "xfdf" ],
    "application/vnd.ahead.space": [ "ahead" ],
    "application/vnd.airzip.filesecure.azf": [ "azf" ],
    "application/vnd.airzip.filesecure.azs": [ "azs" ],
    "application/vnd.amazon.ebook": [ "azw" ],
    "application/vnd.americandynamics.acc": [ "acc" ],
    "application/vnd.amiga.ami": [ "ami" ],
    "application/vnd.android.package-archive": [ "apk" ],
    "application/vnd.anser-web-certificate-issue-initiation": [ "cii" ],
    "application/vnd.anser-web-funds-transfer-initiation": [ "fti" ],
    "application/vnd.antix.game-component": [ "atx" ],
    "application/vnd.apple.installer+xml": [ "mpkg" ],
    "application/vnd.apple.mpegurl": [ "m3u8" ],
    "application/vnd.apple.pkpass": [ "pkpass" ],
    "application/vnd.aristanetworks.swi": [ "swi" ],
    "application/vnd.astraea-software.iota": [ "iota" ],
    "application/vnd.audiograph": [ "aep" ],
    "application/vnd.blueice.multipass": [ "mpm" ],
    "application/vnd.bmi": [ "bmi" ],
    "application/vnd.businessobjects": [ "rep" ],
    "application/vnd.chemdraw+xml": [ "cdxml" ],
    "application/vnd.chipnuts.karaoke-mmd": [ "mmd" ],
    "application/vnd.cinderella": [ "cdy" ],
    "application/vnd.claymore": [ "cla" ],
    "application/vnd.cloanto.rp9": [ "rp9" ],
    "application/vnd.clonk.c4group": [ "c4g", "c4d", "c4f", "c4p", "c4u" ],
    "application/vnd.cluetrust.cartomobile-config": [ "c11amc" ],
    "application/vnd.cluetrust.cartomobile-config-pkg": [ "c11amz" ],
    "application/vnd.commonspace": [ "csp" ],
    "application/vnd.contact.cmsg": [ "cdbcmsg" ],
    "application/vnd.cosmocaller": [ "cmc" ],
    "application/vnd.crick.clicker": [ "clkx" ],
    "application/vnd.crick.clicker.keyboard": [ "clkk" ],
    "application/vnd.crick.clicker.palette": [ "clkp" ],
    "application/vnd.crick.clicker.template": [ "clkt" ],
    "application/vnd.crick.clicker.wordbank": [ "clkw" ],
    "application/vnd.criticaltools.wbs+xml": [ "wbs" ],
    "application/vnd.ctc-posml": [ "pml" ],
    "application/vnd.cups-ppd": [ "ppd" ],
    "application/vnd.curl.car": [ "car" ],
    "application/vnd.curl.pcurl": [ "pcurl" ],
    "application/vnd.dart": [ "dart" ],
    "application/vnd.data-vision.rdz": [ "rdz" ],
    "application/vnd.dece.data": [ "uvf", "uvvf", "uvd", "uvvd" ],
    "application/vnd.dece.ttml+xml": [ "uvt", "uvvt" ],
    "application/vnd.dece.unspecified": [ "uvx", "uvvx" ],
    "application/vnd.dece.zip": [ "uvz", "uvvz" ],
    "application/vnd.denovo.fcselayout-link": [ "fe_launch" ],
    "application/vnd.dna": [ "dna" ],
    "application/vnd.dolby.mlp": [ "mlp" ],
    "application/vnd.dpgraph": [ "dpg" ],
    "application/vnd.dreamfactory": [ "dfac" ],
    "application/vnd.ds-keypoint": [ "kpxx" ],
    "application/vnd.dvb.ait": [ "ait" ],
    "application/vnd.dvb.service": [ "svc" ],
    "application/vnd.dynageo": [ "geo" ],
    "application/vnd.ecowin.chart": [ "mag" ],
    "application/vnd.enliven": [ "nml" ],
    "application/vnd.epson.esf": [ "esf" ],
    "application/vnd.epson.msf": [ "msf" ],
    "application/vnd.epson.quickanime": [ "qam" ],
    "application/vnd.epson.salt": [ "slt" ],
    "application/vnd.epson.ssf": [ "ssf" ],
    "application/vnd.eszigno3+xml": [ "es3", "et3" ],
    "application/vnd.ezpix-album": [ "ez2" ],
    "application/vnd.ezpix-package": [ "ez3" ],
    "application/vnd.fdf": [ "fdf" ],
    "application/vnd.fdsn.mseed": [ "mseed" ],
    "application/vnd.fdsn.seed": [ "seed", "dataless" ],
    "application/vnd.flographit": [ "gph" ],
    "application/vnd.fluxtime.clip": [ "ftc" ],
    "application/vnd.framemaker": [ "fm", "frame", "maker", "book" ],
    "application/vnd.frogans.fnc": [ "fnc" ],
    "application/vnd.frogans.ltf": [ "ltf" ],
    "application/vnd.fsc.weblaunch": [ "fsc" ],
    "application/vnd.fujitsu.oasys": [ "oas" ],
    "application/vnd.fujitsu.oasys2": [ "oa2" ],
    "application/vnd.fujitsu.oasys3": [ "oa3" ],
    "application/vnd.fujitsu.oasysgp": [ "fg5" ],
    "application/vnd.fujitsu.oasysprs": [ "bh2" ],
    "application/vnd.fujixerox.ddd": [ "ddd" ],
    "application/vnd.fujixerox.docuworks": [ "xdw" ],
    "application/vnd.fujixerox.docuworks.binder": [ "xbd" ],
    "application/vnd.fuzzysheet": [ "fzs" ],
    "application/vnd.genomatix.tuxedo": [ "txd" ],
    "application/vnd.geogebra.file": [ "ggb" ],
    "application/vnd.geogebra.tool": [ "ggt" ],
    "application/vnd.geometry-explorer": [ "gex", "gre" ],
    "application/vnd.geonext": [ "gxt" ],
    "application/vnd.geoplan": [ "g2w" ],
    "application/vnd.geospace": [ "g3w" ],
    "application/vnd.gmx": [ "gmx" ],
    "application/vnd.google-apps.document": [ "gdoc" ],
    "application/vnd.google-apps.presentation": [ "gslides" ],
    "application/vnd.google-apps.spreadsheet": [ "gsheet" ],
    "application/vnd.google-earth.kml+xml": [ "kml" ],
    "application/vnd.google-earth.kmz": [ "kmz" ],
    "application/vnd.grafeq": [ "gqf", "gqs" ],
    "application/vnd.groove-account": [ "gac" ],
    "application/vnd.groove-help": [ "ghf" ],
    "application/vnd.groove-identity-message": [ "gim" ],
    "application/vnd.groove-injector": [ "grv" ],
    "application/vnd.groove-tool-message": [ "gtm" ],
    "application/vnd.groove-tool-template": [ "tpl" ],
    "application/vnd.groove-vcard": [ "vcg" ],
    "application/vnd.hal+xml": [ "hal" ],
    "application/vnd.handheld-entertainment+xml": [ "zmm" ],
    "application/vnd.hbci": [ "hbci" ],
    "application/vnd.hhe.lesson-player": [ "les" ],
    "application/vnd.hp-hpgl": [ "hpgl" ],
    "application/vnd.hp-hpid": [ "hpid" ],
    "application/vnd.hp-hps": [ "hps" ],
    "application/vnd.hp-jlyt": [ "jlt" ],
    "application/vnd.hp-pcl": [ "pcl" ],
    "application/vnd.hp-pclxl": [ "pclxl" ],
    "application/vnd.hydrostatix.sof-data": [ "sfd-hdstx" ],
    "application/vnd.ibm.minipay": [ "mpy" ],
    "application/vnd.ibm.modcap": [ "afp", "listafp", "list3820" ],
    "application/vnd.ibm.rights-management": [ "irm" ],
    "application/vnd.ibm.secure-container": [ "sc" ],
    "application/vnd.iccprofile": [ "icc", "icm" ],
    "application/vnd.igloader": [ "igl" ],
    "application/vnd.immervision-ivp": [ "ivp" ],
    "application/vnd.immervision-ivu": [ "ivu" ],
    "application/vnd.insors.igm": [ "igm" ],
    "application/vnd.intercon.formnet": [ "xpw", "xpx" ],
    "application/vnd.intergeo": [ "i2g" ],
    "application/vnd.intu.qbo": [ "qbo" ],
    "application/vnd.intu.qfx": [ "qfx" ],
    "application/vnd.ipunplugged.rcprofile": [ "rcprofile" ],
    "application/vnd.irepository.package+xml": [ "irp" ],
    "application/vnd.is-xpr": [ "xpr" ],
    "application/vnd.isac.fcs": [ "fcs" ],
    "application/vnd.jam": [ "jam" ],
    "application/vnd.jcp.javame.midlet-rms": [ "rms" ],
    "application/vnd.jisp": [ "jisp" ],
    "application/vnd.joost.joda-archive": [ "joda" ],
    "application/vnd.kahootz": [ "ktz", "ktr" ],
    "application/vnd.kde.karbon": [ "karbon" ],
    "application/vnd.kde.kchart": [ "chrt" ],
    "application/vnd.kde.kformula": [ "kfo" ],
    "application/vnd.kde.kivio": [ "flw" ],
    "application/vnd.kde.kontour": [ "kon" ],
    "application/vnd.kde.kpresenter": [ "kpr", "kpt" ],
    "application/vnd.kde.kspread": [ "ksp" ],
    "application/vnd.kde.kword": [ "kwd", "kwt" ],
    "application/vnd.kenameaapp": [ "htke" ],
    "application/vnd.kidspiration": [ "kia" ],
    "application/vnd.kinar": [ "kne", "knp" ],
    "application/vnd.koan": [ "skp", "skd", "skt", "skm" ],
    "application/vnd.kodak-descriptor": [ "sse" ],
    "application/vnd.las.las+xml": [ "lasxml" ],
    "application/vnd.llamagraphics.life-balance.desktop": [ "lbd" ],
    "application/vnd.llamagraphics.life-balance.exchange+xml": [ "lbe" ],
    "application/vnd.lotus-1-2-3": [ "123" ],
    "application/vnd.lotus-approach": [ "apr" ],
    "application/vnd.lotus-freelance": [ "pre" ],
    "application/vnd.lotus-notes": [ "nsf" ],
    "application/vnd.lotus-organizer": [ "org" ],
    "application/vnd.lotus-screencam": [ "scm" ],
    "application/vnd.lotus-wordpro": [ "lwp" ],
    "application/vnd.macports.portpkg": [ "portpkg" ],
    "application/vnd.mcd": [ "mcd" ],
    "application/vnd.medcalcdata": [ "mc1" ],
    "application/vnd.mediastation.cdkey": [ "cdkey" ],
    "application/vnd.mfer": [ "mwf" ],
    "application/vnd.mfmp": [ "mfm" ],
    "application/vnd.micrografx.flo": [ "flo" ],
    "application/vnd.micrografx.igx": [ "igx" ],
    "application/vnd.mif": [ "mif" ],
    "application/vnd.mobius.daf": [ "daf" ],
    "application/vnd.mobius.dis": [ "dis" ],
    "application/vnd.mobius.mbk": [ "mbk" ],
    "application/vnd.mobius.mqy": [ "mqy" ],
    "application/vnd.mobius.msl": [ "msl" ],
    "application/vnd.mobius.plc": [ "plc" ],
    "application/vnd.mobius.txf": [ "txf" ],
    "application/vnd.mophun.application": [ "mpn" ],
    "application/vnd.mophun.certificate": [ "mpc" ],
    "application/vnd.mozilla.xul+xml": [ "xul" ],
    "application/vnd.ms-artgalry": [ "cil" ],
    "application/vnd.ms-cab-compressed": [ "cab" ],
    "application/vnd.ms-excel": [ "xls", "xlm", "xla", "xlc", "xlt", "xlw" ],
    "application/vnd.ms-excel.addin.macroenabled.12": [ "xlam" ],
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": [ "xlsb" ],
    "application/vnd.ms-excel.sheet.macroenabled.12": [ "xlsm" ],
    "application/vnd.ms-excel.template.macroenabled.12": [ "xltm" ],
    "application/vnd.ms-fontobject": [ "eot" ],
    "application/vnd.ms-htmlhelp": [ "chm" ],
    "application/vnd.ms-ims": [ "ims" ],
    "application/vnd.ms-lrm": [ "lrm" ],
    "application/vnd.ms-officetheme": [ "thmx" ],
    "application/vnd.ms-outlook": [ "msg" ],
    "application/vnd.ms-pki.seccat": [ "cat" ],
    "application/vnd.ms-pki.stl": [ "stl" ],
    "application/vnd.ms-powerpoint": [ "ppt", "pps", "pot" ],
    "application/vnd.ms-powerpoint.addin.macroenabled.12": [ "ppam" ],
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": [ "pptm" ],
    "application/vnd.ms-powerpoint.slide.macroenabled.12": [ "sldm" ],
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": [ "ppsm" ],
    "application/vnd.ms-powerpoint.template.macroenabled.12": [ "potm" ],
    "application/vnd.ms-project": [ "mpp", "mpt" ],
    "application/vnd.ms-word.document.macroenabled.12": [ "docm" ],
    "application/vnd.ms-word.template.macroenabled.12": [ "dotm" ],
    "application/vnd.ms-works": [ "wps", "wks", "wcm", "wdb" ],
    "application/vnd.ms-wpl": [ "wpl" ],
    "application/vnd.ms-xpsdocument": [ "xps" ],
    "application/vnd.mseq": [ "mseq" ],
    "application/vnd.musician": [ "mus" ],
    "application/vnd.muvee.style": [ "msty" ],
    "application/vnd.mynfc": [ "taglet" ],
    "application/vnd.neurolanguage.nlu": [ "nlu" ],
    "application/vnd.nitf": [ "ntf", "nitf" ],
    "application/vnd.noblenet-directory": [ "nnd" ],
    "application/vnd.noblenet-sealer": [ "nns" ],
    "application/vnd.noblenet-web": [ "nnw" ],
    "application/vnd.nokia.n-gage.data": [ "ngdat" ],
    "application/vnd.nokia.n-gage.symbian.install": [ "n-gage" ],
    "application/vnd.nokia.radio-preset": [ "rpst" ],
    "application/vnd.nokia.radio-presets": [ "rpss" ],
    "application/vnd.novadigm.edm": [ "edm" ],
    "application/vnd.novadigm.edx": [ "edx" ],
    "application/vnd.novadigm.ext": [ "ext" ],
    "application/vnd.oasis.opendocument.chart": [ "odc" ],
    "application/vnd.oasis.opendocument.chart-template": [ "otc" ],
    "application/vnd.oasis.opendocument.database": [ "odb" ],
    "application/vnd.oasis.opendocument.formula": [ "odf" ],
    "application/vnd.oasis.opendocument.formula-template": [ "odft" ],
    "application/vnd.oasis.opendocument.graphics": [ "odg" ],
    "application/vnd.oasis.opendocument.graphics-template": [ "otg" ],
    "application/vnd.oasis.opendocument.image": [ "odi" ],
    "application/vnd.oasis.opendocument.image-template": [ "oti" ],
    "application/vnd.oasis.opendocument.presentation": [ "odp" ],
    "application/vnd.oasis.opendocument.presentation-template": [ "otp" ],
    "application/vnd.oasis.opendocument.spreadsheet": [ "ods" ],
    "application/vnd.oasis.opendocument.spreadsheet-template": [ "ots" ],
    "application/vnd.oasis.opendocument.text": [ "odt" ],
    "application/vnd.oasis.opendocument.text-master": [ "odm" ],
    "application/vnd.oasis.opendocument.text-template": [ "ott" ],
    "application/vnd.oasis.opendocument.text-web": [ "oth" ],
    "application/vnd.olpc-sugar": [ "xo" ],
    "application/vnd.oma.dd2+xml": [ "dd2" ],
    "application/vnd.openofficeorg.extension": [ "oxt" ],
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": [ "pptx" ],
    "application/vnd.openxmlformats-officedocument.presentationml.slide": [ "sldx" ],
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": [ "ppsx" ],
    "application/vnd.openxmlformats-officedocument.presentationml.template": [ "potx" ],
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [ "xlsx" ],
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": [ "xltx" ],
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [ "docx" ],
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": [ "dotx" ],
    "application/vnd.osgeo.mapguide.package": [ "mgp" ],
    "application/vnd.osgi.dp": [ "dp" ],
    "application/vnd.osgi.subsystem": [ "esa" ],
    "application/vnd.palm": [ "pdb", "pqa", "oprc" ],
    "application/vnd.pawaafile": [ "paw" ],
    "application/vnd.pg.format": [ "str" ],
    "application/vnd.pg.osasli": [ "ei6" ],
    "application/vnd.picsel": [ "efif" ],
    "application/vnd.pmi.widget": [ "wg" ],
    "application/vnd.pocketlearn": [ "plf" ],
    "application/vnd.powerbuilder6": [ "pbd" ],
    "application/vnd.previewsystems.box": [ "box" ],
    "application/vnd.proteus.magazine": [ "mgz" ],
    "application/vnd.publishare-delta-tree": [ "qps" ],
    "application/vnd.pvi.ptid1": [ "ptid" ],
    "application/vnd.quark.quarkxpress": [ "qxd", "qxt", "qwd", "qwt", "qxl", "qxb" ],
    "application/vnd.realvnc.bed": [ "bed" ],
    "application/vnd.recordare.musicxml": [ "mxl" ],
    "application/vnd.recordare.musicxml+xml": [ "musicxml" ],
    "application/vnd.rig.cryptonote": [ "cryptonote" ],
    "application/vnd.rim.cod": [ "cod" ],
    "application/vnd.rn-realmedia": [ "rm" ],
    "application/vnd.rn-realmedia-vbr": [ "rmvb" ],
    "application/vnd.route66.link66+xml": [ "link66" ],
    "application/vnd.sailingtracker.track": [ "st" ],
    "application/vnd.seemail": [ "see" ],
    "application/vnd.sema": [ "sema" ],
    "application/vnd.semd": [ "semd" ],
    "application/vnd.semf": [ "semf" ],
    "application/vnd.shana.informed.formdata": [ "ifm" ],
    "application/vnd.shana.informed.formtemplate": [ "itp" ],
    "application/vnd.shana.informed.interchange": [ "iif" ],
    "application/vnd.shana.informed.package": [ "ipk" ],
    "application/vnd.simtech-mindmapper": [ "twd", "twds" ],
    "application/vnd.smaf": [ "mmf" ],
    "application/vnd.smart.teacher": [ "teacher" ],
    "application/vnd.solent.sdkm+xml": [ "sdkm", "sdkd" ],
    "application/vnd.spotfire.dxp": [ "dxp" ],
    "application/vnd.spotfire.sfs": [ "sfs" ],
    "application/vnd.stardivision.calc": [ "sdc" ],
    "application/vnd.stardivision.draw": [ "sda" ],
    "application/vnd.stardivision.impress": [ "sdd" ],
    "application/vnd.stardivision.math": [ "smf" ],
    "application/vnd.stardivision.writer": [ "sdw", "vor" ],
    "application/vnd.stardivision.writer-global": [ "sgl" ],
    "application/vnd.stepmania.package": [ "smzip" ],
    "application/vnd.stepmania.stepchart": [ "sm" ],
    "application/vnd.sun.wadl+xml": [ "wadl" ],
    "application/vnd.sun.xml.calc": [ "sxc" ],
    "application/vnd.sun.xml.calc.template": [ "stc" ],
    "application/vnd.sun.xml.draw": [ "sxd" ],
    "application/vnd.sun.xml.draw.template": [ "std" ],
    "application/vnd.sun.xml.impress": [ "sxi" ],
    "application/vnd.sun.xml.impress.template": [ "sti" ],
    "application/vnd.sun.xml.math": [ "sxm" ],
    "application/vnd.sun.xml.writer": [ "sxw" ],
    "application/vnd.sun.xml.writer.global": [ "sxg" ],
    "application/vnd.sun.xml.writer.template": [ "stw" ],
    "application/vnd.sus-calendar": [ "sus", "susp" ],
    "application/vnd.svd": [ "svd" ],
    "application/vnd.symbian.install": [ "sis", "sisx" ],
    "application/vnd.syncml+xml": [ "xsm" ],
    "application/vnd.syncml.dm+wbxml": [ "bdm" ],
    "application/vnd.syncml.dm+xml": [ "xdm" ],
    "application/vnd.tao.intent-module-archive": [ "tao" ],
    "application/vnd.tcpdump.pcap": [ "pcap", "cap", "dmp" ],
    "application/vnd.tmobile-livetv": [ "tmo" ],
    "application/vnd.trid.tpt": [ "tpt" ],
    "application/vnd.triscape.mxs": [ "mxs" ],
    "application/vnd.trueapp": [ "tra" ],
    "application/vnd.ufdl": [ "ufd", "ufdl" ],
    "application/vnd.uiq.theme": [ "utz" ],
    "application/vnd.umajin": [ "umj" ],
    "application/vnd.unity": [ "unityweb" ],
    "application/vnd.uoml+xml": [ "uoml" ],
    "application/vnd.vcx": [ "vcx" ],
    "application/vnd.visio": [ "vsd", "vst", "vss", "vsw" ],
    "application/vnd.visionary": [ "vis" ],
    "application/vnd.vsf": [ "vsf" ],
    "application/vnd.wap.wbxml": [ "wbxml" ],
    "application/vnd.wap.wmlc": [ "wmlc" ],
    "application/vnd.wap.wmlscriptc": [ "wmlsc" ],
    "application/vnd.webturbo": [ "wtb" ],
    "application/vnd.wolfram.player": [ "nbp" ],
    "application/vnd.wordperfect": [ "wpd" ],
    "application/vnd.wqd": [ "wqd" ],
    "application/vnd.wt.stf": [ "stf" ],
    "application/vnd.xara": [ "xar" ],
    "application/vnd.xfdl": [ "xfdl" ],
    "application/vnd.yamaha.hv-dic": [ "hvd" ],
    "application/vnd.yamaha.hv-script": [ "hvs" ],
    "application/vnd.yamaha.hv-voice": [ "hvp" ],
    "application/vnd.yamaha.openscoreformat": [ "osf" ],
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": [ "osfpvg" ],
    "application/vnd.yamaha.smaf-audio": [ "saf" ],
    "application/vnd.yamaha.smaf-phrase": [ "spf" ],
    "application/vnd.yellowriver-custom-menu": [ "cmp" ],
    "application/vnd.zul": [ "zir", "zirz" ],
    "application/vnd.zzazz.deck+xml": [ "zaz" ],
    "application/voicexml+xml": [ "vxml" ],
    "application/wasm": [ "wasm" ],
    "application/widget": [ "wgt" ],
    "application/winhlp": [ "hlp" ],
    "application/wsdl+xml": [ "wsdl" ],
    "application/wspolicy+xml": [ "wspolicy" ],
    "application/x-7z-compressed": [ "7z" ],
    "application/x-abiword": [ "abw" ],
    "application/x-ace-compressed": [ "ace" ],
    "application/x-apple-diskimage": [],
    "application/x-arj": [ "arj" ],
    "application/x-authorware-bin": [ "aab", "x32", "u32", "vox" ],
    "application/x-authorware-map": [ "aam" ],
    "application/x-authorware-seg": [ "aas" ],
    "application/x-bcpio": [ "bcpio" ],
    "application/x-bdoc": [],
    "application/x-bittorrent": [ "torrent" ],
    "application/x-blorb": [ "blb", "blorb" ],
    "application/x-bzip": [ "bz" ],
    "application/x-bzip2": [ "bz2", "boz" ],
    "application/x-cbr": [ "cbr", "cba", "cbt", "cbz", "cb7" ],
    "application/x-cdlink": [ "vcd" ],
    "application/x-cfs-compressed": [ "cfs" ],
    "application/x-chat": [ "chat" ],
    "application/x-chess-pgn": [ "pgn" ],
    "application/x-chrome-extension": [ "crx" ],
    "application/x-cocoa": [ "cco" ],
    "application/x-conference": [ "nsc" ],
    "application/x-cpio": [ "cpio" ],
    "application/x-csh": [ "csh" ],
    "application/x-debian-package": [ "udeb" ],
    "application/x-dgc-compressed": [ "dgc" ],
    "application/x-director": [ "dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa" ],
    "application/x-doom": [ "wad" ],
    "application/x-dtbncx+xml": [ "ncx" ],
    "application/x-dtbook+xml": [ "dtb" ],
    "application/x-dtbresource+xml": [ "res" ],
    "application/x-dvi": [ "dvi" ],
    "application/x-envoy": [ "evy" ],
    "application/x-eva": [ "eva" ],
    "application/x-font-bdf": [ "bdf" ],
    "application/x-font-ghostscript": [ "gsf" ],
    "application/x-font-linux-psf": [ "psf" ],
    "application/x-font-pcf": [ "pcf" ],
    "application/x-font-snf": [ "snf" ],
    "application/x-font-type1": [ "pfa", "pfb", "pfm", "afm" ],
    "application/x-freearc": [ "arc" ],
    "application/x-futuresplash": [ "spl" ],
    "application/x-gca-compressed": [ "gca" ],
    "application/x-glulx": [ "ulx" ],
    "application/x-gnumeric": [ "gnumeric" ],
    "application/x-gramps-xml": [ "gramps" ],
    "application/x-gtar": [ "gtar" ],
    "application/x-hdf": [ "hdf" ],
    "application/x-httpd-php": [ "php" ],
    "application/x-install-instructions": [ "install" ],
    "application/x-iso9660-image": [],
    "application/x-java-archive-diff": [ "jardiff" ],
    "application/x-java-jnlp-file": [ "jnlp" ],
    "application/x-latex": [ "latex" ],
    "application/x-lua-bytecode": [ "luac" ],
    "application/x-lzh-compressed": [ "lzh", "lha" ],
    "application/x-makeself": [ "run" ],
    "application/x-mie": [ "mie" ],
    "application/x-mobipocket-ebook": [ "prc", "mobi" ],
    "application/x-ms-application": [ "application" ],
    "application/x-ms-shortcut": [ "lnk" ],
    "application/x-ms-wmd": [ "wmd" ],
    "application/x-ms-wmz": [ "wmz" ],
    "application/x-ms-xbap": [ "xbap" ],
    "application/x-msaccess": [ "mdb" ],
    "application/x-msbinder": [ "obd" ],
    "application/x-mscardfile": [ "crd" ],
    "application/x-msclip": [ "clp" ],
    "application/x-msdos-program": [],
    "application/x-msdownload": [ "com", "bat" ],
    "application/x-msmediaview": [ "mvb", "m13", "m14" ],
    "application/x-msmetafile": [ "wmf", "emf", "emz" ],
    "application/x-msmoney": [ "mny" ],
    "application/x-mspublisher": [ "pub" ],
    "application/x-msschedule": [ "scd" ],
    "application/x-msterminal": [ "trm" ],
    "application/x-mswrite": [ "wri" ],
    "application/x-netcdf": [ "nc", "cdf" ],
    "application/x-ns-proxy-autoconfig": [ "pac" ],
    "application/x-nzb": [ "nzb" ],
    "application/x-perl": [ "pl", "pm" ],
    "application/x-pilot": [],
    "application/x-pkcs12": [ "p12", "pfx" ],
    "application/x-pkcs7-certificates": [ "p7b", "spc" ],
    "application/x-pkcs7-certreqresp": [ "p7r" ],
    "application/x-rar-compressed": [ "rar" ],
    "application/x-redhat-package-manager": [ "rpm" ],
    "application/x-research-info-systems": [ "ris" ],
    "application/x-sea": [ "sea" ],
    "application/x-sh": [ "sh" ],
    "application/x-shar": [ "shar" ],
    "application/x-shockwave-flash": [ "swf" ],
    "application/x-silverlight-app": [ "xap" ],
    "application/x-sql": [ "sql" ],
    "application/x-stuffit": [ "sit" ],
    "application/x-stuffitx": [ "sitx" ],
    "application/x-subrip": [ "srt" ],
    "application/x-sv4cpio": [ "sv4cpio" ],
    "application/x-sv4crc": [ "sv4crc" ],
    "application/x-t3vm-image": [ "t3" ],
    "application/x-tads": [ "gam" ],
    "application/x-tar": [ "tar" ],
    "application/x-tcl": [ "tcl", "tk" ],
    "application/x-tex": [ "tex" ],
    "application/x-tex-tfm": [ "tfm" ],
    "application/x-texinfo": [ "texinfo", "texi" ],
    "application/x-tgif": [ "obj" ],
    "application/x-ustar": [ "ustar" ],
    "application/x-virtualbox-hdd": [ "hdd" ],
    "application/x-virtualbox-ova": [ "ova" ],
    "application/x-virtualbox-ovf": [ "ovf" ],
    "application/x-virtualbox-vbox": [ "vbox" ],
    "application/x-virtualbox-vbox-extpack": [ "vbox-extpack" ],
    "application/x-virtualbox-vdi": [ "vdi" ],
    "application/x-virtualbox-vhd": [ "vhd" ],
    "application/x-virtualbox-vmdk": [ "vmdk" ],
    "application/x-wais-source": [ "src" ],
    "application/x-web-app-manifest+json": [ "webapp" ],
    "application/x-x509-ca-cert": [ "der", "crt", "pem" ],
    "application/x-xfig": [ "fig" ],
    "application/x-xliff+xml": [ "xlf" ],
    "application/x-xpinstall": [ "xpi" ],
    "application/x-xz": [ "xz" ],
    "application/x-zmachine": [ "z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8" ],
    "application/xaml+xml": [ "xaml" ],
    "application/xcap-diff+xml": [ "xdf" ],
    "application/xenc+xml": [ "xenc" ],
    "application/xhtml+xml": [ "xhtml", "xht" ],
    "application/xml": [ "xml", "xsl", "xsd", "rng" ],
    "application/xml-dtd": [ "dtd" ],
    "application/xop+xml": [ "xop" ],
    "application/xproc+xml": [ "xpl" ],
    "application/xslt+xml": [ "xslt" ],
    "application/xspf+xml": [ "xspf" ],
    "application/xv+xml": [ "mxml", "xhvml", "xvml", "xvm" ],
    "application/yang": [ "yang" ],
    "application/yin+xml": [ "yin" ],
    "application/zip": [ "zip" ],
    "audio/3gpp": [],
    "audio/adpcm": [ "adp" ],
    "audio/basic": [ "au", "snd" ],
    "audio/midi": [ "mid", "midi", "kar", "rmi" ],
    "audio/mp3": [],
    "audio/mp4": [ "m4a", "mp4a" ],
    "audio/mpeg": [ "mpga", "mp2", "mp2a", "mp3", "m2a", "m3a" ],
    "audio/ogg": [ "oga", "ogg", "spx" ],
    "audio/s3m": [ "s3m" ],
    "audio/silk": [ "sil" ],
    "audio/vnd.dece.audio": [ "uva", "uvva" ],
    "audio/vnd.digital-winds": [ "eol" ],
    "audio/vnd.dra": [ "dra" ],
    "audio/vnd.dts": [ "dts" ],
    "audio/vnd.dts.hd": [ "dtshd" ],
    "audio/vnd.lucent.voice": [ "lvp" ],
    "audio/vnd.ms-playready.media.pya": [ "pya" ],
    "audio/vnd.nuera.ecelp4800": [ "ecelp4800" ],
    "audio/vnd.nuera.ecelp7470": [ "ecelp7470" ],
    "audio/vnd.nuera.ecelp9600": [ "ecelp9600" ],
    "audio/vnd.rip": [ "rip" ],
    "audio/wav": [ "wav" ],
    "audio/wave": [],
    "audio/webm": [ "weba" ],
    "audio/x-aac": [ "aac" ],
    "audio/x-aiff": [ "aif", "aiff", "aifc" ],
    "audio/x-caf": [ "caf" ],
    "audio/x-flac": [ "flac" ],
    "audio/x-m4a": [],
    "audio/x-matroska": [ "mka" ],
    "audio/x-mpegurl": [ "m3u" ],
    "audio/x-ms-wax": [ "wax" ],
    "audio/x-ms-wma": [ "wma" ],
    "audio/x-pn-realaudio": [ "ram", "ra" ],
    "audio/x-pn-realaudio-plugin": [ "rmp" ],
    "audio/x-realaudio": [],
    "audio/x-wav": [],
    "audio/xm": [ "xm" ],
    "chemical/x-cdx": [ "cdx" ],
    "chemical/x-cif": [ "cif" ],
    "chemical/x-cmdf": [ "cmdf" ],
    "chemical/x-cml": [ "cml" ],
    "chemical/x-csml": [ "csml" ],
    "chemical/x-xyz": [ "xyz" ],
    "font/collection": [ "ttc" ],
    "font/otf": [ "otf" ],
    "font/ttf": [ "ttf" ],
    "font/woff": [ "woff" ],
    "font/woff2": [ "woff2" ],
    "image/apng": [ "apng" ],
    "image/bmp": [ "bmp" ],
    "image/cgm": [ "cgm" ],
    "image/g3fax": [ "g3" ],
    "image/gif": [ "gif" ],
    "image/ief": [ "ief" ],
    "image/jp2": [ "jp2", "jpg2" ],
    "image/jpeg": [ "jpeg", "jpg", "jpe" ],
    "image/jpm": [ "jpm" ],
    "image/jpx": [ "jpx", "jpf" ],
    "image/ktx": [ "ktx" ],
    "image/png": [ "png" ],
    "image/prs.btif": [ "btif" ],
    "image/sgi": [ "sgi" ],
    "image/svg+xml": [ "svg", "svgz" ],
    "image/tiff": [ "tiff", "tif" ],
    "image/vnd.adobe.photoshop": [ "psd" ],
    "image/vnd.dece.graphic": [ "uvi", "uvvi", "uvg", "uvvg" ],
    "image/vnd.djvu": [ "djvu", "djv" ],
    "image/vnd.dvb.subtitle": [],
    "image/vnd.dwg": [ "dwg" ],
    "image/vnd.dxf": [ "dxf" ],
    "image/vnd.fastbidsheet": [ "fbs" ],
    "image/vnd.fpx": [ "fpx" ],
    "image/vnd.fst": [ "fst" ],
    "image/vnd.fujixerox.edmics-mmr": [ "mmr" ],
    "image/vnd.fujixerox.edmics-rlc": [ "rlc" ],
    "image/vnd.ms-modi": [ "mdi" ],
    "image/vnd.ms-photo": [ "wdp" ],
    "image/vnd.net-fpx": [ "npx" ],
    "image/vnd.wap.wbmp": [ "wbmp" ],
    "image/vnd.xiff": [ "xif" ],
    "image/webp": [ "webp" ],
    "image/x-3ds": [ "3ds" ],
    "image/x-cmu-raster": [ "ras" ],
    "image/x-cmx": [ "cmx" ],
    "image/x-freehand": [ "fh", "fhc", "fh4", "fh5", "fh7" ],
    "image/x-icon": [ "ico" ],
    "image/x-jng": [ "jng" ],
    "image/x-mrsid-image": [ "sid" ],
    "image/x-ms-bmp": [],
    "image/x-pcx": [ "pcx" ],
    "image/x-pict": [ "pic", "pct" ],
    "image/x-portable-anymap": [ "pnm" ],
    "image/x-portable-bitmap": [ "pbm" ],
    "image/x-portable-graymap": [ "pgm" ],
    "image/x-portable-pixmap": [ "ppm" ],
    "image/x-rgb": [ "rgb" ],
    "image/x-tga": [ "tga" ],
    "image/x-xbitmap": [ "xbm" ],
    "image/x-xpixmap": [ "xpm" ],
    "image/x-xwindowdump": [ "xwd" ],
    "message/rfc822": [ "eml", "mime" ],
    "model/gltf+json": [ "gltf" ],
    "model/gltf-binary": [ "glb" ],
    "model/iges": [ "igs", "iges" ],
    "model/mesh": [ "msh", "mesh", "silo" ],
    "model/vnd.collada+xml": [ "dae" ],
    "model/vnd.dwf": [ "dwf" ],
    "model/vnd.gdl": [ "gdl" ],
    "model/vnd.gtw": [ "gtw" ],
    "model/vnd.mts": [ "mts" ],
    "model/vnd.vtu": [ "vtu" ],
    "model/vrml": [ "wrl", "vrml" ],
    "model/x3d+binary": [ "x3db", "x3dbz" ],
    "model/x3d+vrml": [ "x3dv", "x3dvz" ],
    "model/x3d+xml": [ "x3d", "x3dz" ],
    "text/cache-manifest": [ "appcache", "manifest" ],
    "text/calendar": [ "ics", "ifb" ],
    "text/coffeescript": [ "coffee", "litcoffee" ],
    "text/css": [ "css" ],
    "text/csv": [ "csv" ],
    "text/hjson": [ "hjson" ],
    "text/html": [ "html", "htm", "shtml" ],
    "text/jade": [ "jade" ],
    "text/jsx": [ "jsx" ],
    "text/less": [ "less" ],
    "text/markdown": [ "markdown", "md" ],
    "text/mathml": [ "mml" ],
    "text/n3": [ "n3" ],
    "text/plain": [ "txt", "text", "conf", "def", "list", "log", "in", "ini" ],
    "text/prs.lines.tag": [ "dsc" ],
    "text/richtext": [ "rtx" ],
    "text/rtf": [],
    "text/sgml": [ "sgml", "sgm" ],
    "text/slim": [ "slim", "slm" ],
    "text/stylus": [ "stylus", "styl" ],
    "text/tab-separated-values": [ "tsv" ],
    "text/troff": [ "t", "tr", "roff", "man", "me", "ms" ],
    "text/turtle": [ "ttl" ],
    "text/uri-list": [ "uri", "uris", "urls" ],
    "text/vcard": [ "vcard" ],
    "text/vnd.curl": [ "curl" ],
    "text/vnd.curl.dcurl": [ "dcurl" ],
    "text/vnd.curl.mcurl": [ "mcurl" ],
    "text/vnd.curl.scurl": [ "scurl" ],
    "text/vnd.dvb.subtitle": [ "sub" ],
    "text/vnd.fly": [ "fly" ],
    "text/vnd.fmi.flexstor": [ "flx" ],
    "text/vnd.graphviz": [ "gv" ],
    "text/vnd.in3d.3dml": [ "3dml" ],
    "text/vnd.in3d.spot": [ "spot" ],
    "text/vnd.sun.j2me.app-descriptor": [ "jad" ],
    "text/vnd.wap.wml": [ "wml" ],
    "text/vnd.wap.wmlscript": [ "wmls" ],
    "text/vtt": [ "vtt" ],
    "text/x-asm": [ "s", "asm" ],
    "text/x-c": [ "c", "cc", "cxx", "cpp", "h", "hh", "dic" ],
    "text/x-component": [ "htc" ],
    "text/x-fortran": [ "f", "for", "f77", "f90" ],
    "text/x-handlebars-template": [ "hbs" ],
    "text/x-java-source": [ "java" ],
    "text/x-lua": [ "lua" ],
    "text/x-markdown": [ "mkd" ],
    "text/x-nfo": [ "nfo" ],
    "text/x-opml": [ "opml" ],
    "text/x-org": [],
    "text/x-pascal": [ "p", "pas" ],
    "text/x-processing": [ "pde" ],
    "text/x-sass": [ "sass" ],
    "text/x-scss": [ "scss" ],
    "text/x-setext": [ "etx" ],
    "text/x-sfv": [ "sfv" ],
    "text/x-suse-ymp": [ "ymp" ],
    "text/x-uuencode": [ "uu" ],
    "text/x-vcalendar": [ "vcs" ],
    "text/x-vcard": [ "vcf" ],
    "text/xml": [],
    "text/yaml": [ "yaml", "yml" ],
    "video/3gpp": [ "3gp", "3gpp" ],
    "video/3gpp2": [ "3g2" ],
    "video/h261": [ "h261" ],
    "video/h263": [ "h263" ],
    "video/h264": [ "h264" ],
    "video/jpeg": [ "jpgv" ],
    "video/jpm": [ "jpgm" ],
    "video/mj2": [ "mj2", "mjp2" ],
    "video/mp2t": [ "ts" ],
    "video/mp4": [ "mp4", "mp4v", "mpg4" ],
    "video/mpeg": [ "mpeg", "mpg", "mpe", "m1v", "m2v" ],
    "video/ogg": [ "ogv" ],
    "video/quicktime": [ "qt", "mov" ],
    "video/vnd.dece.hd": [ "uvh", "uvvh" ],
    "video/vnd.dece.mobile": [ "uvm", "uvvm" ],
    "video/vnd.dece.pd": [ "uvp", "uvvp" ],
    "video/vnd.dece.sd": [ "uvs", "uvvs" ],
    "video/vnd.dece.video": [ "uvv", "uvvv" ],
    "video/vnd.dvb.file": [ "dvb" ],
    "video/vnd.fvt": [ "fvt" ],
    "video/vnd.mpegurl": [ "mxu", "m4u" ],
    "video/vnd.ms-playready.media.pyv": [ "pyv" ],
    "video/vnd.uvvu.mp4": [ "uvu", "uvvu" ],
    "video/vnd.vivo": [ "viv" ],
    "video/webm": [ "webm" ],
    "video/x-f4v": [ "f4v" ],
    "video/x-fli": [ "fli" ],
    "video/x-flv": [ "flv" ],
    "video/x-m4v": [ "m4v" ],
    "video/x-matroska": [ "mkv", "mk3d", "mks" ],
    "video/x-mng": [ "mng" ],
    "video/x-ms-asf": [ "asf", "asx" ],
    "video/x-ms-vob": [ "vob" ],
    "video/x-ms-wm": [ "wm" ],
    "video/x-ms-wmv": [ "wmv" ],
    "video/x-ms-wmx": [ "wmx" ],
    "video/x-ms-wvx": [ "wvx" ],
    "video/x-msvideo": [ "avi" ],
    "video/x-sgi-movie": [ "movie" ],
    "video/x-smv": [ "smv" ],
    "x-conference/x-cooltalk": [ "ice" ]
}), mime$1.default_type = mime$1.lookup("bin"), mime$1.Mime = Mime, mime$1.charsets = {
    lookup: function(mimeType, fallback) {
        return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
    }
};

var mime_1 = mime$1, Buffer$3 = require$$3__default$1.default.Buffer, HEADER = Buffer.from([ 66, 77, 70, 3 ]), fs = require$$1__default.default, url = require$$2__default.default, request = phin_compiled, mime = mime_1, noop = function() {}, loadBmfont = function loadFont(opt, cb) {
    cb = "function" == typeof cb ? cb : noop, "string" == typeof opt ? opt = {
        uri: opt,
        url: opt
    } : opt || (opt = {});
    var file = opt.uri || opt.url;
    function handleData(err, data) {
        if (err) return cb(err);
        !function parseFont(file, data, cb) {
            var result, binary, buf;
            ("string" == typeof (buf = data) ? "BMF" === buf.substring(0, 3) : buf.length > 4 && function(a, b) {
                if (Buffer$3.isBuffer(a) && Buffer$3.isBuffer(b)) {
                    if ("function" == typeof a.equals) return a.equals(b);
                    if (a.length !== b.length) return !1;
                    for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
                    return !0;
                }
            }(buf.slice(0, 4), HEADER)) ? ("string" == typeof data && (data = Buffer.from(data, "binary")), 
            binary = !0) : data = data.toString().trim();
            try {
                result = binary ? function readBMFontBinary(buf) {
                    if (buf.length < 6) throw new Error("invalid buffer length for BMFont");
                    var header = HEADER$1.every((function(byte, i) {
                        return buf.readUInt8(i) === byte;
                    }));
                    if (!header) throw new Error("BMFont missing BMF byte header");
                    var i = 3;
                    if (buf.readUInt8(i++) > 3) throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
                    for (var target = {
                        kernings: [],
                        chars: []
                    }, b = 0; b < 5; b++) i += readBlock(target, buf, i);
                    return target;
                }(data) : /json/.test(mime.lookup(file)) || "{" === data.charAt(0) ? JSON.parse(data) : /xml/.test(mime.lookup(file)) || "<" === data.charAt(0) ? function parseBMFontXML(data) {
                    data = data.toString().trim();
                    var output = {
                        pages: [],
                        chars: [],
                        kernings: []
                    };
                    return xml2js.parseString(data, (function(err, result) {
                        if (err) throw err;
                        if (!result.font) throw "XML bitmap font doesn't have <font> root";
                        result = result.font, output.common = parseAttributes(result.common[0].$), output.info = parseAttributes(result.info[0].$);
                        for (var i = 0; i < result.pages.length; i++) {
                            var p = result.pages[i].page[0].$;
                            if (void 0 === p.id) throw new Error("malformed file -- needs page id=N");
                            if ("string" != typeof p.file) throw new Error('malformed file -- needs page file="path"');
                            output.pages[parseInt(p.id, 10)] = p.file;
                        }
                        if (result.chars) {
                            var chrArray = result.chars[0].char || [];
                            for (i = 0; i < chrArray.length; i++) output.chars.push(parseAttributes(chrArray[i].$));
                        }
                        if (result.kernings) {
                            var kernArray = result.kernings[0].kerning || [];
                            for (i = 0; i < kernArray.length; i++) output.kernings.push(parseAttributes(kernArray[i].$));
                        }
                    })), output;
                }(data) : function parseBMFontAscii(data) {
                    if (!data) throw new Error("no data provided");
                    var output = {
                        pages: [],
                        chars: [],
                        kernings: []
                    }, lines = (data = data.toString().trim()).split(/\r\n?|\n/g);
                    if (0 === lines.length) throw new Error("no data in BMFont file");
                    for (var i = 0; i < lines.length; i++) {
                        var lineData = splitLine(lines[i], i);
                        if (lineData) if ("page" === lineData.key) {
                            if ("number" != typeof lineData.data.id) throw new Error("malformed file at line " + i + " -- needs page id=N");
                            if ("string" != typeof lineData.data.file) throw new Error("malformed file at line " + i + ' -- needs page file="path"');
                            output.pages[lineData.data.id] = lineData.data.file;
                        } else "chars" === lineData.key || "kernings" === lineData.key || ("char" === lineData.key ? output.chars.push(lineData.data) : "kerning" === lineData.key ? output.kernings.push(lineData.data) : output[lineData.key] = lineData.data);
                    }
                    return output;
                }(data);
            } catch (e) {
                cb(e), cb = noop;
            }
            cb(null, result);
        }(file, data.body || data, cb);
    }
    url.parse(file).host ? request(opt, handleData) : fs.readFile(file, opt, handleData);
}, measureText$1 = {};

function measureText(font, text) {
    for (var x = 0, i = 0; i < text.length; i++) if (font.chars[text[i]]) {
        var kerning = font.kernings[text[i]] && font.kernings[text[i]][text[i + 1]] ? font.kernings[text[i]][text[i + 1]] : 0;
        x += (font.chars[text[i]].xadvance || 0) + kerning;
    }
    return x;
}

Object.defineProperty(measureText$1, "__esModule", {
    value: !0
}), measureText$1.measureText = measureText, measureText$1.measureTextHeight = function measureTextHeight(font, text, maxWidth) {
    for (var words = text.split(" "), line = "", textTotalHeight = font.common.lineHeight, n = 0; n < words.length; n++) {
        var testLine = line + words[n] + " ";
        measureText(font, testLine) > maxWidth && n > 0 ? (textTotalHeight += font.common.lineHeight, 
        line = words[n] + " ") : line = testLine;
    }
    return textTotalHeight;
}, function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _typeof2 = _interopRequireDefault(_typeof$1.exports), _toConsumableArray2 = _interopRequireDefault(toConsumableArray.exports), _path = _interopRequireDefault(require$$0__default.default), _loadBmfont = _interopRequireDefault(loadBmfont), _utils = es$s, _measureText = measureText$1;
    function drawCharacter(image, font, x, y, _char) {
        if (_char.width > 0 && _char.height > 0) {
            var characterPage = font.pages[_char.page];
            image.blit(characterPage, x + _char.xoffset, y + _char.yoffset, _char.x, _char.y, _char.width, _char.height);
        }
        return image;
    }
    function printText(font, x, y, text, defaultCharWidth) {
        for (var i = 0; i < text.length; i++) {
            var _char2;
            _char2 = font.chars[text[i]] ? text[i] : /\s/.test(text[i]) ? "" : "?";
            var fontChar = font.chars[_char2] || {}, fontKerning = font.kernings[_char2];
            drawCharacter(this, font, x, y, fontChar || {}), x += (fontKerning && fontKerning[text[i + 1]] ? fontKerning[text[i + 1]] : 0) + (fontChar.xadvance || defaultCharWidth);
        }
    }
    var dir = process.env.DIRNAME || "".concat(__dirname, "/../");
    exports.default = function _default() {
        return {
            constants: {
                measureText: _measureText.measureText,
                measureTextHeight: _measureText.measureTextHeight,
                FONT_SANS_8_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt"),
                FONT_SANS_10_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt"),
                FONT_SANS_12_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt"),
                FONT_SANS_14_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt"),
                FONT_SANS_16_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt"),
                FONT_SANS_32_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt"),
                FONT_SANS_64_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt"),
                FONT_SANS_128_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt"),
                FONT_SANS_8_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt"),
                FONT_SANS_16_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt"),
                FONT_SANS_32_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt"),
                FONT_SANS_64_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt"),
                FONT_SANS_128_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt"),
                loadFont: function loadFont(file, cb) {
                    var _this = this;
                    return "string" != typeof file ? _utils.throwError.call(this, "file must be a string", cb) : new Promise((function(resolve, reject) {
                        cb = cb || function(err, font) {
                            err ? reject(err) : resolve(font);
                        }, (0, _loadBmfont.default)(file, (function(err, font) {
                            var chars = {}, kernings = {};
                            if (err) return _utils.throwError.call(_this, err, cb);
                            for (var i = 0; i < font.chars.length; i++) chars[String.fromCharCode(font.chars[i].id)] = font.chars[i];
                            for (var _i = 0; _i < font.kernings.length; _i++) {
                                var firstString = String.fromCharCode(font.kernings[_i].first);
                                kernings[firstString] = kernings[firstString] || {}, kernings[firstString][String.fromCharCode(font.kernings[_i].second)] = font.kernings[_i].amount;
                            }
                            (function loadPages(Jimp, dir, pages) {
                                var newPages = pages.map((function(page) {
                                    return Jimp.read(dir + "/" + page);
                                }));
                                return Promise.all(newPages);
                            })(_this, _path.default.dirname(file), font.pages).then((function(pages) {
                                cb(null, {
                                    chars,
                                    kernings,
                                    pages,
                                    common: font.common,
                                    info: font.info
                                });
                            }));
                        }));
                    }));
                }
            },
            class: {
                print: function print(font, x, y, text, maxWidth, maxHeight, cb) {
                    var alignmentX, alignmentY, _this2 = this;
                    if ("function" == typeof maxWidth && void 0 === cb && (cb = maxWidth, maxWidth = 1 / 0), 
                    void 0 === maxWidth && (maxWidth = 1 / 0), "function" == typeof maxHeight && void 0 === cb && (cb = maxHeight, 
                    maxHeight = 1 / 0), void 0 === maxHeight && (maxHeight = 1 / 0), "object" !== (0, 
                    _typeof2.default)(font)) return _utils.throwError.call(this, "font must be a Jimp loadFont", cb);
                    if ("number" != typeof x || "number" != typeof y || "number" != typeof maxWidth) return _utils.throwError.call(this, "x, y and maxWidth must be numbers", cb);
                    if ("number" != typeof maxWidth) return _utils.throwError.call(this, "maxWidth must be a number", cb);
                    if ("number" != typeof maxHeight) return _utils.throwError.call(this, "maxHeight must be a number", cb);
                    "object" === (0, _typeof2.default)(text) && null !== text.text && void 0 !== text.text ? (alignmentX = text.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT, 
                    alignmentY = text.alignmentY || this.constructor.VERTICAL_ALIGN_TOP, text = text.text) : (alignmentX = this.constructor.HORIZONTAL_ALIGN_LEFT, 
                    alignmentY = this.constructor.VERTICAL_ALIGN_TOP, text = text.toString()), maxHeight !== 1 / 0 && alignmentY === this.constructor.VERTICAL_ALIGN_BOTTOM ? y += maxHeight - (0, 
                    _measureText.measureTextHeight)(font, text, maxWidth) : maxHeight !== 1 / 0 && alignmentY === this.constructor.VERTICAL_ALIGN_MIDDLE && (y += maxHeight / 2 - (0, 
                    _measureText.measureTextHeight)(font, text, maxWidth) / 2);
                    var defaultCharWidth = Object.entries(font.chars)[0][1].xadvance, _splitLines = function splitLines(font, text, maxWidth) {
                        var words = text.split(" "), lines = [], currentLine = [], longestLine = 0;
                        return words.forEach((function(word) {
                            var line = [].concat((0, _toConsumableArray2.default)(currentLine), [ word ]).join(" "), length = (0, 
                            _measureText.measureText)(font, line);
                            length <= maxWidth ? (length > longestLine && (longestLine = length), currentLine.push(word)) : (lines.push(currentLine), 
                            currentLine = [ word ]);
                        })), lines.push(currentLine), {
                            lines,
                            longestLine
                        };
                    }(font, text, maxWidth), lines = _splitLines.lines, longestLine = _splitLines.longestLine;
                    return lines.forEach((function(line) {
                        var lineString = line.join(" "), alignmentWidth = function xOffsetBasedOnAlignment(constants, font, line, maxWidth, alignment) {
                            return alignment === constants.HORIZONTAL_ALIGN_LEFT ? 0 : alignment === constants.HORIZONTAL_ALIGN_CENTER ? (maxWidth - (0, 
                            _measureText.measureText)(font, line)) / 2 : maxWidth - (0, _measureText.measureText)(font, line);
                        }(_this2.constructor, font, lineString, maxWidth, alignmentX);
                        printText.call(_this2, font, x + alignmentWidth, y, lineString, defaultCharWidth), 
                        y += font.common.lineHeight;
                    })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this, {
                        x: x + longestLine,
                        y
                    }), this;
                }
            }
        };
    };
}(es$5);

var es$4 = {};

function Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
    this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0), this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0), 
    this.targetWidth = Math.abs(Math.floor(targetWidth) || 0), this.targetHeight = Math.abs(Math.floor(targetHeight) || 0), 
    this.colorChannels = blendAlpha ? 4 : 3, this.interpolationPass = Boolean(interpolationPass), 
    this.resizeCallback = "function" == typeof resizeCallback ? resizeCallback : function() {}, 
    this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels, this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels, 
    this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels, 
    this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal, 
    this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight, 
    this.initialize();
}

Resize.prototype.initialize = function() {
    if (!(this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0)) throw new Error("Invalid settings specified for the resizer.");
    this.configurePasses();
}, Resize.prototype.configurePasses = function() {
    this.widthOriginal === this.targetWidth ? this.resizeWidth = this.bypassResizer : (this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth, 
    this.ratioWeightWidthPass < 1 && this.interpolationPass ? (this.initializeFirstPassBuffers(!0), 
    this.resizeWidth = 4 === this.colorChannels ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB) : (this.initializeFirstPassBuffers(!1), 
    this.resizeWidth = 4 === this.colorChannels ? this.resizeWidthRGBA : this.resizeWidthRGB)), 
    this.heightOriginal === this.targetHeight ? this.resizeHeight = this.bypassResizer : (this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight, 
    this.ratioWeightHeightPass < 1 && this.interpolationPass ? (this.initializeSecondPassBuffers(!0), 
    this.resizeHeight = this.resizeHeightInterpolated) : (this.initializeSecondPassBuffers(!1), 
    this.resizeHeight = 4 === this.colorChannels ? this.resizeHeightRGBA : this.resizeHeightRGB));
}, Resize.prototype._resizeWidthInterpolatedRGBChannels = function(buffer, fourthChannel) {
    var targetPosition, interpolationWidthSourceReadStop, channelsNum = fourthChannel ? 4 : 3, ratioWeight = this.ratioWeightWidthPass, outputBuffer = this.widthBuffer, weight = 0, finalOffset = 0, pixelOffset = 0, firstWeight = 0, secondWeight = 0;
    for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) for (finalOffset = targetPosition, 
    pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, 
    finalOffset += this.targetWidthMultipliedByChannels) outputBuffer[finalOffset] = buffer[pixelOffset], 
    outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1], outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2], 
    fourthChannel && (outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3]);
    for (weight -= 1 / 3, interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, 
    weight += ratioWeight) for (firstWeight = 1 - (secondWeight = weight % 1), finalOffset = targetPosition, 
    pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, 
    finalOffset += this.targetWidthMultipliedByChannels) outputBuffer[finalOffset + 0] = buffer[pixelOffset + 0] * firstWeight + buffer[pixelOffset + channelsNum + 0] * secondWeight, 
    outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1] * firstWeight + buffer[pixelOffset + channelsNum + 1] * secondWeight, 
    outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2] * firstWeight + buffer[pixelOffset + channelsNum + 2] * secondWeight, 
    fourthChannel && (outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3] * firstWeight + buffer[pixelOffset + channelsNum + 3] * secondWeight);
    for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) for (finalOffset = targetPosition, 
    pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, 
    finalOffset += this.targetWidthMultipliedByChannels) outputBuffer[finalOffset] = buffer[pixelOffset], 
    outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1], outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2], 
    fourthChannel && (outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3]);
    return outputBuffer;
}, Resize.prototype._resizeWidthRGBChannels = function(buffer, fourthChannel) {
    var channelsNum = fourthChannel ? 4 : 3, ratioWeight = this.ratioWeightWidthPass, ratioWeightDivisor = 1 / ratioWeight, nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1, nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1, output = this.outputWidthWorkBench, outputBuffer = this.widthBuffer, trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount, weight = 0, amountToNext = 0, actualPosition = 0, currentPosition = 0, line = 0, pixelOffset = 0, outputOffset = 0, multiplier = 1, r = 0, g = 0, b = 0, a = 0;
    do {
        for (line = 0; line < this.originalHeightMultipliedByChannels; ) output[line++] = 0, 
        output[line++] = 0, output[line++] = 0, fourthChannel && (output[line++] = 0, trustworthyColorsCount[line / channelsNum - 1] = 0);
        weight = ratioWeight;
        do {
            for (amountToNext = 1 + actualPosition - currentPosition, multiplier = Math.min(weight, amountToNext), 
            line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) r = buffer[pixelOffset], 
            g = buffer[++pixelOffset], b = buffer[++pixelOffset], a = fourthChannel ? buffer[++pixelOffset] : 255, 
            output[line++] += (a ? r : 0) * multiplier, output[line++] += (a ? g : 0) * multiplier, 
            output[line++] += (a ? b : 0) * multiplier, fourthChannel && (output[line++] += a * multiplier, 
            trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0);
            if (!(weight >= amountToNext)) {
                currentPosition += weight;
                break;
            }
            currentPosition = actualPosition += channelsNum, weight -= amountToNext;
        } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);
        for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1, 
        multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor, outputBuffer[pixelOffset] = output[line++] * multiplier, 
        outputBuffer[++pixelOffset] = output[line++] * multiplier, outputBuffer[++pixelOffset] = output[line++] * multiplier, 
        fourthChannel && (outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor);
        outputOffset += channelsNum;
    } while (outputOffset < this.targetWidthMultipliedByChannels);
    return outputBuffer;
}, Resize.prototype._resizeHeightRGBChannels = function(buffer, fourthChannel) {
    var ratioWeight = this.ratioWeightHeightPass, ratioWeightDivisor = 1 / ratioWeight, output = this.outputHeightWorkBench, outputBuffer = this.heightBuffer, trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount, weight = 0, amountToNext = 0, actualPosition = 0, currentPosition = 0, pixelOffset = 0, outputOffset = 0, caret = 0, multiplier = 1, r = 0, g = 0, b = 0, a = 0;
    do {
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) output[pixelOffset++] = 0, 
        output[pixelOffset++] = 0, output[pixelOffset++] = 0, fourthChannel && (output[pixelOffset++] = 0, 
        trustworthyColorsCount[pixelOffset / 4 - 1] = 0);
        weight = ratioWeight;
        do {
            for (amountToNext = 1 + actualPosition - currentPosition, multiplier = Math.min(weight, amountToNext), 
            caret = actualPosition, pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) r = buffer[caret++], 
            g = buffer[caret++], b = buffer[caret++], a = fourthChannel ? buffer[caret++] : 255, 
            output[pixelOffset++] += (a ? r : 0) * multiplier, output[pixelOffset++] += (a ? g : 0) * multiplier, 
            output[pixelOffset++] += (a ? b : 0) * multiplier, fourthChannel && (output[pixelOffset++] += a * multiplier, 
            trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0);
            if (!(weight >= amountToNext)) {
                currentPosition += weight;
                break;
            }
            currentPosition = actualPosition = caret, weight -= amountToNext;
        } while (weight > 0 && actualPosition < this.widthPassResultSize);
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1, 
        multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor, outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier), 
        outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier), outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier), 
        fourthChannel && (outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor));
    } while (outputOffset < this.finalResultSize);
    return outputBuffer;
}, Resize.prototype.resizeWidthInterpolatedRGB = function(buffer) {
    return this._resizeWidthInterpolatedRGBChannels(buffer, !1);
}, Resize.prototype.resizeWidthInterpolatedRGBA = function(buffer) {
    return this._resizeWidthInterpolatedRGBChannels(buffer, !0);
}, Resize.prototype.resizeWidthRGB = function(buffer) {
    return this._resizeWidthRGBChannels(buffer, !1);
}, Resize.prototype.resizeWidthRGBA = function(buffer) {
    return this._resizeWidthRGBChannels(buffer, !0);
}, Resize.prototype.resizeHeightInterpolated = function(buffer) {
    for (var interpolationHeightSourceReadStop, ratioWeight = this.ratioWeightHeightPass, outputBuffer = this.heightBuffer, weight = 0, finalOffset = 0, pixelOffset = 0, pixelOffsetAccumulated = 0, pixelOffsetAccumulated2 = 0, firstWeight = 0, secondWeight = 0; weight < 1 / 3; weight += ratioWeight) for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);
    for (weight -= 1 / 3, interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) for (firstWeight = 1 - (secondWeight = weight % 1), 
    pixelOffsetAccumulated2 = (pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels) + this.targetWidthMultipliedByChannels, 
    pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight + buffer[pixelOffsetAccumulated2++] * secondWeight);
    for (;finalOffset < this.finalResultSize; ) for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);
    return outputBuffer;
}, Resize.prototype.resizeHeightRGB = function(buffer) {
    return this._resizeHeightRGBChannels(buffer, !1);
}, Resize.prototype.resizeHeightRGBA = function(buffer) {
    return this._resizeHeightRGBChannels(buffer, !0);
}, Resize.prototype.resize = function(buffer) {
    this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));
}, Resize.prototype.bypassResizer = function(buffer) {
    return buffer;
}, Resize.prototype.initializeFirstPassBuffers = function(BILINEARAlgo) {
    this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize), BILINEARAlgo || (this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels), 
    this.colorChannels > 3 && (this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal)));
}, Resize.prototype.initializeSecondPassBuffers = function(BILINEARAlgo) {
    this.heightBuffer = this.generateUint8Buffer(this.finalResultSize), BILINEARAlgo || (this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels), 
    this.colorChannels > 3 && (this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth)));
}, Resize.prototype.generateFloatBuffer = function(bufferLength) {
    try {
        return new Float32Array(bufferLength);
    } catch (error) {
        return [];
    }
}, Resize.prototype.generateFloat64Buffer = function(bufferLength) {
    try {
        return new Float64Array(bufferLength);
    } catch (error) {
        return [];
    }
}, Resize.prototype.generateUint8Buffer = function(bufferLength) {
    try {
        return new Uint8Array(bufferLength);
    } catch (error) {
        return [];
    }
};

var resize$1 = Resize, resize2 = {
    nearestNeighbor: function nearestNeighbor(src, dst) {
        for (var wSrc = src.width, hSrc = src.height, wDst = dst.width, hDst = dst.height, bufSrc = src.data, bufDst = dst.data, i = 0; i < hDst; i++) for (var j = 0; j < wDst; j++) {
            var posDst = 4 * (i * wDst + j), posSrc = 4 * (Math.floor(i * hSrc / hDst) * wSrc + Math.floor(j * wSrc / wDst));
            bufDst[posDst++] = bufSrc[posSrc++], bufDst[posDst++] = bufSrc[posSrc++], bufDst[posDst++] = bufSrc[posSrc++], 
            bufDst[posDst++] = bufSrc[posSrc++];
        }
    },
    bilinearInterpolation: function bilinearInterpolation(src, dst) {
        for (var wSrc = src.width, hSrc = src.height, wDst = dst.width, hDst = dst.height, bufSrc = src.data, bufDst = dst.data, interpolate = function interpolate(k, kMin, vMin, kMax, vMax) {
            return kMin === kMax ? vMin : Math.round((k - kMin) * vMax + (kMax - k) * vMin);
        }, assign = function assign(pos, offset, x, xMin, xMax, y, yMin, yMax) {
            var posMin = 4 * (yMin * wSrc + xMin) + offset, posMax = 4 * (yMin * wSrc + xMax) + offset, vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
            if (yMax === yMin) bufDst[pos + offset] = vMin; else {
                posMax = 4 * (yMax * wSrc + xMax) + offset;
                var vMax = interpolate(x, xMin, bufSrc[posMin = 4 * (yMax * wSrc + xMin) + offset], xMax, bufSrc[posMax]);
                bufDst[pos + offset] = interpolate(y, yMin, vMin, yMax, vMax);
            }
        }, i = 0; i < hDst; i++) for (var j = 0; j < wDst; j++) {
            var posDst = 4 * (i * wDst + j), x = j * wSrc / wDst, xMin = Math.floor(x), xMax = Math.min(Math.ceil(x), wSrc - 1), y = i * hSrc / hDst, yMin = Math.floor(y), yMax = Math.min(Math.ceil(y), hSrc - 1);
            assign(posDst, 0, x, xMin, xMax, y, yMin, yMax), assign(posDst, 1, x, xMin, xMax, y, yMin, yMax), 
            assign(posDst, 2, x, xMin, xMax, y, yMin, yMax), assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);
        }
    },
    _interpolate2D: function _interpolate2D(src, dst, options, interpolate) {
        for (var bufSrc = src.data, bufDst = dst.data, wSrc = src.width, hSrc = src.height, wDst = dst.width, hDst = dst.height, wM = Math.max(1, Math.floor(wSrc / wDst)), wDst2 = wDst * wM, hM = Math.max(1, Math.floor(hSrc / hDst)), hDst2 = hDst * hM, buf1 = Buffer.alloc(wDst2 * hSrc * 4), i = 0; i < hSrc; i++) for (var j = 0; j < wDst2; j++) for (var x = j * (wSrc - 1) / wDst2, xPos = Math.floor(x), t = x - xPos, srcPos = 4 * (i * wSrc + xPos), buf1Pos = 4 * (i * wDst2 + j), k = 0; k < 4; k++) {
            var kPos = srcPos + k, x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4], x1 = bufSrc[kPos], x2 = bufSrc[kPos + 4], x3 = xPos < wSrc - 2 ? bufSrc[kPos + 8] : 2 * bufSrc[kPos + 4] - bufSrc[kPos];
            buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);
        }
        for (var buf2 = Buffer.alloc(wDst2 * hDst2 * 4), _i = 0; _i < hDst2; _i++) for (var _j = 0; _j < wDst2; _j++) for (var y = _i * (hSrc - 1) / hDst2, yPos = Math.floor(y), _t = y - yPos, _buf1Pos = 4 * (yPos * wDst2 + _j), buf2Pos = 4 * (_i * wDst2 + _j), _k = 0; _k < 4; _k++) {
            var _kPos = _buf1Pos + _k, y0 = yPos > 0 ? buf1[_kPos - 4 * wDst2] : 2 * buf1[_kPos] - buf1[_kPos + 4 * wDst2], y1 = buf1[_kPos], y2 = buf1[_kPos + 4 * wDst2], y3 = yPos < hSrc - 2 ? buf1[_kPos + 8 * wDst2] : 2 * buf1[_kPos + 4 * wDst2] - buf1[_kPos];
            buf2[buf2Pos + _k] = interpolate(y0, y1, y2, y3, _t);
        }
        var m = wM * hM;
        if (m > 1) for (var _i2 = 0; _i2 < hDst; _i2++) for (var _j2 = 0; _j2 < wDst; _j2++) {
            for (var r = 0, g = 0, b = 0, a = 0, realColors = 0, _y = 0; _y < hM; _y++) for (var _yPos = _i2 * hM + _y, _x = 0; _x < wM; _x++) {
                var xyPos = 4 * (_yPos * wDst2 + (_j2 * wM + _x)), pixelAlpha = buf2[xyPos + 3];
                pixelAlpha && (r += buf2[xyPos], g += buf2[xyPos + 1], b += buf2[xyPos + 2], realColors++), 
                a += pixelAlpha;
            }
            var pos = 4 * (_i2 * wDst + _j2);
            bufDst[pos] = realColors ? Math.round(r / realColors) : 0, bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0, 
            bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0, bufDst[pos + 3] = Math.round(a / m);
        } else dst.data = buf2;
    },
    bicubicInterpolation: function bicubicInterpolation(src, dst, options) {
        return this._interpolate2D(src, dst, options, (function interpolateCubic(x0, x1, x2, x3, t) {
            var a0 = x3 - x2 - x0 + x1, a1 = x0 - x1 - a0, a2 = x2 - x0, a3 = x1;
            return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));
        }));
    },
    hermiteInterpolation: function hermiteInterpolation(src, dst, options) {
        return this._interpolate2D(src, dst, options, (function interpolateHermite(x0, x1, x2, x3, t) {
            var c0 = x1, c1 = 0.5 * (x2 - x0), c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3, c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);
            return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));
        }));
    },
    bezierInterpolation: function bezierInterpolation(src, dst, options) {
        return this._interpolate2D(src, dst, options, (function interpolateBezier(x0, x1, x2, x3, t) {
            var nt = 1 - t, c0 = x1 * nt * nt * nt, c1 = 3 * (x1 + (x2 - x0) / 4) * nt * nt * t, c2 = 3 * (x2 - (x3 - x1) / 4) * nt * t * t, c3 = x2 * t * t * t;
            return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));
        }));
    }
};

!function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s, _resize = _interopRequireDefault(resize$1), _resize2 = _interopRequireDefault(resize2);
    exports.default = function _default() {
        return {
            constants: {
                RESIZE_NEAREST_NEIGHBOR: "nearestNeighbor",
                RESIZE_BILINEAR: "bilinearInterpolation",
                RESIZE_BICUBIC: "bicubicInterpolation",
                RESIZE_HERMITE: "hermiteInterpolation",
                RESIZE_BEZIER: "bezierInterpolation"
            },
            class: {
                resize: function resize(w, h, mode, cb) {
                    if ("number" != typeof w || "number" != typeof h) return _utils.throwError.call(this, "w and h must be numbers", cb);
                    if ("function" == typeof mode && void 0 === cb && (cb = mode, mode = null), w === this.constructor.AUTO && h === this.constructor.AUTO) return _utils.throwError.call(this, "w and h cannot both be set to auto", cb);
                    if (w === this.constructor.AUTO && (w = this.bitmap.width * (h / this.bitmap.height)), 
                    h === this.constructor.AUTO && (h = this.bitmap.height * (w / this.bitmap.width)), 
                    w < 0 || h < 0) return _utils.throwError.call(this, "w and h must be positive numbers", cb);
                    if (w = Math.round(w), h = Math.round(h), "function" == typeof _resize2.default[mode]) {
                        var dst = {
                            data: Buffer.alloc(w * h * 4),
                            width: w,
                            height: h
                        };
                        _resize2.default[mode](this.bitmap, dst), this.bitmap = dst;
                    } else {
                        var image = this, resize = new _resize.default(this.bitmap.width, this.bitmap.height, w, h, !0, !0, (function(buffer) {
                            image.bitmap.data = Buffer.from(buffer), image.bitmap.width = w, image.bitmap.height = h;
                        }));
                        resize.resize(this.bitmap.data);
                    }
                    return (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                }
            }
        };
    };
}(es$4);

var es$3 = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    function advancedRotate(deg, mode) {
        var rad = (deg %= 360) * Math.PI / 180, cosine = Math.cos(rad), sine = Math.sin(rad), w = this.bitmap.width, h = this.bitmap.height;
        if (!0 === mode || "string" == typeof mode) {
            (w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1) % 2 != 0 && w++, 
            (h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1) % 2 != 0 && h++;
            var c = this.cloneQuiet();
            this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                this.bitmap.data.writeUInt32BE(this._background, idx);
            }));
            var max = Math.max(w, h, this.bitmap.width, this.bitmap.height);
            this.resize(max, max, mode), this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);
        }
        var bW = this.bitmap.width, bH = this.bitmap.height, dstBuffer = Buffer.alloc(this.bitmap.data.length);
        function createTranslationFunction(deltaX, deltaY) {
            return function(x, y) {
                return {
                    x: x + deltaX,
                    y: y + deltaY
                };
            };
        }
        for (var translate2Cartesian = createTranslationFunction(-bW / 2, -bH / 2), translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5), y = 1; y <= bH; y++) for (var x = 1; x <= bW; x++) {
            var cartesian = translate2Cartesian(x, y), source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x), dstIdx = bW * (y - 1) + x - 1 << 2;
            if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {
                var srcIdx = (bW * (0 | source.y) + source.x | 0) << 2, pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);
                dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
            } else dstBuffer.writeUInt32BE(this._background, dstIdx);
        }
        if (this.bitmap.data = dstBuffer, !0 === mode || "string" == typeof mode) {
            var _x = bW / 2 - w / 2, _y = bH / 2 - h / 2;
            this.crop(_x, _y, w, h);
        }
    }
    exports.default = function _default() {
        return {
            rotate: function rotate(deg, mode, cb) {
                return null == mode && (mode = !0), "function" == typeof mode && void 0 === cb && (cb = mode, 
                mode = !0), "number" != typeof deg ? _utils.throwError.call(this, "deg must be a number", cb) : "boolean" != typeof mode && "string" != typeof mode ? _utils.throwError.call(this, "mode must be a boolean or a string", cb) : (advancedRotate.call(this, deg, mode, cb), 
                (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
            }
        };
    };
}(es$3);

var es$2 = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    exports.default = function _default() {
        return {
            scale: function scale(f, mode, cb) {
                if ("number" != typeof f) return _utils.throwError.call(this, "f must be a number", cb);
                if (f < 0) return _utils.throwError.call(this, "f must be a positive number", cb);
                "function" == typeof mode && void 0 === cb && (cb = mode, mode = null);
                var w = this.bitmap.width * f, h = this.bitmap.height * f;
                return this.resize(w, h, mode), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
                this;
            },
            scaleToFit: function scaleToFit(w, h, mode, cb) {
                if ("number" != typeof w || "number" != typeof h) return _utils.throwError.call(this, "w and h must be numbers", cb);
                "function" == typeof mode && void 0 === cb && (cb = mode, mode = null);
                var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
                return this.scale(f, mode), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
                this;
            }
        };
    };
}(es$2);

var es$1 = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    exports.default = function _default() {
        return {
            shadow: function shadow() {
                var _this = this, options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, cb = arguments.length > 1 ? arguments[1] : void 0;
                "function" == typeof options && (cb = options, options = {});
                var _options = options, _options$opacity = _options.opacity, opacity = void 0 === _options$opacity ? 0.7 : _options$opacity, _options$size = _options.size, size = void 0 === _options$size ? 1.1 : _options$size, _options$x = _options.x, x = void 0 === _options$x ? -25 : _options$x, _options$y = _options.y, y = void 0 === _options$y ? 25 : _options$y, _options$blur = _options.blur, blur = void 0 === _options$blur ? 5 : _options$blur, orig = this.clone(), shadow = this.clone();
                return shadow.scan(0, 0, shadow.bitmap.width, shadow.bitmap.height, (function(x, y, idx) {
                    shadow.bitmap.data[idx] = 0x00, shadow.bitmap.data[idx + 1] = 0x00, shadow.bitmap.data[idx + 2] = 0x00, 
                    shadow.bitmap.data[idx + 3] = shadow.constructor.limit255(shadow.bitmap.data[idx + 3] * opacity), 
                    _this.bitmap.data[idx] = 0x00, _this.bitmap.data[idx + 1] = 0x00, _this.bitmap.data[idx + 2] = 0x00, 
                    _this.bitmap.data[idx + 3] = 0x00;
                })), shadow.resize(shadow.bitmap.width * size, shadow.bitmap.height * size).blur(blur), 
                this.composite(shadow, x, y), this.composite(orig, 0, 0), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
                this;
            }
        };
    };
}(es$1);

var es = {};

!function(exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _utils = es$s;
    exports.default = function _default() {
        return {
            threshold: function threshold(_ref, cb) {
                var _this = this, max = _ref.max, _ref$replace = _ref.replace, replace = void 0 === _ref$replace ? 255 : _ref$replace, _ref$autoGreyscale = _ref.autoGreyscale, autoGreyscale = void 0 === _ref$autoGreyscale || _ref$autoGreyscale;
                return "number" != typeof max ? _utils.throwError.call(this, "max must be a number", cb) : "number" != typeof replace ? _utils.throwError.call(this, "replace must be a number", cb) : "boolean" != typeof autoGreyscale ? _utils.throwError.call(this, "autoGreyscale must be a boolean", cb) : (max = this.constructor.limit255(max), 
                replace = this.constructor.limit255(replace), autoGreyscale && this.greyscale(), 
                this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    var grey = _this.bitmap.data[idx] < max ? _this.bitmap.data[idx] : replace;
                    _this.bitmap.data[idx] = grey, _this.bitmap.data[idx + 1] = grey, _this.bitmap.data[idx + 2] = grey;
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
            }
        };
    };
}(es), function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _toConsumableArray2 = _interopRequireDefault(toConsumableArray.exports), _timm = timm$1, _pluginBlit = _interopRequireDefault(es$k), _pluginBlur = _interopRequireDefault(es$j), _pluginCircle = _interopRequireDefault(es$i), _pluginColor = _interopRequireDefault(es$h), _pluginContain = _interopRequireDefault(es$g), _pluginCover = _interopRequireDefault(es$f), _pluginCrop = _interopRequireDefault(es$e), _pluginDisplace = _interopRequireDefault(es$d), _pluginDither = _interopRequireDefault(es$c), _pluginFisheye = _interopRequireDefault(es$b), _pluginFlip = _interopRequireDefault(es$a), _pluginGaussian = _interopRequireDefault(es$9), _pluginInvert = _interopRequireDefault(es$8), _pluginMask = _interopRequireDefault(es$7), _pluginNormalize = _interopRequireDefault(es$6), _pluginPrint = _interopRequireDefault(es$5), _pluginResize = _interopRequireDefault(es$4), _pluginRotate = _interopRequireDefault(es$3), _pluginScale = _interopRequireDefault(es$2), _pluginShadow = _interopRequireDefault(es$1), _pluginThreshold = _interopRequireDefault(es), plugins = [ _pluginBlit.default, _pluginBlur.default, _pluginCircle.default, _pluginColor.default, _pluginContain.default, _pluginCover.default, _pluginCrop.default, _pluginDisplace.default, _pluginDither.default, _pluginFisheye.default, _pluginFlip.default, _pluginGaussian.default, _pluginInvert.default, _pluginMask.default, _pluginNormalize.default, _pluginPrint.default, _pluginResize.default, _pluginRotate.default, _pluginScale.default, _pluginShadow.default, _pluginThreshold.default ];
    exports.default = function _default(jimpEvChange) {
        var initializedPlugins = plugins.map((function(pluginModule) {
            var plugin = pluginModule(jimpEvChange) || {};
            return plugin.class || plugin.constants || (plugin = {
                class: plugin
            }), plugin;
        }));
        return _timm.mergeDeep.apply(void 0, (0, _toConsumableArray2.default)(initializedPlugins));
    };
}(es$l), function(exports) {
    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = void 0;
    var _custom = _interopRequireDefault(es$u), _types = _interopRequireDefault(es$r), _plugins = _interopRequireDefault(es$l), _default = (0, 
    _custom.default)({
        types: [ _types.default ],
        plugins: [ _plugins.default ]
    });
    exports.default = _default;
}(es$v);

var Jimp = getDefaultExportFromCjs(es$v);

class NeuQuant {
    network=[];
    netindex=new Int32Array(256);
    bias=new Int32Array(256);
    freq=new Int32Array(256);
    radpower=new Int32Array(32);
    pixels;
    samplefac;
    constructor(pixels, samplefac) {
        this.pixels = pixels, this.samplefac = samplefac;
    }
    init() {
        this.network = [], this.netindex = new Int32Array(256), this.bias = new Int32Array(256), 
        this.freq = new Int32Array(256), this.radpower = new Int32Array(32);
        for (let i = 0; i < 256; i++) {
            const v = (i << 12) / 256;
            this.network[i] = new Float64Array([ v, v, v, 0 ]), this.freq[i] = 256, this.bias[i] = 0;
        }
    }
    unbiasnet() {
        for (let i = 0; i < 256; i++) this.network[i][0] >>= 4, this.network[i][1] >>= 4, 
        this.network[i][2] >>= 4, this.network[i][3] = i;
    }
    altersingle(alpha, i, b, g, r) {
        this.network[i][0] -= alpha * (this.network[i][0] - b) / 1024, this.network[i][1] -= alpha * (this.network[i][1] - g) / 1024, 
        this.network[i][2] -= alpha * (this.network[i][2] - r) / 1024;
    }
    alterneigh(radius, i, b, g, r) {
        const lo = Math.abs(i - radius), hi = Math.min(i + radius, 256);
        let j = i + 1, k = i - 1, m = 1;
        for (;j < hi || k > lo; ) {
            const a = this.radpower[m++];
            let p;
            j < hi && (p = this.network[j++], p[0] -= a * (p[0] - b) / 262144, p[1] -= a * (p[1] - g) / 262144, 
            p[2] -= a * (p[2] - r) / 262144), k > lo && (p = this.network[k--], p[0] -= a * (p[0] - b) / 262144, 
            p[1] -= a * (p[1] - g) / 262144, p[2] -= a * (p[2] - r) / 262144);
        }
    }
    contest(b, g, r) {
        let bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
        for (let i = 0; i < 256; i++) {
            const n = this.network[i], dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);
            dist < bestd && (bestd = dist, bestpos = i);
            const biasdist = dist - (this.bias[i] >> 12);
            biasdist < bestbiasd && (bestbiasd = biasdist, bestbiaspos = i);
            const betafreq = this.freq[i] >> 10;
            this.freq[i] -= betafreq, this.bias[i] += betafreq << 10;
        }
        return this.freq[bestpos] += 64, this.bias[bestpos] -= 65536, bestbiaspos;
    }
    inxbuild() {
        let j, previouscol = 0, startpos = 0;
        for (let i = 0; i < 256; i++) {
            const p = this.network[i];
            let q, smallpos = i, smallval = p[1];
            for (j = i + 1; j < 256; j++) q = this.network[j], q[1] < smallval && (smallpos = j, 
            smallval = q[1]);
            if (q = this.network[smallpos], i !== smallpos && (j = q[0], q[0] = p[0], p[0] = j, 
            j = q[1], q[1] = p[1], p[1] = j, j = q[2], q[2] = p[2], p[2] = j, j = q[3], q[3] = p[3], 
            p[3] = j), smallval !== previouscol) {
                for (this.netindex[previouscol] = startpos + i >> 1, j = previouscol + 1; j < smallval; j++) this.netindex[j] = i;
                previouscol = smallval, startpos = i;
            }
        }
        for (this.netindex[previouscol] = startpos + 255 >> 1, j = previouscol + 1; j < 256; j++) this.netindex[j] = 255;
    }
    lookupRGB(b, g, r) {
        let a, p, dist, bestd = 1000, best = -1, i = this.netindex[g], j = i - 1;
        for (;i < 256 || j >= 0; ) i < 256 && (p = this.network[i], dist = p[1] - g, dist >= bestd ? i = 256 : (i++, 
        dist < 0 && (dist = -dist), a = p[0] - b, a < 0 && (a = -a), dist += a, dist < bestd && (a = p[2] - r, 
        a < 0 && (a = -a), dist += a, dist < bestd && (bestd = dist, best = p[3])))), j >= 0 && (p = this.network[j], 
        dist = g - p[1], dist >= bestd ? j = -1 : (j--, dist < 0 && (dist = -dist), a = p[0] - b, 
        a < 0 && (a = -a), dist += a, dist < bestd && (a = p[2] - r, a < 0 && (a = -a), 
        dist += a, dist < bestd && (bestd = dist, best = p[3]))));
        return best;
    }
    learn() {
        let i;
        const lengthcount = this.pixels.length, alphadec = 30 + (this.samplefac - 1) / 3, samplepixels = lengthcount / (3 * this.samplefac);
        let step, b, g, r, j, delta = ~~(samplepixels / 100), alpha = 1024, radius = 2048, rad = radius >> 6;
        for (rad <= 1 && (rad = 0), i = 0; i < rad; i++) this.radpower[i] = alpha * (256 * (rad * rad - i * i) / (rad * rad));
        lengthcount < 1509 ? (this.samplefac = 1, step = 3) : step = lengthcount % 499 != 0 ? 1497 : lengthcount % 491 != 0 ? 1473 : lengthcount % 487 != 0 ? 1461 : 1509;
        let pix = 0;
        for (i = 0; i < samplepixels; ) if (b = (0xff & this.pixels[pix]) << 4, g = (0xff & this.pixels[pix + 1]) << 4, 
        r = (0xff & this.pixels[pix + 2]) << 4, j = this.contest(b, g, r), this.altersingle(alpha, j, b, g, r), 
        0 !== rad && this.alterneigh(rad, j, b, g, r), pix += step, pix >= lengthcount && (pix -= lengthcount), 
        i++, 0 === delta && (delta = 1), i % delta == 0) for (alpha -= alpha / alphadec, 
        radius -= radius / 30, rad = radius >> 6, rad <= 1 && (rad = 0), j = 0; j < rad; j++) this.radpower[j] = alpha * (256 * (rad * rad - j * j) / (rad * rad));
    }
    buildColormap() {
        this.init(), this.learn(), this.unbiasnet(), this.inxbuild();
    }
    getColormap() {
        const map = [], index = [];
        for (let i = 0; i < 256; i++) index[this.network[i][3]] = i;
        let k = 0;
        for (let l = 0; l < 256; l++) {
            const j = index[l];
            map[k++] = this.network[j][0], map[k++] = this.network[j][1], map[k++] = this.network[j][2];
        }
        return map;
    }
}

const masks = [ 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF ];

class LZWEncoder {
    width;
    height;
    pixels;
    colorDepth;
    initCodeSize;
    accum=new Uint8Array(256);
    htab=new Int32Array(5003);
    codetab=new Int32Array(5003);
    curAccum=0;
    curBits=0;
    aCount=0;
    freeEnt=0;
    maxcode=0;
    clearFlg=!1;
    gInitBits=0;
    nBits=0;
    ClearCode=0;
    EOFCode;
    remaining=0;
    curPixel=0;
    constructor(width, height, pixels, colorDepth) {
        this.width = width, this.height = height, this.pixels = pixels, this.colorDepth = colorDepth, 
        this.initCodeSize = Math.max(2, colorDepth);
    }
    flushChar(outs) {
        this.aCount > 0 && (outs.writeByte(this.aCount), outs.writeBytes(this.accum, 0, this.aCount), 
        this.aCount = 0);
    }
    charOut(c, outs) {
        this.accum[this.aCount++] = c, this.aCount >= 254 && this.flushChar(outs);
    }
    clHash(hsize) {
        for (let i = 0; i < hsize; ++i) this.htab[i] = -1;
    }
    static MAXCODE(nBits) {
        return (1 << nBits) - 1;
    }
    output(code, outs) {
        for (this.curAccum &= masks[this.curBits], this.curBits > 0 ? this.curAccum |= code << this.curBits : this.curAccum = code, 
        this.curBits += this.nBits; this.curBits >= 8; ) this.charOut(0xff & this.curAccum, outs), 
        this.curAccum >>= 8, this.curBits -= 8;
        if ((this.freeEnt > this.maxcode || this.clearFlg) && (this.clearFlg ? (this.maxcode = LZWEncoder.MAXCODE(this.nBits = this.gInitBits), 
        this.clearFlg = !1) : (++this.nBits, 12 === this.nBits ? this.maxcode = 4096 : this.maxcode = LZWEncoder.MAXCODE(this.nBits))), 
        code === this.EOFCode) {
            for (;this.curBits > 0; ) this.charOut(0xff & this.curAccum, outs), this.curAccum >>= 8, 
            this.curBits -= 8;
            this.flushChar(outs);
        }
    }
    clBlock(outs) {
        this.clHash(5003), this.freeEnt = this.ClearCode + 2, this.clearFlg = !0, this.output(this.ClearCode, outs);
    }
    nextPixel() {
        return 0 === this.remaining ? -1 : (--this.remaining, 0xff & this.pixels[this.curPixel++]);
    }
    compress(initBits, outs) {
        this.gInitBits = initBits, this.clearFlg = !1, this.nBits = this.gInitBits, this.maxcode = LZWEncoder.MAXCODE(this.nBits), 
        this.ClearCode = 1 << initBits - 1, this.EOFCode = this.ClearCode + 1, this.freeEnt = this.ClearCode + 2, 
        this.aCount = 0;
        let fcode, c, ent = this.nextPixel(), hshift = 0;
        for (fcode = 5003; fcode < 65536; fcode *= 2) ++hshift;
        hshift = 8 - hshift, this.clHash(5003), this.output(this.ClearCode, outs);
        outerLoop: do {
            c = this.nextPixel(), fcode = (c << 12) + ent;
            let i = c << hshift ^ ent;
            if (this.htab[i] !== fcode) {
                if (this.htab[i] >= 0) {
                    let disp = 5003 - i;
                    0 === i && (disp = 1);
                    do {
                        if (i -= disp, i < 0 && (i += 5003), this.htab[i] === fcode) {
                            ent = this.codetab[i];
                            continue outerLoop;
                        }
                    } while (this.htab[i] >= 0);
                }
                this.output(ent, outs), ent = c, this.freeEnt < 4096 ? (this.codetab[i] = this.freeEnt++, 
                this.htab[i] = fcode) : this.clBlock(outs);
            } else ent = this.codetab[i];
        } while (-1 !== c);
        this.output(ent, outs), this.output(this.EOFCode, outs);
    }
    encode(outs) {
        outs.writeByte(this.initCodeSize), this.remaining = this.width * this.height, this.curPixel = 0, 
        this.compress(this.initCodeSize + 1, outs), outs.writeByte(0);
    }
}

class ByteArray {
    data=[];
    getData() {
        return Buffer.from(this.data);
    }
    writeByte(val) {
        this.data.push(val);
    }
    writeUTFBytes(text) {
        for (let l = text.length, i = 0; i < l; i++) this.writeByte(text.charCodeAt(i));
    }
    writeBytes(array, offset, length) {
        for (let l = length || array.length, i = offset || 0; i < l; i++) this.writeByte(array[i]);
    }
}

class GIFEncoder {
    width;
    height;
    transparent;
    transIndex=0;
    repeat=-1;
    delay=0;
    image;
    pixels;
    indexedPixels;
    colorDepth;
    colorTab;
    usedEntry=[];
    palSize=7;
    dispose=-1;
    firstFrame=!0;
    sample=10;
    started=!1;
    readStreams=[];
    out=new ByteArray;
    constructor(width, height) {
        this.width = ~~width, this.height = ~~height;
    }
    createReadStream(_readStream) {
        let readStream = _readStream;
        return void 0 === readStream && (readStream = new require$$1__default$1.default.Readable, 
        readStream._read = () => {}), this.readStreams.push(readStream), readStream;
    }
    emit() {
        0 !== this.readStreams.length && this.out.data.length && (this.readStreams.forEach((rs => {
            rs.push(Buffer.from(this.out.data));
        })), this.out.data = []);
    }
    start() {
        this.out.writeUTFBytes("GIF89a"), this.started = !0, this.emit();
    }
    getImagePixels() {
        const data = this.image;
        if (void 0 === data) return;
        const w = this.width, h = this.height;
        this.pixels = new Uint8Array(w * h * 3);
        let count = 0;
        for (let i = 0; i < h; i++) for (let j = 0; j < w; j++) {
            const b = i * w * 4 + 4 * j;
            this.pixels[count++] = data[b], this.pixels[count++] = data[b + 1], this.pixels[count++] = data[b + 2];
        }
    }
    findClosest(c) {
        if (void 0 === this.colorTab) return -1;
        const r = (0xFF0000 & c) >> 16, g = (0x00FF00 & c) >> 8, b = 0x0000FF & c;
        let minpos = 0, dmin = 16777216;
        const len = this.colorTab.length;
        for (let i = 0; i < len; ) {
            const index = i / 3, dr = r - (0xff & this.colorTab[i++]), dg = g - (0xff & this.colorTab[i++]), db = b - (0xff & this.colorTab[i++]), d = dr * dr + dg * dg + db * db;
            this.usedEntry[index] && d < dmin && (dmin = d, minpos = index);
        }
        return minpos;
    }
    analyzePixels() {
        if (void 0 === this.pixels || void 0 === this.image) return;
        const nPix = this.pixels.length / 3;
        this.indexedPixels = new Uint8Array(nPix);
        const imgq = new NeuQuant(this.pixels, this.sample);
        imgq.buildColormap(), this.colorTab = imgq.getColormap();
        let k = 0;
        for (let j = 0; j < nPix; j++) {
            const index = imgq.lookupRGB(0xff & this.pixels[k++], 0xff & this.pixels[k++], 0xff & this.pixels[k++]);
            this.usedEntry[index] = !0, this.indexedPixels[j] = index;
        }
        if (this.pixels = void 0, this.colorDepth = 8, this.palSize = 7, void 0 !== this.transparent) {
            this.transIndex = this.findClosest(this.transparent);
            for (let pixelIndex = 0; pixelIndex < nPix; pixelIndex++) 0 === this.image[4 * pixelIndex + 3] && (this.indexedPixels[pixelIndex] = this.transIndex);
        }
    }
    writeShort(pValue) {
        this.out.writeByte(0xFF & pValue), this.out.writeByte(pValue >> 8 & 0xFF);
    }
    writeLSD() {
        this.writeShort(this.width), this.writeShort(this.height), this.out.writeByte(240 | this.palSize), 
        this.out.writeByte(0), this.out.writeByte(0);
    }
    writePalette() {
        if (void 0 === this.colorTab) return;
        this.out.writeBytes(this.colorTab);
        const n = 768 - this.colorTab.length;
        for (let i = 0; i < n; i++) this.out.writeByte(0);
    }
    writeNetscapeExt() {
        this.out.writeByte(0x21), this.out.writeByte(0xff), this.out.writeByte(11), this.out.writeUTFBytes("NETSCAPE2.0"), 
        this.out.writeByte(3), this.out.writeByte(1), this.writeShort(this.repeat), this.out.writeByte(0);
    }
    writeGraphicCtrlExt() {
        let transp, disp;
        this.out.writeByte(0x21), this.out.writeByte(0xf9), this.out.writeByte(4), void 0 === this.transparent ? (transp = 0, 
        disp = 0) : (transp = 1, disp = 2), this.dispose >= 0 && (disp = 7 & this.dispose), 
        disp <<= 2, this.out.writeByte(0 | disp | transp), this.writeShort(this.delay), 
        this.out.writeByte(this.transIndex), this.out.writeByte(0);
    }
    writeImageDesc() {
        this.out.writeByte(0x2c), this.writeShort(0), this.writeShort(0), this.writeShort(this.width), 
        this.writeShort(this.height), this.firstFrame ? this.out.writeByte(0) : this.out.writeByte(128 | this.palSize);
    }
    writePixels() {
        void 0 !== this.indexedPixels && void 0 !== this.colorDepth && new LZWEncoder(this.width, this.height, this.indexedPixels, this.colorDepth).encode(this.out);
    }
    addFrame(imageData) {
        Buffer.isBuffer(imageData) ? this.image = imageData : this.image = imageData.getImageData(0, 0, this.width, this.height).data, 
        this.getImagePixels(), this.analyzePixels(), this.firstFrame && (this.writeLSD(), 
        this.writePalette(), this.repeat >= 0 && this.writeNetscapeExt()), this.writeGraphicCtrlExt(), 
        this.writeImageDesc(), this.firstFrame || this.writePalette(), this.writePixels(), 
        this.firstFrame = !1, this.emit();
    }
    setDelay(milliseconds) {
        void 0 !== milliseconds && (this.delay = Math.round(milliseconds / 10));
    }
    setFrameRate(fps) {
        void 0 !== fps && (this.delay = Math.round(100 / fps));
    }
    setDispose(disposalCode) {
        void 0 !== disposalCode ? disposalCode >= 0 && (this.dispose = disposalCode) : this.dispose = void 0 === this.transparent ? 0 : 2;
    }
    setRepeat(repeat = -1) {
        this.repeat = repeat;
    }
    setTransparent(color) {
        this.transparent = color;
    }
    end() {
        null !== this.readStreams.length && (this.emit(), this.readStreams.forEach((readStream => {
            readStream.push(null);
        })), this.readStreams = []);
    }
    finish() {
        this.out.writeByte(0x3b), this.end();
    }
    setQuality(_quality = 10) {
        let quality = _quality;
        quality < 1 && (quality = 1), this.sample = quality;
    }
}

async function getBuffer(data) {
    const buffers = [];
    let readStream;
    return readStream = Buffer.isBuffer(data) ? function convert(buf, _chunkSize) {
        const reader = new require$$1$2.Readable, hwm = reader._readableState.highWaterMark, len = buf.length;
        let chunkSize, start = 0;
        return chunkSize = void 0 === _chunkSize || _chunkSize < 1 || _chunkSize > hwm ? hwm : _chunkSize, 
        reader._read = () => {
            const chunk = buf.slice(start, start += chunkSize);
            for (;reader.push(chunk); ) if (start >= len) {
                reader.push(null);
                break;
            }
        }, reader;
    }(data) : "string" == typeof data ? await httpsGetStream(data) : data, new Promise(((resolve, reject) => {
        readStream.on("data", (chunk => {
            buffers.push(chunk);
        })).on("end", (() => {
            resolve(Buffer.concat(buffers));
        })).on("error", (error => {
            reject(error);
        }));
    }));
}

async function getGifFromBuffer(data) {
    const buffer = await getBuffer(data), gif = await src.GifUtil.read(buffer, new src.GifCodec);
    if (gif.frames.length > 200) throw Error("Image too large, advanced modifiers not supported!");
    return gif;
}

function alignGif(frames, interval) {
    let alignedFrames = src.GifUtil.cloneFrames(frames);
    for (;alignedFrames.length < interval; ) alignedFrames = alignedFrames.concat(src.GifUtil.cloneFrames(frames));
    let framesToDelete = alignedFrames.length % interval;
    for (;framesToDelete / alignedFrames.length > 0.2; ) alignedFrames = alignedFrames.concat(src.GifUtil.cloneFrames(frames)), 
    framesToDelete = alignedFrames.length % interval;
    const amountCopies = alignedFrames.length / frames.length;
    let currentCopy = 0;
    for (let i = 0; i < framesToDelete; i++) {
        const frameToDelete = Math.floor(Math.random() * frames.length - 1) + 1;
        alignedFrames.splice(frameToDelete + currentCopy * frames.length, 1), currentCopy = (currentCopy + 1) % amountCopies;
    }
    return alignedFrames;
}

function setEncoderProperties(encoder, delay) {
    encoder.start(), encoder.setRepeat(0), encoder.setQuality(5), void 0 !== delay && encoder.setDelay(delay), 
    encoder.setTransparent(0x00000000);
}

function preparePNGVariables(options, image) {
    const {widthModifier, heightModifier} = function getSizeFromOptions(options) {
        let widthModifier = 1, heightModifier = 1;
        if (!options.isResized) {
            const {size} = options;
            if (size.includes("x")) {
                const split = size.split("x");
                widthModifier = parseFloat(split[0] ?? "1"), heightModifier = parseFloat(split[1] ?? "1");
            } else widthModifier = parseFloat(size), heightModifier = parseFloat(size);
        }
        return {
            widthModifier,
            heightModifier
        };
    }(options), width = Math.floor(widthModifier * image.width), height = Math.floor(heightModifier * image.height);
    return {
        width,
        height,
        encoder: new GIFEncoder(width, height)
    };
}

function prepareRotateVariables(width, height) {
    let margin = (width - height) / 2;
    return height > width && (margin *= -1), {
        max: Math.max(width, height),
        margin
    };
}

function prepareSpinVariables(delay, centisecsPerRotation, reverse, width, height) {
    let degrees = 360 * delay / centisecsPerRotation;
    const interval = Math.floor(360 / degrees);
    degrees *= reverse ? 1 : -1;
    let margin = (width - height) / 2;
    return height > width && (margin *= -1), {
        degrees,
        interval,
        max: Math.max(width, height),
        margin
    };
}

function greatestCommonDenominator(a, b) {
    return b ? greatestCommonDenominator(b, a % b) : a;
}

function shiftColor(bitmap, index, shiftAmount, randomBlack, randomWhite) {
    const [firstColor, secondColor, thirdColor] = [ bitmap[index] ?? 0, bitmap[index + 1] ?? 0, bitmap[index + 2] ?? 0 ];
    let colors;
    return colors = firstColor <= 30 && secondColor <= 30 && thirdColor <= 30 ? [ randomWhite, 0.5, 0.2 ] : firstColor >= 220 && secondColor >= 220 && thirdColor >= 220 ? [ randomBlack, 0.5, 0.8 ] : function rgb2hsl(_r, _g, _b) {
        const r = _r / 255, g = _g / 255, b = _b / 255, max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s;
        const l = (max + min) / 2;
        if (max === min) h = 0, s = 0; else {
            const d = max - min;
            switch (s = l > 0.5 ? d / (2 - max - min) : d / (max + min), max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;

              case g:
                h = (b - r) / d + 2;
                break;

              case b:
                h = (r - g) / d + 4;
                break;

              default:
                h = 0;
            }
            h /= 6;
        }
        return [ h, s, l ];
    }(firstColor, secondColor, thirdColor), colors[0] += shiftAmount, colors;
}

function hue2rgb(p, q, _t) {
    let t = _t;
    return t < 0 ? t++ : t > 1 && t--, t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;
}

function hsl2rgb(h, s, l) {
    let r, g, b, q, p;
    return 0 === s ? (r = l, g = l, b = l) : (q = l < 0.5 ? l * (1 + s) : l + s - l * s, 
    p = 2 * l - q, r = hue2rgb(p, q, h + 1 / 3), g = hue2rgb(p, q, h), b = hue2rgb(p, q, h - 1 / 3)), 
    [ 255 * r, 255 * g, 255 * b ];
}

function shiftColors(bitmap, interval, randomBlack, randomWhite) {
    for (let i = 0; i < bitmap.data.length; i += 4) if ((bitmap.data[i + 3] ?? 0) > 0) {
        let colors = shiftColor(bitmap.data, i, interval, randomBlack, randomWhite);
        for (;colors[0] > 1; ) colors[0]--;
        colors = hsl2rgb(colors[0], colors[1], colors[2]), bitmap.data.set(colors, i);
    }
}

function prepareWiggleVariables(margin, height) {
    const shiftSize = Math.max(1, margin / 6);
    return {
        shiftSize,
        interval: 2 * (margin / shiftSize + 4),
        stripeHeight: Math.max(1, Math.floor(height / 32)),
        shift: margin / 2,
        left: !0
    };
}

function shiftWiggleStep(_shift, _left, margin, shiftSize) {
    let shift = _shift, left = _left;
    return left ? (shift -= shiftSize, shift < -shiftSize && (left = !1)) : (shift += shiftSize, 
    shift > margin + shiftSize && (left = !0)), [ shift, left ];
}

function getWiggledFrameData(oldFrame, _shift, _left, options) {
    const newFrame = new Jimp(options.width, oldFrame.bitmap.height);
    let shift = _shift, left = _left;
    for (let stripe = 0; stripe < oldFrame.bitmap.height; stripe += options.stripeHeight) newFrame.blit(oldFrame, shift, stripe, 0, stripe, oldFrame.bitmap.width, options.stripeHeight), 
    [shift, left] = shiftWiggleStep(shift, left, options.margin, options.shiftSize);
    return newFrame.bitmap;
}

function resetInfiniteScales(scalesAmount, scaleDiff, scaleStep) {
    const scales = [];
    for (let depth = 0; depth < scalesAmount; depth++) scales.push((scalesAmount - depth - 1) * scaleDiff + scaleStep);
    return scales;
}

function getInfiniteShiftedFrameData(frameBitmap, scales) {
    const newFrame = new Jimp(frameBitmap.width, frameBitmap.height, 0x00);
    return scales.forEach((scale => {
        const scaledFrame = new Jimp(frameBitmap);
        scaledFrame.scale(scale);
        const dx = (scaledFrame.bitmap.width - frameBitmap.width) / 2, dy = (scaledFrame.bitmap.height - frameBitmap.height) / 2;
        scale > 1 ? newFrame.blit(scaledFrame, 0, 0, dx, dy, frameBitmap.width, frameBitmap.height) : newFrame.blit(scaledFrame, -dx, -dy);
    })), newFrame.bitmap;
}

function shiftInfiniteScales(_scales, scaleDiff, scaleStep) {
    let scales = _scales;
    if ((scales[0] ?? 0) >= scales.length * scaleDiff) scales = resetInfiniteScales(scales.length, scaleDiff, scaleStep); else for (let depth = 0; depth < scales.length; depth++) scales[depth] += scaleStep;
    return scales;
}

function prepareSlidingVariables(width, speed) {
    const interval = 2 * speed;
    return {
        interval,
        shift: 0,
        shiftSize: width / interval
    };
}

function getShiftedFrameData(oldFrame, shift) {
    const {width} = oldFrame.bitmap, {height} = oldFrame.bitmap, newFrame = new Jimp(width, height, 0x00);
    return newFrame.blit(oldFrame, shift, 0, 0, 0, width - shift, height), newFrame.blit(oldFrame, 0, 0, width - shift, 0, shift, height), 
    newFrame.bitmap;
}

function resetDrop(delay) {
    let speed = Math.random();
    const len = Math.floor(5 * speed + 1), size = Math.floor(2 * speed + 1);
    return speed = Math.floor(speed * delay + delay), {
        speed,
        len,
        size
    };
}

module.exports = GIFEncoder;

class Drop {
    width;
    height;
    delay;
    x;
    y;
    speed;
    len;
    size;
    r=0;
    g=0;
    b=0;
    constructor(width, height, delay) {
        this.width = width, this.height = height, this.delay = delay, this.x = Math.random() * width, 
        this.y = Math.random() * height;
        const {speed, len, size} = resetDrop(this.delay);
        this.speed = speed, this.len = len, this.size = size;
    }
    fall() {
        if (this.y += this.speed, this.y > this.height) {
            this.y = 0;
            const {speed, len, size} = resetDrop(this.delay);
            this.speed = speed, this.len = len, this.size = size;
        }
    }
    setColor(r, g, b) {
        this.r = r, this.g = g, this.b = b;
    }
}

function rainImageGenerator(width, height, glitter, delay) {
    const drops = [];
    for (let i = 0, amount = (width + height) / 5; i < amount; i++) drops.push(new Drop(width, height, delay));
    return glitter ? drops.forEach((drop => {
        drop.setColor(256 * Math.random(), 256 * Math.random(), 256 * Math.random());
    })) : drops.forEach((drop => drop.setColor(0, 120, 255))), {
        next() {
            const img = new Jimp(width, height, 0x00);
            return drops.forEach((drop => {
                for (let j = 0; j < drop.len; j++) for (let k = 0; k < drop.size; k++) {
                    const pos = 4 * (Math.floor(drop.y + j) * width + Math.floor(drop.x + k));
                    img.bitmap.data[pos + 0] = drop.r, img.bitmap.data[pos + 1] = drop.g, img.bitmap.data[pos + 2] = drop.b, 
                    img.bitmap.data[pos + 3] = 255;
                }
                drop.fall();
            })), img;
        }
    };
}

let Buffer$2;

class GifsicleService extends BaseService {
    async start() {
        Buffer$2 = (await Promise.resolve().then((function() {
            return _interopNamespace(require("buffer"));
        }))).Buffer;
    }
    async modifyGif(url, options) {
        Logger.info("Got GIF request", url, options);
        const commands = this.getCommands(options);
        Logger.info("Processed request commands", commands);
        const buffer = await this.processCommands(url, commands);
        return Logger.info("Processed modified emote", {
            length: buffer.length
        }), buffer;
    }
    getCommands(options) {
        const normal = [], special = [], priority = [];
        return options.forEach((option => {
            switch (option[0]) {
              case "resize":
                {
                    const command = {
                        name: "--scale",
                        param: option[1]
                    }, split = command.param?.toString().split("x");
                    !0 === split?.some((axis => parseFloat(axis) > 1)) ? normal.push(command) : priority.push(command);
                    break;
                }

              case "reverse":
                normal.push({
                    name: "#-1-0"
                });
                break;

              case "flip":
                normal.push({
                    name: "--flip-horizontal"
                });
                break;

              case "flap":
                normal.push({
                    name: "--flip-vertical"
                });
                break;

              case "speed":
                {
                    const param = option[1]?.toString() ?? "";
                    param && normal.push({
                        name: `-d${Math.max(2, parseFloat(param))}`
                    });
                    break;
                }

              case "hyperspeed":
                normal.push({
                    name: "hyperspeed"
                });
                break;

              case "rotate":
                special.push({
                    name: option[0],
                    param: option[1]
                });
                break;

              case "wiggle":
                {
                    let size = 2;
                    const param = option[1];
                    "big" === param ? size = 4 : "bigger" === param ? size = 6 : "huge" === param && (size = 10), 
                    special.push({
                        name: option[0],
                        param: size
                    });
                    break;
                }

              case "rain":
                special.push({
                    name: option[0],
                    param: "glitter" === option[1] ? 1 : 0
                });
                break;

              case "spin":
              case "spinrev":
              case "shake":
              case "rainbow":
              case "infinite":
              case "slide":
              case "sliderev":
                {
                    let speed = 8;
                    const param = option[1];
                    "fast" === param ? speed = 6 : "faster" === param ? speed = 4 : "hyper" === param && (speed = 2), 
                    special.push({
                        name: option[0],
                        param: speed
                    });
                    break;
                }
            }
        })), {
            normal,
            special,
            priority
        };
    }
    async processCommands(url, commands) {
        const fileType = url.endsWith("gif") ? "gif" : "png";
        let size, buffer = url;
        if ("gif" === fileType && (commands.priority.length > 0 && (buffer = await this.doModification(buffer, commands.priority)), 
        buffer = await this.doModification(buffer, [ {
            name: "--unoptimize"
        } ])), "png" === fileType) {
            const scaleIndex = this.getCommandIndex(commands.priority, "--scale");
            void 0 !== scaleIndex && (size = commands.priority[scaleIndex]?.param);
        }
        if (commands.special.length > 0 && (buffer = await this.processSpecialCommands({
            data: buffer,
            commands: commands.special,
            fileType,
            size
        })), commands.normal.length > 0 && (buffer = await this.processNormalCommands(buffer, commands.normal)), 
        !(buffer instanceof Buffer$2)) throw Error("Did not process gif!");
        return buffer;
    }
    async doModification(data, options, _retryCount = 0) {
        if (0 === data.length) return Buffer$2.concat([]);
        let retryCount = _retryCount;
        const gifsicleParams = [];
        let buffer;
        if (options.forEach((option => {
            const param = option.param ?? "";
            gifsicleParams.push(option.name), "" !== param && gifsicleParams.push(param.toString());
        })), Buffer$2.isBuffer(data)) buffer = data.buffer; else {
            const buffers = [], stream = await httpsGetStream(data);
            buffer = await new Promise(((resolve, reject) => {
                stream.on("data", (chunk => {
                    buffers.push(chunk);
                })).on("error", (err => reject(err))).on("end", (() => resolve(Buffer$2.concat(buffers).buffer)));
            }));
        }
        const result = (await gifsicle.run({
            input: [ {
                file: buffer,
                name: "1.gif"
            } ],
            command: [ `${gifsicleParams.join(" ")} 1.gif -o /out/out.gif` ]
        }))[0];
        if (!result) return Buffer$2.from([]);
        const arrayBuffer = await result.arrayBuffer();
        return 0 === arrayBuffer.byteLength && retryCount < 5 ? (retryCount++, this.doModification(data, options, retryCount)) : Buffer$2.from(arrayBuffer);
    }
    getCommandIndex(commands, name) {
        const index = commands.findIndex((command => command.name === name));
        return -1 !== index ? index : void 0;
    }
    async processSpecialCommands(options) {
        const {commands} = options;
        let currentBuffer = options.data;
        Logger.info(`Commands count: ${commands.length}`);
        for (const [index, command] of commands.entries()) {
            const value = (command.param ?? 0).toString(), size = (options.size ?? 1).toString();
            currentBuffer = await this.processSpecialCommand({
                name: command.name,
                value: parseFloat(value),
                buffer: currentBuffer,
                type: 0 === index ? options.fileType : "gif",
                size,
                isResized: index > 0
            });
        }
        return currentBuffer;
    }
    processSpecialCommand(command) {
        switch (Logger.info(`Command name: ${command.name}`), command.name) {
          case "rotate":
            return function rotateEmote(options) {
                return "gif" === options.type ? async function createRotatedGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), max = Math.max(inputGif.width, inputGif.height), encoder = new GIFEncoder(max, max);
                    return new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then((buffer => resolve(buffer))).catch(reject), 
                        setEncoderProperties(encoder);
                        const degrees = -options.value, {margin} = prepareRotateVariables(inputGif.width, inputGif.height), {frames} = inputGif;
                        for (let i = 0; i < frames.length; i++) {
                            encoder.setDelay(10 * (frames[i]?.delayCentisecs ?? 0));
                            const adjustedImg = new Jimp(max, max);
                            inputGif.width > inputGif.height ? adjustedImg.blit(new Jimp(frames[i]?.bitmap), 0, margin) : adjustedImg.blit(new Jimp(frames[i]?.bitmap), margin, 0), 
                            adjustedImg.rotate(degrees, !1), encoder.addFrame(adjustedImg.bitmap.data);
                        }
                        encoder.finish();
                    }));
                }(options) : async function createRotatedPNG(options) {
                    if (options.buffer instanceof Buffer) throw Error("Was given a buffer instead of a path");
                    let image = await Jimp.read(options.buffer);
                    const {width, height} = preparePNGVariables(options, image.bitmap), degrees = options.value, {max, margin} = prepareRotateVariables(width, height), encoder = new GIFEncoder(max, max);
                    image.resize(width, height);
                    const resizedImage = new Jimp(max, max);
                    return image = width > height ? resizedImage.blit(image, 0, margin) : resizedImage.blit(image, margin, 0), 
                    new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then((buffer => resolve(buffer))).catch(reject), 
                        setEncoderProperties(encoder, 10 * options.value);
                        const rotatedImage = new Jimp(resizedImage.bitmap);
                        rotatedImage.rotate(degrees, !1), encoder.addFrame(rotatedImage.bitmap.data), encoder.finish();
                    }));
                }(options);
            }(command);

          case "spin":
          case "spinrev":
            return function spinEmote(options) {
                return "gif" === options.type ? async function createSpinningGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), max = Math.max(inputGif.width, inputGif.height), encoder = new GIFEncoder(max, max);
                    return new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then((buffer => resolve(buffer))).catch(reject), 
                        setEncoderProperties(encoder);
                        const {degrees, interval, margin} = prepareSpinVariables(inputGif.frames[0]?.delayCentisecs ?? 0, 200 * options.value / 8, "spinrev" === options.name, inputGif.width, inputGif.height), frames = alignGif(inputGif.frames, interval);
                        for (let i = 0; i < frames.length; i++) {
                            encoder.setDelay(10 * (frames[i]?.delayCentisecs ?? 0));
                            const adjustedImg = new Jimp(max, max);
                            inputGif.width > inputGif.height ? adjustedImg.blit(new Jimp(frames[i]?.bitmap), 0, margin) : adjustedImg.blit(new Jimp(frames[i]?.bitmap), margin, 0), 
                            adjustedImg.rotate(i * degrees % 360, !1), encoder.addFrame(adjustedImg.bitmap.data);
                        }
                        encoder.finish();
                    }));
                }(options) : async function createSpinningPNG(options) {
                    if (options.buffer instanceof Buffer) throw Error("Was given a buffer instead of a path");
                    let image = await Jimp.read(options.buffer);
                    const {width, height} = preparePNGVariables(options, image.bitmap), {degrees, interval, max, margin} = prepareSpinVariables(options.value, 200 * options.value / 8, "spinrev" === options.name, width, height), encoder = new GIFEncoder(max, max);
                    image.resize(width, height);
                    const resizedImage = new Jimp(max, max);
                    return image = width > height ? resizedImage.blit(image, 0, margin) : resizedImage.blit(image, margin, 0), 
                    new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then((buffer => resolve(buffer))).catch(reject), 
                        setEncoderProperties(encoder, 10 * options.value);
                        for (let i = 0; i < interval; i++) {
                            const rotatedImage = new Jimp(resizedImage.bitmap);
                            rotatedImage.rotate(i * degrees, !1), encoder.addFrame(rotatedImage.bitmap.data);
                        }
                        encoder.finish();
                    }));
                }(options);
            }(command);

          case "shake":
            return function shakeEmote(options) {
                return "gif" === options.type ? async function createShakingGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer);
                    let speed = Math.max(2, options.value), delay = inputGif.frames[0]?.delayCentisecs ?? 0, {frames} = inputGif, interval = 1, incrValue = 1;
                    if (delay !== speed) {
                        const padAmount = function lowestCommonDenominator(a, b) {
                            return a * b / greatestCommonDenominator(a, b);
                        }(delay, speed) / speed;
                        if (frames.length * padAmount > 800 && (frames = frames.filter(((_, i) => i % 2 == 0)), 
                        delay *= 2, speed *= 2), frames = function padGif(frames, amountCopies) {
                            if (amountCopies < 2) return src.GifUtil.cloneFrames(frames);
                            const copiedFrames = [];
                            return frames.forEach((frame => {
                                for (let j = 0; j < amountCopies; j++) copiedFrames.push(new src.GifFrame(frame.bitmap));
                            })), copiedFrames;
                        }(frames, padAmount), delay > speed ? (delay /= padAmount, interval = speed / greatestCommonDenominator(delay, speed), 
                        1 === delay && (interval /= 2)) : delay < speed && (delay /= padAmount, incrValue = greatestCommonDenominator(delay, speed) / speed, 
                        1 === delay && (incrValue /= 2)), 1 === delay) {
                            if (frames.length % 2 != 0) {
                                const frameToDelete = Math.floor(Math.random() * frames.length - 1) + 1;
                                frames.splice(frameToDelete, 1);
                            }
                            frames = frames.filter(((_, i) => i % 2 == 0)), delay = 2;
                        }
                        incrValue *= 4;
                    }
                    let dx = 0, dy = 0, sx = 1, sy = 1, offsets = 3, state = 0;
                    const encoder = new GIFEncoder(inputGif.width, inputGif.height);
                    return new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then((buffer => resolve(buffer))).catch(reject), 
                        setEncoderProperties(encoder, 10 * delay);
                        for (let i = 0; i < frames.length; i++) {
                            state += incrValue, state >= interval && (state -= interval, offsets <<= 1, offsets > 16 && (offsets -= 15), 
                            dx = offsets >> 3, dy = offsets >> 2 & 1, sx = offsets >> 1 & 1, sy = 1 & offsets);
                            const shakenFrame = new Jimp(inputGif.width, inputGif.height, 0x00);
                            shakenFrame.blit(new Jimp(frames[i]?.bitmap), dx, dy, sx, sy, inputGif.width - 1, inputGif.height - 1), 
                            encoder.addFrame(shakenFrame.bitmap.data);
                        }
                        encoder.finish();
                    }));
                }(options) : async function createShakingPNG(options) {
                    if (options.buffer instanceof Buffer) throw Error("Was given a buffer instead of a path");
                    const image = await Jimp.read(options.buffer), {width, height, encoder} = preparePNGVariables(options, image.bitmap);
                    return image.resize(width, height), new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then((buffer => resolve(buffer))).catch(reject), 
                        setEncoderProperties(encoder, 10 * options.value);
                        for (let i = 0; i < 4; i++) {
                            const frame = new Jimp(width, height, 0x00);
                            switch (i) {
                              case 0:
                                frame.blit(new Jimp(image.bitmap), 0, 0, 1, 1, width - 1, height - 1);
                                break;

                              case 1:
                                frame.blit(new Jimp(image.bitmap), 0, 1, 1, 0, width - 1, height - 1);
                                break;

                              case 2:
                                frame.blit(new Jimp(image.bitmap), 1, 1, 0, 0, width - 1, height - 1);
                                break;

                              case 3:
                                frame.blit(new Jimp(image.bitmap), 1, 0, 0, 1, width - 1, height - 1);
                            }
                            encoder.addFrame(frame.bitmap.data);
                        }
                        encoder.finish();
                    }));
                }(options);
            }(command);

          case "rainbow":
            return function rainbowEmote(options) {
                return "gif" === options.type ? async function createRainbowGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), encoder = new GIFEncoder(inputGif.width, inputGif.height);
                    return new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then((buffer => resolve(buffer))).catch(reject), 
                        setEncoderProperties(encoder);
                        const interval = 32 * options.value, frames = alignGif(inputGif.frames, interval), randomBlack = Math.random(), randomWhite = Math.random();
                        frames.forEach(((frame, index) => {
                            encoder.setDelay(10 * frame.delayCentisecs), shiftColors(frame.bitmap, index % interval / interval, randomBlack, randomWhite), 
                            encoder.addFrame(frame.bitmap.data);
                        })), encoder.finish();
                    }));
                }(options) : async function createRainbowPNG(options) {
                    if (options.buffer instanceof Buffer) throw Error("Was given a buffer instead of a path");
                    const image = await Jimp.read(options.buffer), {width, height, encoder} = preparePNGVariables(options, image.bitmap);
                    return image.resize(width, height), new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then((buffer => resolve(buffer))).catch(reject), 
                        setEncoderProperties(encoder, 10 * options.value);
                        const randomBlack = Math.random(), randomWhite = Math.random();
                        for (let i = 0; i < 32; i++) shiftColors(image.bitmap, .03125, randomBlack, randomWhite), 
                        encoder.addFrame(image.bitmap.data);
                        encoder.finish();
                    }));
                }(options);
            }(command);

          case "wiggle":
            return function wiggleEmote(options) {
                return "gif" === options.type ? async function createWigglingGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), encoder = new GIFEncoder(inputGif.width, inputGif.height);
                    return new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then(resolve).catch(reject), setEncoderProperties(encoder);
                        const margin = inputGif.width + 2 * Math.floor(inputGif.width * options.value * 0.1 / 15) - inputGif.width, wiggleVariables = prepareWiggleVariables(margin, inputGif.height), {shiftSize, interval, stripeHeight} = wiggleVariables;
                        let {shift, left} = wiggleVariables;
                        alignGif(inputGif.frames, interval).forEach((frame => {
                            encoder.setDelay(10 * frame.delayCentisecs);
                            const wiggledBitmap = getWiggledFrameData(new Jimp(frame.bitmap), shift, left, {
                                stripeHeight,
                                shiftSize,
                                width: inputGif.width,
                                margin
                            });
                            encoder.addFrame(wiggledBitmap.data), [shift, left] = shiftWiggleStep(shift, left, margin, shiftSize);
                        })), encoder.finish();
                    }));
                }(options) : async function createWigglingPNG(options) {
                    if (options.buffer instanceof Buffer) throw Error("Was given a buffer instead of a path");
                    const image = await Jimp.read(options.buffer), {width: imgWidth, height} = preparePNGVariables(options, image.bitmap);
                    image.resize(imgWidth, height);
                    const width = imgWidth + 2 * Math.floor(imgWidth * options.value * 0.1 / 15), margin = width - imgWidth, encoder = new GIFEncoder(width, height), wiggleVariables = prepareWiggleVariables(margin, height), {shiftSize, interval, stripeHeight} = wiggleVariables;
                    let {shift, left} = wiggleVariables;
                    return new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then(resolve).catch(reject), setEncoderProperties(encoder, 80);
                        for (let i = 0; i < interval; i++) {
                            const wiggledBitmap = getWiggledFrameData(image, shift, left, {
                                stripeHeight,
                                shiftSize,
                                width,
                                margin
                            });
                            encoder.addFrame(wiggledBitmap.data), [shift, left] = shiftWiggleStep(shift, left, margin, shiftSize);
                        }
                        encoder.finish();
                    }));
                }(options);
            }(command);

          case "infinite":
            return function infiniteEmote(options) {
                return "gif" === options.type ? async function createInfiniteGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), encoder = new GIFEncoder(inputGif.width, inputGif.height);
                    return new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then(resolve).catch(reject), setEncoderProperties(encoder);
                        const scaleStep = .24 / options.value;
                        let scales = resetInfiniteScales(5, .9, scaleStep);
                        alignGif(inputGif.frames, .9 / scaleStep).forEach((frame => {
                            encoder.setDelay(10 * frame.delayCentisecs);
                            const frameData = getInfiniteShiftedFrameData(frame.bitmap, scales);
                            encoder.addFrame(frameData.data), scales = shiftInfiniteScales(scales, .9, scaleStep);
                        })), encoder.finish();
                    }));
                }(options) : async function createInfinitePNG(options) {
                    if (options.buffer instanceof Buffer) throw Error("Was given a buffer instead of a path");
                    const image = await Jimp.read(options.buffer), {width, height, encoder} = preparePNGVariables(options, image.bitmap);
                    return image.resize(width, height), new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then(resolve).catch(reject), setEncoderProperties(encoder, 10 * options.value);
                        let scales = resetInfiniteScales(5, .9, .06);
                        for (let i = 0; i < 14.000000000000002; i++) {
                            const frameData = getInfiniteShiftedFrameData(image.bitmap, scales);
                            encoder.addFrame(frameData.data), scales = shiftInfiniteScales(scales, .9, .06);
                        }
                        encoder.finish();
                    }));
                }(options);
            }(command);

          case "slide":
          case "sliderev":
            return function slideEmote(options) {
                return "gif" === options.type ? async function createSlidingGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), encoder = new GIFEncoder(inputGif.width, inputGif.height);
                    return new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then(resolve).catch(reject), setEncoderProperties(encoder);
                        const {width} = inputGif, slidingVariables = prepareSlidingVariables(width, options.value), {interval, shiftSize} = slidingVariables;
                        let {shift} = slidingVariables;
                        const frames = alignGif(inputGif.frames, interval), direction = "sliderev" === options.name ? 1 : -1;
                        frames.forEach((frame => {
                            encoder.setDelay(10 * frame.delayCentisecs);
                            const shiftedBitmap = getShiftedFrameData(new Jimp(frame.bitmap), shift);
                            encoder.addFrame(shiftedBitmap.data), shift = (shift + direction * shiftSize) % width;
                        })), encoder.finish();
                    }));
                }(options) : async function createSlidingPNG(options) {
                    if (options.buffer instanceof Buffer) throw Error("Was given a buffer instead of a path");
                    const image = await Jimp.read(options.buffer), {width, height, encoder} = preparePNGVariables(options, image.bitmap);
                    image.resize(width, height);
                    const slidingVariables = prepareSlidingVariables(width, options.value), {interval, shiftSize} = slidingVariables;
                    let {shift} = slidingVariables;
                    return new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then(resolve).catch(reject), setEncoderProperties(encoder, 40);
                        const direction = "sliderev" === options.name ? 1 : -1;
                        for (let i = 0; i < interval; i++) {
                            const frameData = getShiftedFrameData(image, shift);
                            encoder.addFrame(frameData.data), shift = (shift + direction * shiftSize) % width;
                        }
                        encoder.finish();
                    }));
                }(options);
            }(command);

          case "rain":
            return function rainEmote(options) {
                return "gif" === options.type ? async function createRainingGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), encoder = new GIFEncoder(inputGif.width, inputGif.height);
                    return new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then((buffer => resolve(buffer))).catch(reject), 
                        setEncoderProperties(encoder);
                        const {frames} = inputGif, glitter = 1 === options.value, rainGenerator = rainImageGenerator(inputGif.width, inputGif.height, glitter, frames[0]?.delayCentisecs ?? 0);
                        frames.forEach((frame => {
                            encoder.setDelay(10 * frame.delayCentisecs);
                            const jimpFrame = new Jimp(frame.bitmap);
                            jimpFrame.blit(rainGenerator.next(), 0, 0), encoder.addFrame(jimpFrame.bitmap.data);
                        })), encoder.finish();
                    }));
                }(options) : async function createRainingPNG(options) {
                    if (options.buffer instanceof Buffer) throw Error("Was given a buffer instead of a path");
                    const image = await Jimp.read(options.buffer), {width, height, encoder} = preparePNGVariables(options, image.bitmap);
                    return image.resize(width, height), new Promise(((resolve, reject) => {
                        getBuffer(encoder.createReadStream()).then(resolve).catch(reject), setEncoderProperties(encoder, 80);
                        const glitter = 1 === options.value, rainGenerator = rainImageGenerator(width, height, glitter, 8);
                        for (let i = 0; i < 12; i++) {
                            const img = new Jimp(image.bitmap);
                            img.blit(rainGenerator.next(), 0, 0), encoder.addFrame(img.bitmap.data);
                        }
                        encoder.finish();
                    }));
                }(options);
            }(command);

          default:
            return Promise.resolve(command.buffer);
        }
    }
    async processNormalCommands(buffer, _commands) {
        let commands = _commands;
        const info = await this.doModification(buffer, [ {
            name: "-I"
        } ]);
        commands.unshift({
            name: "-U"
        });
        const hyperspeedIndex = this.getCommandIndex(commands, "hyperspeed");
        return void 0 !== hyperspeedIndex && (commands.splice(hyperspeedIndex, 1), commands = this.removeEveryOtherFrame(2, commands, info)), 
        this.doModification(buffer, commands);
    }
    removeEveryOtherFrame(frameInterval, commands, data) {
        commands.push({
            name: "-d2"
        });
        const frameCount = data.toString("utf8").split("image #").length - 1;
        if (frameCount <= 4) return commands;
        commands.push({
            name: "--delete"
        });
        for (let i = 1; i < frameCount; i += frameInterval) commands.push({
            name: `#${i}`
        });
        return commands;
    }
    stop() {}
}

class ModulesService extends BaseService {
    selectedChannelStore;
    channelStore;
    uploader;
    draft;
    permissions;
    discordPermissions;
    dispatcher;
    componentDispatcher;
    deletePendingReply;
    emojiStore;
    emojiSearch;
    discordConstants;
    userStore;
    messageStore;
    classes;
    start() {
        const [selectedChannelStore, channelStore, uploader, draft, permissions, discordPermissions, dispatcher, componentDispatcher, deletePendingReply, emojiStore, emojiSearch, discordConstants, userStore, messageStore, TextArea, Autocomplete, autocompleteAttached, Wrapper, Size] = BdApi.Webpack.getBulk({
            filter: BdApi.Webpack.Filters.byProps("getChannelId", "getVoiceChannelId")
        }, {
            filter: BdApi.Webpack.Filters.byProps("getChannel", "hasChannel")
        }, {
            filter: BdApi.Webpack.Filters.byProps("instantBatchUpload")
        }, {
            filter: BdApi.Webpack.Filters.byProps("changeDraft")
        }, {
            filter: BdApi.Webpack.Filters.byProps("getChannelPermissions")
        }, {
            filter: BdApi.Webpack.Filters.byProps("Permissions", "ActivityTypes", "StatusTypes")
        }, {
            filter: BdApi.Webpack.Filters.byProps("dispatch", "subscribe")
        }, {
            filter: BdApi.Webpack.Filters.byProps("ComponentDispatch")
        }, {
            filter: BdApi.Webpack.Filters.byProps("deletePendingReply")
        }, {
            filter: BdApi.Webpack.Filters.byProps("getEmojiUnavailableReason")
        }, {
            filter: BdApi.Webpack.Filters.byProps("getDisambiguatedEmojiContext")
        }, {
            filter: BdApi.Webpack.Filters.byProps("EmojiDisabledReasons")
        }, {
            filter: BdApi.Webpack.Filters.byProps("getCurrentUser")
        }, {
            filter: BdApi.Webpack.Filters.byProps("sendMessage")
        }, {
            filter: BdApi.Webpack.Filters.byProps("channelTextArea", "textAreaHeight")
        }, {
            filter: BdApi.Webpack.Filters.byProps("autocomplete", "autocompleteInner", "autocompleteRowVertical")
        }, {
            filter: BdApi.Webpack.Filters.byProps("autocomplete", "autocompleteAttached")
        }, {
            filter: BdApi.Webpack.Filters.byProps("wrapper", "base")
        }, {
            filter: BdApi.Webpack.Filters.byProps("size12")
        });
        return this.selectedChannelStore = selectedChannelStore, this.channelStore = channelStore, 
        this.uploader = uploader, this.draft = draft, this.permissions = permissions, this.discordPermissions = discordPermissions, 
        this.dispatcher = dispatcher, this.componentDispatcher = componentDispatcher, this.deletePendingReply = deletePendingReply, 
        this.emojiSearch = emojiSearch, this.discordConstants = discordConstants, this.emojiStore = emojiStore, 
        this.userStore = userStore, this.messageStore = messageStore, this.classes = {
            TextArea,
            Autocomplete: {
                ...Autocomplete,
                autocomplete: [ autocompleteAttached?.autocomplete, autocompleteAttached?.autocompleteAttached, Autocomplete?.autocomplete ].join(" ")
            },
            Wrapper,
            Size
        }, Promise.resolve();
    }
    stop() {}
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/ var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
    if (null == val) throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(val);
}

var wa, objectAssign = function shouldUseNative() {
    try {
        if (!Object.assign) return !1;
        var test1 = new String("abc");
        if (test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) return !1;
        for (var test2 = {}, i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
        if ("0123456789" !== Object.getOwnPropertyNames(test2).map((function(n) {
            return test2[n];
        })).join("")) return !1;
        var test3 = {};
        return "abcdefghijklmnopqrst".split("").forEach((function(letter) {
            test3[letter] = letter;
        })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, test3)).join("");
    } catch (err) {
        return !1;
    }
}() ? Object.assign : function(target, source) {
    for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
        for (var key in from = Object(arguments[s])) hasOwnProperty.call(from, key) && (to[key] = from[key]);
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
        }
    }
    return to;
}, bundleFn = arguments[3], sources = arguments[4], cache = arguments[5], stringify = JSON.stringify, assign$1 = objectAssign, DEFAULT_OPTIONS = {
    js: !0,
    wasm: !0
};

function MultiMath(options) {
    if (!(this instanceof MultiMath)) return new MultiMath(options);
    var opts = assign$1({}, DEFAULT_OPTIONS, options || {});
    if (this.options = opts, this.__cache = {}, this.__init_promise = null, this.__modules = opts.modules || {}, 
    this.__memory = null, this.__wasm = {}, this.__isLE = 1 === new Uint32Array(new Uint8Array([ 1, 0, 0, 0 ]).buffer)[0], 
    !this.options.js && !this.options.wasm) throw new Error('mathlib: at least "js" or "wasm" should be enabled');
}

MultiMath.prototype.has_wasm = function hasWebAssembly() {
    if (void 0 !== wa) return wa;
    if (wa = !1, "undefined" == typeof WebAssembly) return wa;
    try {
        var bin = new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 127, 1, 127, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 8, 1, 4, 116, 101, 115, 116, 0, 0, 10, 16, 1, 14, 0, 32, 0, 65, 1, 54, 2, 0, 32, 0, 40, 2, 0, 11 ]), module = new WebAssembly.Module(bin);
        return 0 !== new WebAssembly.Instance(module, {}).exports.test(4) && (wa = !0), 
        wa;
    } catch (__) {}
    return wa;
}, MultiMath.prototype.use = function(module) {
    return this.__modules[module.name] = module, this.options.wasm && this.has_wasm() && module.wasm_fn ? this[module.name] = module.wasm_fn : this[module.name] = module.fn, 
    this;
}, MultiMath.prototype.init = function() {
    if (this.__init_promise) return this.__init_promise;
    if (!this.options.js && this.options.wasm && !this.has_wasm()) return Promise.reject(new Error('mathlib: only "wasm" was enabled, but it\'s not supported'));
    var self = this;
    return this.__init_promise = Promise.all(Object.keys(self.__modules).map((function(name) {
        var module = self.__modules[name];
        return self.options.wasm && self.has_wasm() && module.wasm_fn ? self.__wasm[name] ? null : WebAssembly.compile(self.__base64decode(module.wasm_src)).then((function(m) {
            self.__wasm[name] = m;
        })) : null;
    }))).then((function() {
        return self;
    })), this.__init_promise;
}, MultiMath.prototype.__base64decode = function base64decode(str) {
    for (var input = str.replace(/[\r\n=]/g, ""), max = input.length, out = new Uint8Array(3 * max >> 2), bits = 0, ptr = 0, idx = 0; idx < max; idx++) idx % 4 == 0 && idx && (out[ptr++] = bits >> 16 & 0xFF, 
    out[ptr++] = bits >> 8 & 0xFF, out[ptr++] = 0xFF & bits), bits = bits << 6 | "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(input.charAt(idx));
    var tailbits = max % 4 * 6;
    return 0 === tailbits ? (out[ptr++] = bits >> 16 & 0xFF, out[ptr++] = bits >> 8 & 0xFF, 
    out[ptr++] = 0xFF & bits) : 18 === tailbits ? (out[ptr++] = bits >> 10 & 0xFF, out[ptr++] = bits >> 2 & 0xFF) : 12 === tailbits && (out[ptr++] = bits >> 4 & 0xFF), 
    out;
}, MultiMath.prototype.__reallocate = function mem_grow_to(bytes) {
    if (!this.__memory) return this.__memory = new WebAssembly.Memory({
        initial: Math.ceil(bytes / 65536)
    }), this.__memory;
    var mem_size = this.__memory.buffer.byteLength;
    return mem_size < bytes && this.__memory.grow(Math.ceil((bytes - mem_size) / 65536)), 
    this.__memory;
}, MultiMath.prototype.__instance = function instance(name, memsize, env_extra) {
    if (memsize && this.__reallocate(memsize), !this.__wasm[name]) {
        var module = this.__modules[name];
        this.__wasm[name] = new WebAssembly.Module(this.__base64decode(module.wasm_src));
    }
    if (!this.__cache[name]) {
        var env_base = {
            memoryBase: 0,
            memory: this.__memory,
            tableBase: 0,
            table: new WebAssembly.Table({
                initial: 0,
                element: "anyfunc"
            })
        };
        this.__cache[name] = new WebAssembly.Instance(this.__wasm[name], {
            env: assign$1(env_base, env_extra || {})
        });
    }
    return this.__cache[name];
}, MultiMath.prototype.__align = function align(number, base) {
    var reminder = number % (base = base || 8);
    return number + (reminder ? base - reminder : 0);
};

var a0, a1, a2, a3, b1, b2, multimath = MultiMath;

function convolveMono16(src, out, line, coeff, width, height) {
    var prev_src, curr_src, curr_out, prev_out, prev_prev_out, src_index, out_index, line_index, i, j, coeff_a0, coeff_a1, coeff_b1, coeff_b2;
    for (i = 0; i < height; i++) {
        for (out_index = i, line_index = 0, prev_out = prev_prev_out = (prev_src = src[src_index = i * width]) * coeff[6], 
        coeff_a0 = coeff[0], coeff_a1 = coeff[1], coeff_b1 = coeff[4], coeff_b2 = coeff[5], 
        j = 0; j < width; j++) curr_out = (curr_src = src[src_index]) * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2, 
        prev_prev_out = prev_out, prev_out = curr_out, prev_src = curr_src, line[line_index] = prev_out, 
        line_index++, src_index++;
        for (line_index--, out_index += height * (width - 1), prev_out = prev_prev_out = (prev_src = src[--src_index]) * coeff[7], 
        curr_src = prev_src, coeff_a0 = coeff[2], coeff_a1 = coeff[3], j = width - 1; j >= 0; j--) curr_out = curr_src * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2, 
        prev_prev_out = prev_out, prev_out = curr_out, prev_src = curr_src, curr_src = src[src_index], 
        out[out_index] = line[line_index] + prev_out, src_index--, line_index--, out_index -= height;
    }
}

var mm_unsharp_mask$1 = {
    name: "unsharp_mask",
    fn: function unsharp(img, width, height, amount, radius, threshold) {
        var v1, v2, vmul, diff, iTimes4;
        if (!(0 === amount || radius < 0.5)) {
            radius > 2.0 && (radius = 2.0);
            var brightness = function hsv_v16(img, width, height) {
                for (var r, g, b, max, size = width * height, out = new Uint16Array(size), i = 0; i < size; i++) r = img[4 * i], 
                g = img[4 * i + 1], b = img[4 * i + 2], max = r >= g && r >= b ? r : g >= b && g >= r ? g : b, 
                out[i] = max << 8;
                return out;
            }(img, width, height), blured = new Uint16Array(brightness);
            !function blurMono16(src, width, height, radius) {
                if (radius) {
                    var out = new Uint16Array(src.length), tmp_line = new Float32Array(Math.max(width, height)), coeff = function gaussCoef(sigma) {
                        sigma < 0.5 && (sigma = 0.5);
                        var a = Math.exp(.527076) / sigma, g1 = Math.exp(-a), g2 = Math.exp(-2 * a), k = (1 - g1) * (1 - g1) / (1 + 2 * a * g1 - g2);
                        return a0 = k, a1 = k * (a - 1) * g1, a2 = k * (a + 1) * g1, a3 = -k * g2, b1 = 2 * g1, 
                        b2 = -g2, new Float32Array([ a0, a1, a2, a3, b1, b2, (a0 + a1) / (1 - b1 - b2), (a2 + a3) / (1 - b1 - b2) ]);
                    }(radius);
                    convolveMono16(src, out, tmp_line, coeff, width, height), convolveMono16(out, src, tmp_line, coeff, height, width);
                }
            }(blured, width, height, radius);
            for (var amountFp = amount / 100 * 0x1000 + 0.5 | 0, thresholdFp = threshold << 8, size = width * height, i = 0; i < size; i++) diff = (v1 = brightness[i]) - blured[i], 
            Math.abs(diff) >= thresholdFp && (vmul = ((v2 = (v2 = (v2 = v1 + (amountFp * diff + 0x800 >> 12)) > 0xff00 ? 0xff00 : v2) < 0x0000 ? 0x0000 : v2) << 12) / (v1 = 0 !== v1 ? v1 : 1) | 0, 
            img[iTimes4 = 4 * i] = img[iTimes4] * vmul + 0x800 >> 12, img[iTimes4 + 1] = img[iTimes4 + 1] * vmul + 0x800 >> 12, 
            img[iTimes4 + 2] = img[iTimes4 + 2] * vmul + 0x800 >> 12);
        }
    },
    wasm_fn: function unsharp(img, width, height, amount, radius, threshold) {
        if (!(0 === amount || radius < 0.5)) {
            radius > 2.0 && (radius = 2.0);
            var pixels = width * height, img_bytes_cnt = 4 * pixels, hsv_bytes_cnt = 2 * pixels, blur_bytes_cnt = 2 * pixels, blur_line_byte_cnt = 4 * Math.max(width, height), hsv_offset = img_bytes_cnt, blur_offset = hsv_offset + hsv_bytes_cnt, blur_tmp_offset = blur_offset + blur_bytes_cnt, blur_line_offset = blur_tmp_offset + blur_bytes_cnt, blur_coeffs_offset = blur_line_offset + blur_line_byte_cnt, instance = this.__instance("unsharp_mask", img_bytes_cnt + hsv_bytes_cnt + 2 * blur_bytes_cnt + blur_line_byte_cnt + 32, {
                exp: Math.exp
            }), img32 = new Uint32Array(img.buffer);
            new Uint32Array(this.__memory.buffer).set(img32);
            var fn = instance.exports.hsv_v16 || instance.exports._hsv_v16;
            fn(0, hsv_offset, width, height), (fn = instance.exports.blurMono16 || instance.exports._blurMono16)(hsv_offset, blur_offset, blur_tmp_offset, blur_line_offset, blur_coeffs_offset, width, height, radius), 
            (fn = instance.exports.unsharp || instance.exports._unsharp)(0, 0, hsv_offset, blur_offset, width, height, amount, threshold), 
            img32.set(new Uint32Array(this.__memory.buffer, 0, pixels));
        }
    },
    wasm_src: "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"
};

const filter = {
    box: {
        win: 0.5,
        fn: function(x) {
            return x < 0 && (x = -x), x < 0.5 ? 1.0 : 0.0;
        }
    },
    hamming: {
        win: 1.0,
        fn: function(x) {
            if (x < 0 && (x = -x), x >= 1.0) return 0.0;
            if (x < 1.19209290E-07) return 1.0;
            var xpi = x * Math.PI;
            return Math.sin(xpi) / xpi * (0.54 + 0.46 * Math.cos(xpi / 1.0));
        }
    },
    lanczos2: {
        win: 2.0,
        fn: function(x) {
            if (x < 0 && (x = -x), x >= 2.0) return 0.0;
            if (x < 1.19209290E-07) return 1.0;
            var xpi = x * Math.PI;
            return Math.sin(xpi) / xpi * Math.sin(xpi / 2.0) / (xpi / 2.0);
        }
    },
    lanczos3: {
        win: 3.0,
        fn: function(x) {
            if (x < 0 && (x = -x), x >= 3.0) return 0.0;
            if (x < 1.19209290E-07) return 1.0;
            var xpi = x * Math.PI;
            return Math.sin(xpi) / xpi * Math.sin(xpi / 3.0) / (xpi / 3.0);
        }
    },
    mks2013: {
        win: 2.5,
        fn: function(x) {
            return x < 0 && (x = -x), x >= 2.5 ? 0.0 : x >= 1.5 ? -0.125 * (x - 2.5) * (x - 2.5) : x >= 0.5 ? 0.25 * (4 * x * x - 11 * x + 7) : 1.0625 - 1.75 * x * x;
        }
    }
};

var resize_filter_info = {
    filter,
    f2q: {
        box: 0,
        hamming: 1,
        lanczos2: 2,
        lanczos3: 3
    },
    q2f: [ "box", "hamming", "lanczos2", "lanczos3" ]
}, FILTER_INFO = resize_filter_info;

function toFixedPoint(num) {
    return Math.round(16383 * num);
}

var resize_filter_gen = function resizeFilterGen(filter, srcSize, destSize, scale, offset) {
    var destPixel, srcPixel, srcFirst, srcLast, filterElementSize, floatFilter, fxpFilter, total, pxl, idx, floatVal, filterTotal, filterVal, leftNotEmpty, rightNotEmpty, filterShift, filterSize, filterFunction = FILTER_INFO.filter[filter].fn, scaleInverted = 1.0 / scale, scaleClamped = Math.min(1.0, scale), srcWindow = FILTER_INFO.filter[filter].win / scaleClamped, maxFilterElementSize = Math.floor(2 * (srcWindow + 1)), packedFilter = new Int16Array((maxFilterElementSize + 2) * destSize), packedFilterPtr = 0, slowCopy = !packedFilter.subarray || !packedFilter.set;
    for (destPixel = 0; destPixel < destSize; destPixel++) {
        for (srcPixel = (destPixel + 0.5) * scaleInverted + offset, srcFirst = Math.max(0, Math.floor(srcPixel - srcWindow)), 
        filterElementSize = (srcLast = Math.min(srcSize - 1, Math.ceil(srcPixel + srcWindow))) - srcFirst + 1, 
        floatFilter = new Float32Array(filterElementSize), fxpFilter = new Int16Array(filterElementSize), 
        total = 0.0, pxl = srcFirst, idx = 0; pxl <= srcLast; pxl++, idx++) total += floatVal = filterFunction((pxl + 0.5 - srcPixel) * scaleClamped), 
        floatFilter[idx] = floatVal;
        for (filterTotal = 0, idx = 0; idx < floatFilter.length; idx++) filterTotal += filterVal = floatFilter[idx] / total, 
        fxpFilter[idx] = toFixedPoint(filterVal);
        for (fxpFilter[destSize >> 1] += toFixedPoint(1.0 - filterTotal), leftNotEmpty = 0; leftNotEmpty < fxpFilter.length && 0 === fxpFilter[leftNotEmpty]; ) leftNotEmpty++;
        if (leftNotEmpty < fxpFilter.length) {
            for (rightNotEmpty = fxpFilter.length - 1; rightNotEmpty > 0 && 0 === fxpFilter[rightNotEmpty]; ) rightNotEmpty--;
            if (filterShift = srcFirst + leftNotEmpty, filterSize = rightNotEmpty - leftNotEmpty + 1, 
            packedFilter[packedFilterPtr++] = filterShift, packedFilter[packedFilterPtr++] = filterSize, 
            slowCopy) for (idx = leftNotEmpty; idx <= rightNotEmpty; idx++) packedFilter[packedFilterPtr++] = fxpFilter[idx]; else packedFilter.set(fxpFilter.subarray(leftNotEmpty, rightNotEmpty + 1), packedFilterPtr), 
            packedFilterPtr += filterSize;
        } else packedFilter[packedFilterPtr++] = 0, packedFilter[packedFilterPtr++] = 0;
    }
    return packedFilter;
};

function clampTo8(i) {
    return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clampNegative(i) {
    return i >= 0 ? i : 0;
}

var convolve = {
    convolveHor: function convolveHor$1(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a, filterPtr, filterShift, filterSize, srcPtr, srcY, destX, filterVal, srcOffset = 0, destOffset = 0;
        for (srcY = 0; srcY < srcH; srcY++) {
            for (filterPtr = 0, destX = 0; destX < destW; destX++) {
                for (filterShift = filters[filterPtr++], filterSize = filters[filterPtr++], srcPtr = srcOffset + 4 * filterShift | 0, 
                r = g = b = a = 0; filterSize > 0; filterSize--) a = a + (filterVal = filters[filterPtr++]) * src[srcPtr + 3] | 0, 
                b = b + filterVal * src[srcPtr + 2] | 0, g = g + filterVal * src[srcPtr + 1] | 0, 
                r = r + filterVal * src[srcPtr] | 0, srcPtr = srcPtr + 4 | 0;
                dest[destOffset + 3] = clampNegative(a >> 7), dest[destOffset + 2] = clampNegative(b >> 7), 
                dest[destOffset + 1] = clampNegative(g >> 7), dest[destOffset] = clampNegative(r >> 7), 
                destOffset = destOffset + 4 * srcH | 0;
            }
            destOffset = 4 * (srcY + 1) | 0, srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
    },
    convolveVert: function convolveVert$1(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a, filterPtr, filterShift, filterSize, srcPtr, srcY, destX, filterVal, srcOffset = 0, destOffset = 0;
        for (srcY = 0; srcY < srcH; srcY++) {
            for (filterPtr = 0, destX = 0; destX < destW; destX++) {
                for (filterShift = filters[filterPtr++], filterSize = filters[filterPtr++], srcPtr = srcOffset + 4 * filterShift | 0, 
                r = g = b = a = 0; filterSize > 0; filterSize--) a = a + (filterVal = filters[filterPtr++]) * src[srcPtr + 3] | 0, 
                b = b + filterVal * src[srcPtr + 2] | 0, g = g + filterVal * src[srcPtr + 1] | 0, 
                r = r + filterVal * src[srcPtr] | 0, srcPtr = srcPtr + 4 | 0;
                r >>= 7, g >>= 7, b >>= 7, a >>= 7, dest[destOffset + 3] = clampTo8(a + 8192 >> 14), 
                dest[destOffset + 2] = clampTo8(b + 8192 >> 14), dest[destOffset + 1] = clampTo8(g + 8192 >> 14), 
                dest[destOffset] = clampTo8(r + 8192 >> 14), destOffset = destOffset + 4 * srcH | 0;
            }
            destOffset = 4 * (srcY + 1) | 0, srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
    },
    convolveHorWithPre: function convolveHorWithPre$1(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a, alpha, filterPtr, filterShift, filterSize, srcPtr, srcY, destX, filterVal, srcOffset = 0, destOffset = 0;
        for (srcY = 0; srcY < srcH; srcY++) {
            for (filterPtr = 0, destX = 0; destX < destW; destX++) {
                for (filterShift = filters[filterPtr++], filterSize = filters[filterPtr++], srcPtr = srcOffset + 4 * filterShift | 0, 
                r = g = b = a = 0; filterSize > 0; filterSize--) a = a + (filterVal = filters[filterPtr++]) * (alpha = src[srcPtr + 3]) | 0, 
                b = b + filterVal * src[srcPtr + 2] * alpha | 0, g = g + filterVal * src[srcPtr + 1] * alpha | 0, 
                r = r + filterVal * src[srcPtr] * alpha | 0, srcPtr = srcPtr + 4 | 0;
                b = b / 255 | 0, g = g / 255 | 0, r = r / 255 | 0, dest[destOffset + 3] = clampNegative(a >> 7), 
                dest[destOffset + 2] = clampNegative(b >> 7), dest[destOffset + 1] = clampNegative(g >> 7), 
                dest[destOffset] = clampNegative(r >> 7), destOffset = destOffset + 4 * srcH | 0;
            }
            destOffset = 4 * (srcY + 1) | 0, srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
    },
    convolveVertWithPre: function convolveVertWithPre$1(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a, filterPtr, filterShift, filterSize, srcPtr, srcY, destX, filterVal, srcOffset = 0, destOffset = 0;
        for (srcY = 0; srcY < srcH; srcY++) {
            for (filterPtr = 0, destX = 0; destX < destW; destX++) {
                for (filterShift = filters[filterPtr++], filterSize = filters[filterPtr++], srcPtr = srcOffset + 4 * filterShift | 0, 
                r = g = b = a = 0; filterSize > 0; filterSize--) a = a + (filterVal = filters[filterPtr++]) * src[srcPtr + 3] | 0, 
                b = b + filterVal * src[srcPtr + 2] | 0, g = g + filterVal * src[srcPtr + 1] | 0, 
                r = r + filterVal * src[srcPtr] | 0, srcPtr = srcPtr + 4 | 0;
                r >>= 7, g >>= 7, b >>= 7, (a = clampTo8(8192 + (a >>= 7) >> 14)) > 0 && (r = 255 * r / a | 0, 
                g = 255 * g / a | 0, b = 255 * b / a | 0), dest[destOffset + 3] = a, dest[destOffset + 2] = clampTo8(b + 8192 >> 14), 
                dest[destOffset + 1] = clampTo8(g + 8192 >> 14), dest[destOffset] = clampTo8(r + 8192 >> 14), 
                destOffset = destOffset + 4 * srcH | 0;
            }
            destOffset = 4 * (srcY + 1) | 0, srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
    }
};

const createFilters$1 = resize_filter_gen, {convolveHor, convolveVert, convolveHorWithPre, convolveVertWithPre} = convolve, createFilters = resize_filter_gen;

let IS_LE = !0;

try {
    IS_LE = 1 === new Uint32Array(new Uint8Array([ 1, 0, 0, 0 ]).buffer)[0];
} catch (__) {}

function copyInt16asLE(src, target, target_offset) {
    if (IS_LE) target.set(function asUint8Array(src) {
        return new Uint8Array(src.buffer, 0, src.byteLength);
    }(src), target_offset); else for (let ptr = target_offset, i = 0; i < src.length; i++) {
        let data = src[i];
        target[ptr++] = 0xFF & data, target[ptr++] = data >> 8 & 0xFF;
    }
}

var mm_resize$1 = {
    name: "resize",
    fn: function resize(options) {
        const src = options.src, srcW = options.width, srcH = options.height, destW = options.toWidth, destH = options.toHeight, scaleX = options.scaleX || options.toWidth / options.width, scaleY = options.scaleY || options.toHeight / options.height, offsetX = options.offsetX || 0, offsetY = options.offsetY || 0, dest = options.dest || new Uint8Array(destW * destH * 4), filter = void 0 === options.filter ? "mks2013" : options.filter, filtersX = createFilters$1(filter, srcW, destW, scaleX, offsetX), filtersY = createFilters$1(filter, srcH, destH, scaleY, offsetY), tmp = new Uint16Array(destW * srcH * 4);
        return function hasAlpha$1(src, width, height) {
            let ptr = 3, len = width * height * 4 | 0;
            for (;ptr < len; ) {
                if (255 !== src[ptr]) return !0;
                ptr = ptr + 4 | 0;
            }
            return !1;
        }(src, srcW, srcH) ? (convolveHorWithPre(src, tmp, srcW, srcH, destW, filtersX), 
        convolveVertWithPre(tmp, dest, srcH, destW, destH, filtersY)) : (convolveHor(src, tmp, srcW, srcH, destW, filtersX), 
        convolveVert(tmp, dest, srcH, destW, destH, filtersY), function resetAlpha$1(dst, width, height) {
            let ptr = 3, len = width * height * 4 | 0;
            for (;ptr < len; ) dst[ptr] = 0xFF, ptr = ptr + 4 | 0;
        }(dest, destW, destH)), dest;
    },
    wasm_fn: function resize_wasm(options) {
        const src = options.src, srcW = options.width, srcH = options.height, destW = options.toWidth, destH = options.toHeight, scaleX = options.scaleX || options.toWidth / options.width, scaleY = options.scaleY || options.toHeight / options.height, offsetX = options.offsetX || 0.0, offsetY = options.offsetY || 0.0, dest = options.dest || new Uint8Array(destW * destH * 4), filter = void 0 === options.filter ? "mks2013" : options.filter, filtersX = createFilters(filter, srcW, destW, scaleX, offsetX), filtersY = createFilters(filter, srcH, destH, scaleY, offsetY), src_size = Math.max(src.byteLength, dest.byteLength), tmp_offset = this.__align(0 + src_size), tmp_size = srcH * destW * 4 * 2, filtersX_offset = this.__align(tmp_offset + tmp_size), filtersY_offset = this.__align(filtersX_offset + filtersX.byteLength), alloc_bytes = filtersY_offset + filtersY.byteLength, instance = this.__instance("resize", alloc_bytes), mem = new Uint8Array(this.__memory.buffer), mem32 = new Uint32Array(this.__memory.buffer), src32 = new Uint32Array(src.buffer);
        mem32.set(src32), copyInt16asLE(filtersX, mem, filtersX_offset), copyInt16asLE(filtersY, mem, filtersY_offset);
        const fn = instance.exports.convolveHV || instance.exports._convolveHV;
        return function hasAlpha(src, width, height) {
            let ptr = 3, len = width * height * 4 | 0;
            for (;ptr < len; ) {
                if (255 !== src[ptr]) return !0;
                ptr = ptr + 4 | 0;
            }
            return !1;
        }(src, srcW, srcH) ? fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 1) : (fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 0), 
        function resetAlpha(dst, width, height) {
            let ptr = 3, len = width * height * 4 | 0;
            for (;ptr < len; ) dst[ptr] = 0xFF, ptr = ptr + 4 | 0;
        }(dest, destW, destH)), new Uint32Array(dest.buffer).set(new Uint32Array(this.__memory.buffer, 0, destH * destW)), 
        dest;
    },
    wasm_src: "AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEYA2AGf39/f39/AGAAAGAIf39/f39/f38AAg8BA2VudgZtZW1vcnkCAAADBwYBAAAAAAIGBgF/AEEACweUAQgRX193YXNtX2NhbGxfY3RvcnMAAAtjb252b2x2ZUhvcgABDGNvbnZvbHZlVmVydAACEmNvbnZvbHZlSG9yV2l0aFByZQADE2NvbnZvbHZlVmVydFdpdGhQcmUABApjb252b2x2ZUhWAAUMX19kc29faGFuZGxlAwAYX193YXNtX2FwcGx5X2RhdGFfcmVsb2NzAAAKyA4GAwABC4wDARB/AkAgA0UNACAERQ0AIANBAnQhFQNAQQAhE0EAIQsDQCALQQJqIQcCfyALQQF0IAVqIgYuAQIiC0UEQEEAIQhBACEGQQAhCUEAIQogBwwBCyASIAYuAQBqIQhBACEJQQAhCiALIRRBACEOIAchBkEAIQ8DQCAFIAZBAXRqLgEAIhAgACAIQQJ0aigCACIRQRh2bCAPaiEPIBFB/wFxIBBsIAlqIQkgEUEQdkH/AXEgEGwgDmohDiARQQh2Qf8BcSAQbCAKaiEKIAhBAWohCCAGQQFqIQYgFEEBayIUDQALIAlBB3UhCCAKQQd1IQYgDkEHdSEJIA9BB3UhCiAHIAtqCyELIAEgDEEBdCIHaiAIQQAgCEEAShs7AQAgASAHQQJyaiAGQQAgBkEAShs7AQAgASAHQQRyaiAJQQAgCUEAShs7AQAgASAHQQZyaiAKQQAgCkEAShs7AQAgDCAVaiEMIBNBAWoiEyAERw0ACyANQQFqIg0gAmwhEiANQQJ0IQwgAyANRw0ACwsL2gMBD38CQCADRQ0AIARFDQAgAkECdCEUA0AgCyEMQQAhE0EAIQIDQCACQQJqIQYCfyACQQF0IAVqIgcuAQIiAkUEQEEAIQhBACEHQQAhCkEAIQkgBgwBCyAHLgEAQQJ0IBJqIQhBACEJIAIhCkEAIQ0gBiEHQQAhDkEAIQ8DQCAFIAdBAXRqLgEAIhAgACAIQQF0IhFqLwEAbCAJaiEJIAAgEUEGcmovAQAgEGwgDmohDiAAIBFBBHJqLwEAIBBsIA9qIQ8gACARQQJyai8BACAQbCANaiENIAhBBGohCCAHQQFqIQcgCkEBayIKDQALIAlBB3UhCCANQQd1IQcgDkEHdSEKIA9BB3UhCSACIAZqCyECIAEgDEECdGogB0GAQGtBDnUiBkH/ASAGQf8BSBsiBkEAIAZBAEobQQh0QYD+A3EgCUGAQGtBDnUiBkH/ASAGQf8BSBsiBkEAIAZBAEobQRB0QYCA/AdxIApBgEBrQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG0EYdHJyIAhBgEBrQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG3I2AgAgAyAMaiEMIBNBAWoiEyAERw0ACyAUIAtBAWoiC2whEiADIAtHDQALCwuSAwEQfwJAIANFDQAgBEUNACADQQJ0IRUDQEEAIRNBACEGA0AgBkECaiEIAn8gBkEBdCAFaiIGLgECIgdFBEBBACEJQQAhDEEAIQ1BACEOIAgMAQsgEiAGLgEAaiEJQQAhDkEAIQ1BACEMIAchFEEAIQ8gCCEGA0AgBSAGQQF0ai4BACAAIAlBAnRqKAIAIhBBGHZsIhEgD2ohDyARIBBBEHZB/wFxbCAMaiEMIBEgEEEIdkH/AXFsIA1qIQ0gESAQQf8BcWwgDmohDiAJQQFqIQkgBkEBaiEGIBRBAWsiFA0ACyAPQQd1IQkgByAIagshBiABIApBAXQiCGogDkH/AW1BB3UiB0EAIAdBAEobOwEAIAEgCEECcmogDUH/AW1BB3UiB0EAIAdBAEobOwEAIAEgCEEEcmogDEH/AW1BB3UiB0EAIAdBAEobOwEAIAEgCEEGcmogCUEAIAlBAEobOwEAIAogFWohCiATQQFqIhMgBEcNAAsgC0EBaiILIAJsIRIgC0ECdCEKIAMgC0cNAAsLC4IEAQ9/AkAgA0UNACAERQ0AIAJBAnQhFANAIAshDEEAIRJBACEHA0AgB0ECaiEKAn8gB0EBdCAFaiICLgECIhNFBEBBACEIQQAhCUEAIQYgCiEHQQAMAQsgAi4BAEECdCARaiEJQQAhByATIQJBACENIAohBkEAIQ5BACEPA0AgBSAGQQF0ai4BACIIIAAgCUEBdCIQai8BAGwgB2ohByAAIBBBBnJqLwEAIAhsIA5qIQ4gACAQQQRyai8BACAIbCAPaiEPIAAgEEECcmovAQAgCGwgDWohDSAJQQRqIQkgBkEBaiEGIAJBAWsiAg0ACyAHQQd1IQggDUEHdSEJIA9BB3UhBiAKIBNqIQcgDkEHdQtBgEBrQQ51IgJB/wEgAkH/AUgbIgJBACACQQBKGyIKQf8BcQRAIAlB/wFsIAJtIQkgCEH/AWwgAm0hCCAGQf8BbCACbSEGCyABIAxBAnRqIAlBgEBrQQ51IgJB/wEgAkH/AUgbIgJBACACQQBKG0EIdEGA/gNxIAZBgEBrQQ51IgJB/wEgAkH/AUgbIgJBACACQQBKG0EQdEGAgPwHcSAKQRh0ciAIQYBAa0EOdSICQf8BIAJB/wFIGyICQQAgAkEAShtycjYCACADIAxqIQwgEkEBaiISIARHDQALIBQgC0EBaiILbCERIAMgC0cNAAsLC0AAIAcEQEEAIAIgAyAEIAUgABADIAJBACAEIAUgBiABEAQPC0EAIAIgAyAEIAUgABABIAJBACAEIAUgBiABEAIL"
};

const Multimath = multimath, mm_unsharp_mask = mm_unsharp_mask$1, mm_resize = mm_resize$1;

function MathLib$1(requested_features) {
    const __requested_features = requested_features || [];
    let features = {
        js: __requested_features.indexOf("js") >= 0,
        wasm: __requested_features.indexOf("wasm") >= 0
    };
    Multimath.call(this, features), this.features = {
        js: features.js,
        wasm: features.wasm && this.has_wasm()
    }, this.use(mm_unsharp_mask), this.use(mm_resize);
}

MathLib$1.prototype = Object.create(Multimath.prototype), MathLib$1.prototype.constructor = MathLib$1, 
MathLib$1.prototype.resizeAndUnsharp = function resizeAndUnsharp(options, cache) {
    let result = this.resize(options, cache);
    return options.unsharpAmount && this.unsharp_mask(result, options.toWidth, options.toHeight, options.unsharpAmount, options.unsharpRadius, options.unsharpThreshold), 
    result;
};

var mathlib = MathLib$1;

function Pool$1(create, idle) {
    this.create = create, this.available = [], this.acquired = {}, this.lastId = 1, 
    this.timeoutId = 0, this.idle = idle || 2000;
}

Pool$1.prototype.acquire = function() {
    let resource;
    return 0 !== this.available.length ? resource = this.available.pop() : (resource = this.create(), 
    resource.id = this.lastId++, resource.release = () => this.release(resource)), this.acquired[resource.id] = resource, 
    resource;
}, Pool$1.prototype.release = function(resource) {
    delete this.acquired[resource.id], resource.lastUsed = Date.now(), this.available.push(resource), 
    0 === this.timeoutId && (this.timeoutId = setTimeout((() => this.gc()), 100));
}, Pool$1.prototype.gc = function() {
    const now = Date.now();
    this.available = this.available.filter((resource => !(now - resource.lastUsed > this.idle && (resource.destroy(), 
    1)))), 0 !== this.available.length ? this.timeoutId = setTimeout((() => this.gc()), 100) : this.timeoutId = 0;
};

var pool = Pool$1, utils$1 = {};

function objClass(obj) {
    return Object.prototype.toString.call(obj);
}

function pixelFloor(x) {
    var nearest = Math.round(x);
    return Math.abs(x - nearest) < 1e-5 ? nearest : Math.floor(x);
}

function pixelCeil(x) {
    var nearest = Math.round(x);
    return Math.abs(x - nearest) < 1e-5 ? nearest : Math.ceil(x);
}

utils$1.isCanvas = function isCanvas(element) {
    let cname = objClass(element);
    return "[object HTMLCanvasElement]" === cname || "[object OffscreenCanvas]" === cname || "[object Canvas]" === cname;
}, utils$1.isImage = function isImage(element) {
    return "[object HTMLImageElement]" === objClass(element);
}, utils$1.isImageBitmap = function isImageBitmap(element) {
    return "[object ImageBitmap]" === objClass(element);
}, utils$1.limiter = function limiter(concurrency) {
    let active = 0, queue = [];
    function roll() {
        active < concurrency && queue.length && (active++, queue.shift()());
    }
    return function limit(fn) {
        return new Promise(((resolve, reject) => {
            queue.push((() => {
                fn().then((result => {
                    resolve(result), active--, roll();
                }), (err => {
                    reject(err), active--, roll();
                }));
            })), roll();
        }));
    };
}, utils$1.cib_quality_name = function cib_quality_name(num) {
    switch (num) {
      case 0:
        return "pixelated";

      case 1:
        return "low";

      case 2:
        return "medium";
    }
    return "high";
}, utils$1.cib_support = function cib_support(createCanvas) {
    return Promise.resolve().then((() => {
        if ("undefined" == typeof createImageBitmap) return !1;
        let c = createCanvas(100, 100);
        return createImageBitmap(c, 0, 0, 100, 100, {
            resizeWidth: 10,
            resizeHeight: 10,
            resizeQuality: "high"
        }).then((bitmap => {
            let status = 10 === bitmap.width;
            return bitmap.close(), c = null, status;
        }));
    })).catch((() => !1));
}, utils$1.worker_offscreen_canvas_support = function worker_offscreen_canvas_support() {
    return new Promise(((resolve, reject) => {
        if ("undefined" == typeof OffscreenCanvas) return void resolve(!1);
        let code = btoa(`(${function workerPayload(self) {
            "undefined" != typeof createImageBitmap ? Promise.resolve().then((() => {
                let canvas = new OffscreenCanvas(10, 10);
                return canvas.getContext("2d").rect(0, 0, 1, 1), createImageBitmap(canvas, 0, 0, 1, 1);
            })).then((() => self.postMessage(!0)), (() => self.postMessage(!1))) : self.postMessage(!1);
        }.toString()})(self);`), w = new Worker(`data:text/javascript;base64,${code}`);
        w.onmessage = ev => resolve(ev.data), w.onerror = reject;
    })).then((result => result), (() => !1));
}, utils$1.can_use_canvas = function can_use_canvas(createCanvas) {
    let usable = !1;
    try {
        let ctx = createCanvas(2, 1).getContext("2d"), d = ctx.createImageData(2, 1);
        d.data[0] = 12, d.data[1] = 23, d.data[2] = 34, d.data[3] = 255, d.data[4] = 45, 
        d.data[5] = 56, d.data[6] = 67, d.data[7] = 255, ctx.putImageData(d, 0, 0), d = null, 
        d = ctx.getImageData(0, 0, 2, 1), 12 === d.data[0] && 23 === d.data[1] && 34 === d.data[2] && 255 === d.data[3] && 45 === d.data[4] && 56 === d.data[5] && 67 === d.data[6] && 255 === d.data[7] && (usable = !0);
    } catch (err) {}
    return usable;
}, utils$1.cib_can_use_region = function cib_can_use_region() {
    return new Promise((resolve => {
        if ("undefined" == typeof Image || "undefined" == typeof createImageBitmap) return void resolve(!1);
        let image = new Image;
        image.src = "data:image/jpeg;base64,/9j/4QBiRXhpZgAATU0AKgAAAAgABQESAAMAAAABAAYAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAABIAAAAAQAAAEgAAAAB/9sAQwAEAwMEAwMEBAMEBQQEBQYKBwYGBgYNCQoICg8NEBAPDQ8OERMYFBESFxIODxUcFRcZGRsbGxAUHR8dGh8YGhsa/9sAQwEEBQUGBQYMBwcMGhEPERoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa/8IAEQgAAQACAwERAAIRAQMRAf/EABQAAQAAAAAAAAAAAAAAAAAAAAf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAF/P//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAQUCf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Bf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Bf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEABj8Cf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8hf//aAAwDAQACAAMAAAAQH//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Qf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Qf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8Qf//Z", 
        image.onload = () => {
            createImageBitmap(image, 0, 0, image.width, image.height).then((bitmap => {
                bitmap.width === image.width && bitmap.height === image.height ? resolve(!0) : resolve(!1);
            }), (() => resolve(!1)));
        }, image.onerror = () => resolve(!1);
    }));
};

const assign = objectAssign, webworkify = function(fn, options) {
    for (var wkey, cacheKeys = Object.keys(cache), i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i], exp = cache[key].exports;
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }
    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (i = 0, l = cacheKeys.length; i < l; i++) wcache[key = cacheKeys[i]] = key;
        sources[wkey] = [ "function(require,module,exports){" + fn + "(self); }", wcache ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16), scache = {};
    scache[wkey] = wkey, sources[skey] = [ "function(require,module,exports){var f = require(" + stringify(wkey) + ");(f.default ? f.default : f)(self);}", scache ];
    var workerSources = {};
    !function resolveSources(key) {
        for (var depPath in workerSources[key] = !0, sources[key][1]) {
            var depKey = sources[key][1][depPath];
            workerSources[depKey] || resolveSources(depKey);
        }
    }(skey);
    var src = "(" + bundleFn + ")({" + Object.keys(workerSources).map((function(key) {
        return stringify(key) + ":[" + sources[key][0] + "," + stringify(sources[key][1]) + "]";
    })).join(",") + "},{},[" + stringify(skey) + "])", URL = window.URL || window.webkitURL || window.mozURL || window.msURL, blob = new Blob([ src ], {
        type: "text/javascript"
    });
    if (options && options.bare) return blob;
    var workerUrl = URL.createObjectURL(blob), worker = new Worker(workerUrl);
    return worker.objectURL = workerUrl, worker;
}, MathLib = mathlib, Pool = pool, utils = utils$1, worker = function() {
    const MathLib = mathlib;
    let mathLib;
    onmessage = function(ev) {
        let tileOpts = ev.data.opts;
        if (!tileOpts.src && tileOpts.srcBitmap) {
            let canvas = new OffscreenCanvas(tileOpts.width, tileOpts.height), ctx = canvas.getContext("2d");
            ctx.drawImage(tileOpts.srcBitmap, 0, 0), tileOpts.src = ctx.getImageData(0, 0, tileOpts.width, tileOpts.height).data, 
            canvas.width = canvas.height = 0, canvas = null, tileOpts.srcBitmap.close(), tileOpts.srcBitmap = null;
        }
        mathLib || (mathLib = new MathLib(ev.data.features));
        let data = mathLib.resizeAndUnsharp(tileOpts);
        postMessage({
            data
        }, [ data.buffer ]);
    };
}, filter_info = resize_filter_info, singletones = {};

let NEED_SAFARI_FIX = !1;

try {
    "undefined" != typeof navigator && navigator.userAgent && (NEED_SAFARI_FIX = navigator.userAgent.indexOf("Safari") >= 0);
} catch (e) {}

let concurrency = 1;

"undefined" != typeof navigator && (concurrency = Math.min(navigator.hardwareConcurrency || 1, 4));

const DEFAULT_PICA_OPTS = {
    tile: 1024,
    concurrency,
    features: [ "js", "wasm", "ww" ],
    idle: 2000,
    createCanvas: function(width, height) {
        let tmpCanvas = document.createElement("canvas");
        return tmpCanvas.width = width, tmpCanvas.height = height, tmpCanvas;
    }
}, DEFAULT_RESIZE_OPTS = {
    filter: "mks2013",
    unsharpAmount: 0,
    unsharpRadius: 0.0,
    unsharpThreshold: 0
};

let CAN_NEW_IMAGE_DATA = !1, CAN_CREATE_IMAGE_BITMAP = !1, CAN_USE_CANVAS_GET_IMAGE_DATA = !1, CAN_USE_OFFSCREEN_CANVAS = !1, CAN_USE_CIB_REGION_FOR_IMAGE = !1;

function workerFabric() {
    return {
        value: webworkify(worker),
        destroy: function() {
            if (this.value.terminate(), "undefined" != typeof window) {
                let url = window.URL || window.webkitURL || window.mozURL || window.msURL;
                url && url.revokeObjectURL && this.value.objectURL && url.revokeObjectURL(this.value.objectURL);
            }
        }
    };
}

function Pica(options) {
    if (!(this instanceof Pica)) return new Pica(options);
    this.options = assign({}, DEFAULT_PICA_OPTS, options || {});
    let limiter_key = `lk_${this.options.concurrency}`;
    this.__limit = singletones[limiter_key] || utils.limiter(this.options.concurrency), 
    singletones[limiter_key] || (singletones[limiter_key] = this.__limit), this.features = {
        js: !1,
        wasm: !1,
        cib: !1,
        ww: !1
    }, this.__workersPool = null, this.__requested_features = [], this.__mathlib = null;
}

Pica.prototype.init = function() {
    if (this.__initPromise) return this.__initPromise;
    if ("undefined" != typeof ImageData && "undefined" != typeof Uint8ClampedArray) try {
        new ImageData(new Uint8ClampedArray(400), 10, 10), CAN_NEW_IMAGE_DATA = !0;
    } catch (__) {}
    "undefined" != typeof ImageBitmap && (ImageBitmap.prototype && ImageBitmap.prototype.close ? CAN_CREATE_IMAGE_BITMAP = !0 : this.debug("ImageBitmap does not support .close(), disabled"));
    let features = this.options.features.slice();
    if (features.indexOf("all") >= 0 && (features = [ "cib", "wasm", "js", "ww" ]), 
    this.__requested_features = features, this.__mathlib = new MathLib(features), features.indexOf("ww") >= 0 && "undefined" != typeof window && "Worker" in window) try {
        require("webworkify")((function() {})).terminate(), this.features.ww = !0;
        let wpool_key = `wp_${JSON.stringify(this.options)}`;
        singletones[wpool_key] ? this.__workersPool = singletones[wpool_key] : (this.__workersPool = new Pool(workerFabric, this.options.idle), 
        singletones[wpool_key] = this.__workersPool);
    } catch (__) {}
    let checkCibResize, checkOffscreenCanvas, initMath = this.__mathlib.init().then((mathlib => {
        assign(this.features, mathlib.features);
    }));
    checkCibResize = CAN_CREATE_IMAGE_BITMAP ? utils.cib_support(this.options.createCanvas).then((status => {
        this.features.cib && features.indexOf("cib") < 0 ? this.debug("createImageBitmap() resize supported, but disabled by config") : features.indexOf("cib") >= 0 && (this.features.cib = status);
    })) : Promise.resolve(!1), CAN_USE_CANVAS_GET_IMAGE_DATA = utils.can_use_canvas(this.options.createCanvas), 
    checkOffscreenCanvas = CAN_CREATE_IMAGE_BITMAP && CAN_NEW_IMAGE_DATA && -1 !== features.indexOf("ww") ? utils.worker_offscreen_canvas_support() : Promise.resolve(!1), 
    checkOffscreenCanvas = checkOffscreenCanvas.then((result => {
        CAN_USE_OFFSCREEN_CANVAS = result;
    }));
    let checkCibRegion = utils.cib_can_use_region().then((result => {
        CAN_USE_CIB_REGION_FOR_IMAGE = result;
    }));
    return this.__initPromise = Promise.all([ initMath, checkCibResize, checkOffscreenCanvas, checkCibRegion ]).then((() => this)), 
    this.__initPromise;
}, Pica.prototype.__invokeResize = function(tileOpts, opts) {
    return opts.__mathCache = opts.__mathCache || {}, Promise.resolve().then((() => this.features.ww ? new Promise(((resolve, reject) => {
        let w = this.__workersPool.acquire();
        opts.cancelToken && opts.cancelToken.catch((err => reject(err))), w.value.onmessage = ev => {
            w.release(), ev.data.err ? reject(ev.data.err) : resolve(ev.data);
        };
        let transfer = [];
        tileOpts.src && transfer.push(tileOpts.src.buffer), tileOpts.srcBitmap && transfer.push(tileOpts.srcBitmap), 
        w.value.postMessage({
            opts: tileOpts,
            features: this.__requested_features,
            preload: {
                wasm_nodule: this.__mathlib.__
            }
        }, transfer);
    })) : {
        data: this.__mathlib.resizeAndUnsharp(tileOpts, opts.__mathCache)
    }));
}, Pica.prototype.__extractTileData = function(tile, from, opts, stageEnv, extractTo) {
    if (this.features.ww && CAN_USE_OFFSCREEN_CANVAS && (utils.isCanvas(from) || CAN_USE_CIB_REGION_FOR_IMAGE)) return this.debug("Create tile for OffscreenCanvas"), 
    createImageBitmap(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height).then((bitmap => (extractTo.srcBitmap = bitmap, 
    extractTo)));
    if (utils.isCanvas(from)) return stageEnv.srcCtx || (stageEnv.srcCtx = from.getContext("2d")), 
    this.debug("Get tile pixel data"), extractTo.src = stageEnv.srcCtx.getImageData(tile.x, tile.y, tile.width, tile.height).data, 
    extractTo;
    this.debug("Draw tile imageBitmap/image to temporary canvas");
    let tmpCanvas = this.options.createCanvas(tile.width, tile.height), tmpCtx = tmpCanvas.getContext("2d");
    return tmpCtx.globalCompositeOperation = "copy", tmpCtx.drawImage(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height, 0, 0, tile.width, tile.height), 
    this.debug("Get tile pixel data"), extractTo.src = tmpCtx.getImageData(0, 0, tile.width, tile.height).data, 
    tmpCanvas.width = tmpCanvas.height = 0, extractTo;
}, Pica.prototype.__landTileData = function(tile, result, stageEnv) {
    let toImageData;
    if (this.debug("Convert raw rgba tile result to ImageData"), result.bitmap) return stageEnv.toCtx.drawImage(result.bitmap, tile.toX, tile.toY), 
    null;
    if (CAN_NEW_IMAGE_DATA) toImageData = new ImageData(new Uint8ClampedArray(result.data), tile.toWidth, tile.toHeight); else if (toImageData = stageEnv.toCtx.createImageData(tile.toWidth, tile.toHeight), 
    toImageData.data.set) toImageData.data.set(result.data); else for (let i = toImageData.data.length - 1; i >= 0; i--) toImageData.data[i] = result.data[i];
    return this.debug("Draw tile"), NEED_SAFARI_FIX ? stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth + 1e-5, tile.toInnerHeight + 1e-5) : stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth, tile.toInnerHeight), 
    null;
}, Pica.prototype.__tileAndResize = function(from, to, opts) {
    let stageEnv = {
        srcCtx: null,
        srcImageBitmap: null,
        isImageBitmapReused: !1,
        toCtx: null
    };
    const processTile = tile => this.__limit((() => {
        if (opts.canceled) return opts.cancelToken;
        let tileOpts = {
            width: tile.width,
            height: tile.height,
            toWidth: tile.toWidth,
            toHeight: tile.toHeight,
            scaleX: tile.scaleX,
            scaleY: tile.scaleY,
            offsetX: tile.offsetX,
            offsetY: tile.offsetY,
            filter: opts.filter,
            unsharpAmount: opts.unsharpAmount,
            unsharpRadius: opts.unsharpRadius,
            unsharpThreshold: opts.unsharpThreshold
        };
        return this.debug("Invoke resize math"), Promise.resolve(tileOpts).then((tileOpts => this.__extractTileData(tile, from, opts, stageEnv, tileOpts))).then((tileOpts => (this.debug("Invoke resize math"), 
        this.__invokeResize(tileOpts, opts)))).then((result => opts.canceled ? opts.cancelToken : (stageEnv.srcImageData = null, 
        this.__landTileData(tile, result, stageEnv))));
    }));
    return Promise.resolve().then((() => {
        if (stageEnv.toCtx = to.getContext("2d"), utils.isCanvas(from)) return null;
        if (utils.isImageBitmap(from)) return stageEnv.srcImageBitmap = from, stageEnv.isImageBitmapReused = !0, 
        null;
        if (utils.isImage(from)) return CAN_CREATE_IMAGE_BITMAP ? (this.debug("Decode image via createImageBitmap"), 
        createImageBitmap(from).then((imageBitmap => {
            stageEnv.srcImageBitmap = imageBitmap;
        })).catch((e => null))) : null;
        throw new Error('Pica: ".from" should be Image, Canvas or ImageBitmap');
    })).then((() => {
        if (opts.canceled) return opts.cancelToken;
        this.debug("Calculate tiles");
        let jobs = function createRegions(options) {
            var x, y, innerX, innerY, toTileWidth, toTileHeight, scaleX = options.toWidth / options.width, scaleY = options.toHeight / options.height, innerTileWidth = pixelFloor(options.srcTileSize * scaleX) - 2 * options.destTileBorder, innerTileHeight = pixelFloor(options.srcTileSize * scaleY) - 2 * options.destTileBorder;
            if (innerTileWidth < 1 || innerTileHeight < 1) throw new Error("Internal error in pica: target tile width/height is too small.");
            var tile, tiles = [];
            for (innerY = 0; innerY < options.toHeight; innerY += innerTileHeight) for (innerX = 0; innerX < options.toWidth; innerX += innerTileWidth) (x = innerX - options.destTileBorder) < 0 && (x = 0), 
            x + (toTileWidth = innerX + innerTileWidth + options.destTileBorder - x) >= options.toWidth && (toTileWidth = options.toWidth - x), 
            (y = innerY - options.destTileBorder) < 0 && (y = 0), y + (toTileHeight = innerY + innerTileHeight + options.destTileBorder - y) >= options.toHeight && (toTileHeight = options.toHeight - y), 
            tile = {
                toX: x,
                toY: y,
                toWidth: toTileWidth,
                toHeight: toTileHeight,
                toInnerX: innerX,
                toInnerY: innerY,
                toInnerWidth: innerTileWidth,
                toInnerHeight: innerTileHeight,
                offsetX: x / scaleX - pixelFloor(x / scaleX),
                offsetY: y / scaleY - pixelFloor(y / scaleY),
                scaleX,
                scaleY,
                x: pixelFloor(x / scaleX),
                y: pixelFloor(y / scaleY),
                width: pixelCeil(toTileWidth / scaleX),
                height: pixelCeil(toTileHeight / scaleY)
            }, tiles.push(tile);
            return tiles;
        }({
            width: opts.width,
            height: opts.height,
            srcTileSize: this.options.tile,
            toWidth: opts.toWidth,
            toHeight: opts.toHeight,
            destTileBorder: opts.__destTileBorder
        }).map((tile => processTile(tile)));
        function cleanup(stageEnv) {
            stageEnv.srcImageBitmap && (stageEnv.isImageBitmapReused || stageEnv.srcImageBitmap.close(), 
            stageEnv.srcImageBitmap = null);
        }
        return this.debug("Process tiles"), Promise.all(jobs).then((() => (this.debug("Finished!"), 
        cleanup(stageEnv), to)), (err => {
            throw cleanup(stageEnv), err;
        }));
    }));
}, Pica.prototype.__processStages = function(stages, from, to, opts) {
    if (opts.canceled) return opts.cancelToken;
    let filter, tmpCanvas, [toWidth, toHeight] = stages.shift(), isLastStage = 0 === stages.length;
    return filter = isLastStage || filter_info.q2f.indexOf(opts.filter) < 0 ? opts.filter : "box" === opts.filter ? "box" : "hamming", 
    opts = assign({}, opts, {
        toWidth,
        toHeight,
        filter
    }), isLastStage || (tmpCanvas = this.options.createCanvas(toWidth, toHeight)), this.__tileAndResize(from, isLastStage ? to : tmpCanvas, opts).then((() => isLastStage ? to : (opts.width = toWidth, 
    opts.height = toHeight, this.__processStages(stages, tmpCanvas, to, opts)))).then((res => (tmpCanvas && (tmpCanvas.width = tmpCanvas.height = 0), 
    res)));
}, Pica.prototype.__resizeViaCreateImageBitmap = function(from, to, opts) {
    let toCtx = to.getContext("2d");
    return this.debug("Resize via createImageBitmap()"), createImageBitmap(from, {
        resizeWidth: opts.toWidth,
        resizeHeight: opts.toHeight,
        resizeQuality: utils.cib_quality_name(filter_info.f2q[opts.filter])
    }).then((imageBitmap => {
        if (opts.canceled) return opts.cancelToken;
        if (!opts.unsharpAmount) return toCtx.drawImage(imageBitmap, 0, 0), imageBitmap.close(), 
        toCtx = null, this.debug("Finished!"), to;
        this.debug("Unsharp result");
        let tmpCanvas = this.options.createCanvas(opts.toWidth, opts.toHeight), tmpCtx = tmpCanvas.getContext("2d");
        tmpCtx.drawImage(imageBitmap, 0, 0), imageBitmap.close();
        let iData = tmpCtx.getImageData(0, 0, opts.toWidth, opts.toHeight);
        return this.__mathlib.unsharp_mask(iData.data, opts.toWidth, opts.toHeight, opts.unsharpAmount, opts.unsharpRadius, opts.unsharpThreshold), 
        toCtx.putImageData(iData, 0, 0), tmpCanvas.width = tmpCanvas.height = 0, iData = tmpCtx = tmpCanvas = toCtx = null, 
        this.debug("Finished!"), to;
    }));
}, Pica.prototype.resize = function(from, to, options) {
    this.debug("Start resize...");
    let opts = assign({}, DEFAULT_RESIZE_OPTS);
    if (isNaN(options) ? options && (opts = assign(opts, options)) : opts = assign(opts, {
        quality: options
    }), opts.toWidth = to.width, opts.toHeight = to.height, opts.width = from.naturalWidth || from.width, 
    opts.height = from.naturalHeight || from.height, Object.prototype.hasOwnProperty.call(opts, "quality")) {
        if (opts.quality < 0 || opts.quality > 3) throw new Error(`Pica: .quality should be [0..3], got ${opts.quality}`);
        opts.filter = filter_info.q2f[opts.quality];
    }
    return 0 === to.width || 0 === to.height ? Promise.reject(new Error(`Invalid output size: ${to.width}x${to.height}`)) : (opts.unsharpRadius > 2 && (opts.unsharpRadius = 2), 
    opts.canceled = !1, opts.cancelToken && (opts.cancelToken = opts.cancelToken.then((data => {
        throw opts.canceled = !0, data;
    }), (err => {
        throw opts.canceled = !0, err;
    }))), opts.__destTileBorder = Math.ceil(Math.max(3, 2.5 * opts.unsharpRadius | 0)), 
    this.init().then((() => {
        if (opts.canceled) return opts.cancelToken;
        if (this.features.cib) {
            if (filter_info.q2f.indexOf(opts.filter) >= 0) return this.__resizeViaCreateImageBitmap(from, to, opts);
            this.debug("cib is enabled, but not supports provided filter, fallback to manual math");
        }
        if (!CAN_USE_CANVAS_GET_IMAGE_DATA) {
            let err = new Error("Pica: cannot use getImageData on canvas, make sure fingerprinting protection isn't enabled");
            throw err.code = "ERR_GET_IMAGE_DATA", err;
        }
        let stages = function createStages(fromWidth, fromHeight, toWidth, toHeight, srcTileSize, destTileBorder) {
            let scaleX = toWidth / fromWidth, scaleY = toHeight / fromHeight, minScale = (2 * destTileBorder + 2 + 1) / srcTileSize;
            if (minScale > 0.5) return [ [ toWidth, toHeight ] ];
            let stageCount = Math.ceil(Math.log(Math.min(scaleX, scaleY)) / Math.log(minScale));
            if (stageCount <= 1) return [ [ toWidth, toHeight ] ];
            let result = [];
            for (let i = 0; i < stageCount; i++) {
                let width = Math.round(Math.pow(Math.pow(fromWidth, stageCount - i - 1) * Math.pow(toWidth, i + 1), 1 / stageCount)), height = Math.round(Math.pow(Math.pow(fromHeight, stageCount - i - 1) * Math.pow(toHeight, i + 1), 1 / stageCount));
                result.push([ width, height ]);
            }
            return result;
        }(opts.width, opts.height, opts.toWidth, opts.toHeight, this.options.tile, opts.__destTileBorder);
        return this.__processStages(stages, from, to, opts);
    })));
}, Pica.prototype.resizeBuffer = function(options) {
    const opts = assign({}, DEFAULT_RESIZE_OPTS, options);
    if (Object.prototype.hasOwnProperty.call(opts, "quality")) {
        if (opts.quality < 0 || opts.quality > 3) throw new Error(`Pica: .quality should be [0..3], got ${opts.quality}`);
        opts.filter = filter_info.q2f[opts.quality];
    }
    return this.init().then((() => this.__mathlib.resizeAndUnsharp(opts)));
}, Pica.prototype.toBlob = function(canvas, mimeType, quality) {
    return mimeType = mimeType || "image/png", new Promise((resolve => {
        if (canvas.toBlob) return void canvas.toBlob((blob => resolve(blob)), mimeType, quality);
        if (canvas.convertToBlob) return void resolve(canvas.convertToBlob({
            type: mimeType,
            quality
        }));
        const asString = atob(canvas.toDataURL(mimeType, quality).split(",")[1]), len = asString.length, asBuffer = new Uint8Array(len);
        for (let i = 0; i < len; i++) asBuffer[i] = asString.charCodeAt(i);
        resolve(new Blob([ asBuffer ], {
            type: mimeType
        }));
    }));
}, Pica.prototype.debug = function() {};

var pica = Pica;

let Buffer$1;

class SendMessageService extends BaseService {
    emoteService;
    attachService;
    modulesService;
    settingsService;
    gifsicleService;
    picaInstance;
    async start(emoteService, attachService, modulesService, settingsService, gifsicleService) {
        this.emoteService = emoteService, this.attachService = attachService, this.modulesService = modulesService, 
        this.settingsService = settingsService, this.gifsicleService = gifsicleService, 
        Buffer$1 = (await Promise.resolve().then((function() {
            return _interopNamespace(require("buffer"));
        }))).Buffer, this.picaInstance = pica(), BdApi.Patcher.instead(this.plugin.meta.name, modulesService.messageStore, "sendMessage", ((_, args, original) => this.onSendMessage(args, original)));
    }
    async onSendMessage(args, original) {
        const callDefault = original, message = args[1];
        if (message) try {
            const discordEmotes = this.getTargetEmoteFromMessage(message);
            let content = message.content;
            const foundEmote = this.getTextPos(content, {
                ...this.emoteService.emoteNames,
                ...discordEmotes
            });
            if (!foundEmote) return void callDefault(...args);
            if (!this.attachService.canAttach) return BdApi.showToast("This channel does not allow sending images!", {
                type: "error"
            }), void callDefault(...args);
            content = (content.substring(0, foundEmote.pos) + content.substring(foundEmote.pos + foundEmote.nameAndCommand.length)).trim(), 
            foundEmote.content = content;
            try {
                return this.attachService.pendingUpload = this.fetchBlobAndUpload(foundEmote), void await this.attachService.pendingUpload;
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : error;
                if (BdApi.showToast(errorMessage, {
                    type: "error"
                }), "" === content) return;
                message.content = content;
            } finally {
                this.attachService.pendingUpload = void 0;
            }
            return void callDefault(...args);
        } catch (error) {
            Logger.warn("Error in onSendMessage", error);
        } else callDefault(...args);
    }
    getTargetEmoteFromMessage(message) {
        const invalidEmojis = message.invalidEmojis ?? [], validNonShortcutEmojis = message.validNonShortcutEmojis ?? [];
        let emoji, validEmoji = !1;
        if (invalidEmojis.length > 0) emoji = invalidEmojis[invalidEmojis.length - 1]; else {
            if (!(validNonShortcutEmojis?.length > 0)) return {};
            if (emoji = validNonShortcutEmojis[validNonShortcutEmojis.length - 1], !0 === emoji?.managed) return {};
            validEmoji = !0 === emoji?.available;
        }
        if (!emoji) return {};
        const emojiName = emoji.originalName ?? emoji.name, allNamesString = emoji.allNamesString.replace(emoji.name, emojiName), emojiText = `<${emoji.animated ? "a" : ""}${allNamesString}${emoji.id}>`, result = {}, url = emoji.url.split("?")[0] ?? "";
        if (!url) return {};
        const extensionIndex = url.lastIndexOf(".");
        result[emojiText] = {
            name: emojiName,
            url: ".webp" === url.substring(extensionIndex) ? `${url.substring(0, extensionIndex)}.png` : url
        };
        const foundEmote = this.getTextPos(message.content, result);
        return foundEmote ? validEmoji && 0 === foundEmote.commands.length ? {} : result : {};
    }
    getTextPos(content, emoteCandidates) {
        const foundEmotes = [];
        return Object.entries(emoteCandidates).forEach((([key, value]) => {
            const regex = new RegExp("(?<!\\/)" + key + "(?<=\\b|>)", "g"), regexCommand = new RegExp(key + "(\\.\\S{4,}\\b)+"), matches = content.match(regex), command = content.match(regexCommand);
            if (matches && 0 !== matches.length) for (let i = 0; i < matches.length; i++) {
                const pos = this.getNthIndexOf(content, key, i), emote = {
                    name: "string" == typeof value ? key : value.name,
                    nameAndCommand: key,
                    url: "string" == typeof value ? value : value.url,
                    emoteLength: key.length,
                    pos,
                    spoiler: !1,
                    commands: []
                };
                if (command) {
                    const commands = command[0]?.split(".") ?? [];
                    emote.commands = commands.filter((command => command !== key)).map((command => {
                        const split = command.split("-");
                        return [ split[0] ?? void 0, split[1] ?? void 0 ];
                    })), emote.nameAndCommand = command[0] ?? "";
                }
                const beforeEmote = content.substring(0, pos), afterEmote = content.substring(pos + emote.nameAndCommand.length);
                if (beforeEmote.includes("||") && afterEmote.includes("||")) {
                    const spoilerStart = beforeEmote.substring(beforeEmote.indexOf("||"));
                    emote.nameAndCommand = spoilerStart + emote.nameAndCommand, emote.pos -= spoilerStart.length;
                    const spoilerEnd = afterEmote.substring(0, afterEmote.indexOf("||") + 2);
                    emote.nameAndCommand = emote.nameAndCommand + spoilerEnd, emote.spoiler = !0;
                }
                beforeEmote.includes("`") && afterEmote.includes("`") || foundEmotes.push(emote);
            }
        })), foundEmotes.pop();
    }
    getNthIndexOf(input, search, nth) {
        const firstIndex = input.indexOf(search), startPos = firstIndex + search.length;
        if (0 === nth) return firstIndex;
        {
            const inputAfterFirstOccurrence = input.substring(startPos), nextOccurrence = this.getNthIndexOf(inputAfterFirstOccurrence, search, nth - 1);
            return -1 === nextOccurrence ? -1 : startPos + nextOccurrence;
        }
    }
    fetchBlobAndUpload(emote) {
        const url = emote.url, name = emote.name, commands = emote.commands;
        return emote.channel = this.modulesService.selectedChannelStore.getChannelId(), 
        url.endsWith(".gif") || this.findCommand(commands, this.getGifModifiers()) ? this.getMetaAndModifyGif(emote) : new Promise(((resolve, reject) => {
            https__default.default.get(url, (res => {
                const contentType = res.headers["content-type"] ?? "";
                if (!contentType.startsWith("image")) return void reject(new Error("Emote URL was not an image"));
                if (0 === (res.headers["content-length"] ?? 0)) return void reject(new Error("Emote URL did not contain data"));
                const data = [];
                res.on("data", (chunk => {
                    data.push(chunk);
                })), res.on("end", (() => {
                    const buffer = Buffer$1.concat(data);
                    this.compress(new Blob([ buffer ], {
                        type: contentType
                    }), commands).then((resultBlob => {
                        this.uploadFile({
                            fileData: resultBlob ?? new Blob([]),
                            fullName: name + ".png",
                            emote
                        }), resolve();
                    })).catch(reject);
                }));
            })).on("error", (error => {
                reject(error);
            }));
        }));
    }
    findCommand(commands, names) {
        let foundCommand;
        return commands.forEach((command => {
            names.forEach((name => {
                command[0] === name && (foundCommand = command);
            }));
        })), foundCommand;
    }
    getGifModifiers() {
        const gifModifiers = [];
        return this.emoteService.modifiers.forEach((modifier => {
            "gif" === modifier.type && gifModifiers.push(modifier.name);
        })), gifModifiers;
    }
    async getMetaAndModifyGif(emote) {
        const image = await loadImagePromise(emote.url), commands = emote.commands;
        this.addResizeCommand(commands, image), BdApi.showToast("Processing gif...", {
            type: "info"
        });
        const buffer = await this.gifsicleService.modifyGif(emote.url, commands);
        if (0 === buffer.length) throw Error("Failed to process gif");
        this.uploadFile({
            fileData: buffer,
            fullName: emote.name + ".gif",
            emote
        });
    }
    addResizeCommand(commands, image) {
        const scaleFactorNum = this.getScaleFactor(commands, image);
        let scaleFactor = scaleFactorNum.toString();
        const wideCommand = this.findCommand(commands, [ "wide" ]);
        wideCommand && (scaleFactor = `${scaleFactorNum * this.getEmoteWideness(wideCommand)}x${scaleFactorNum}}`), 
        commands.push([ "resize", scaleFactor ]);
    }
    getScaleFactor(commands, image) {
        const size = this.getEmoteSize(commands);
        let scaleFactor;
        return scaleFactor = "largest" === this.settingsService.settings.resizeMethod ? image.width > image.height ? size / image.width : size / image.height : image.width < image.height ? size / image.width : size / image.height, 
        scaleFactor;
    }
    getEmoteSize(commands) {
        let size, resizeCommand = [];
        commands.forEach(((command, index, object) => {
            "resize" === command[0] && (resizeCommand = command, object.splice(index, 1));
        }));
        const resizeCommandSize = resizeCommand[1] ?? "";
        if (size = "" !== resizeCommandSize ? resizeCommandSize : Math.round(this.settingsService.settings.emoteSize), 
        "large" === size || "big" === size) return 128;
        if ("medium" === size || "normal" === size) return 64;
        {
            const sizeNumber = "string" == typeof size ? parseInt(size) : size;
            return isNaN(sizeNumber) ? 48 : Math.min(Math.max(sizeNumber, 32), 128);
        }
    }
    getEmoteWideness(wideCommand) {
        const param = wideCommand[1], paramNum = parseInt(param ?? "");
        return isNaN(paramNum) ? "extreme" === param ? 8 : "huge" === param ? 6 : "big" === param ? 4 : 2 : Math.max(Math.min(paramNum, 8), 2);
    }
    uploadFile(params) {
        const {fileData, fullName, emote} = params, content = emote.content ?? "", channelId = emote.channel ?? "";
        channelId ? this.modulesService.uploader.upload({
            channelId,
            file: new File([ fileData ], fullName),
            draftType: 0,
            message: {
                content,
                invalidEmojis: [],
                tts: !1,
                channel_id: channelId
            },
            hasSpoiler: emote.spoiler,
            filename: fullName
        }) : Logger.error("Channel ID not found for emote:", emote);
    }
    async compress(originalFile, commands) {
        const result = await function fileReaderPromise(blob) {
            return new Promise(((resolve, reject) => {
                const reader = new FileReader;
                reader.readAsDataURL(blob), reader.onload = event => {
                    resolve(event.target?.result ?? void 0);
                }, reader.onerror = error => {
                    reject(error);
                };
            }));
        }(originalFile), image = await loadImagePromise(result?.toString() ?? ""), ctx = (await this.applyScaling(image, commands)).getContext("2d");
        if (ctx) return await new Promise((resolve => {
            ctx.canvas.toBlob((blob => {
                resolve(blob ?? void 0);
            }), "image/png", 1);
        }));
    }
    async applyScaling(image, commands) {
        const scaleFactor = this.getScaleFactor(commands, image);
        let canvas = document.createElement("canvas");
        canvas.width = image.width, canvas.height = image.height, commands.length > 0 ? canvas = this.applyCommands(image, canvas, commands) : canvas.getContext("2d")?.drawImage(image, 0, 0);
        const resizedCanvas = document.createElement("canvas");
        return resizedCanvas.width = Math.ceil(canvas.width * scaleFactor), resizedCanvas.height = Math.ceil(canvas.height * scaleFactor), 
        await this.picaInstance.resize(canvas, resizedCanvas, {
            unsharpAmount: 70,
            unsharpRadius: 0.8,
            unsharpThreshold: 105
        });
    }
    applyCommands(image, canvas, commands) {
        let scaleH = 1, scaleV = 1, posX = 0, posY = 0;
        this.findCommand(commands, [ "flip" ]) && (scaleH = -1, posX = -1 * canvas.width), 
        this.findCommand(commands, [ "flap" ]) && (scaleV = -1, posY = -1 * canvas.height);
        const ctx = canvas.getContext("2d"), wideCommand = this.findCommand(commands, [ "wide" ]);
        if (wideCommand) {
            const wideness = this.getEmoteWideness(wideCommand);
            image.width = image.width * wideness, canvas.width = canvas.width * wideness;
        }
        const rotateCommand = this.findCommand(commands, [ "rotate" ]);
        if (rotateCommand) {
            const angle = parseInt(rotateCommand[1] ?? "0") * Math.PI / 180, sin = Math.sin(angle), cos = Math.cos(angle), newWidth = Math.abs(canvas.width * cos) + Math.abs(canvas.height * sin), newHeight = Math.abs(canvas.width * sin) + Math.abs(canvas.height * cos);
            canvas.width = newWidth, canvas.height = newHeight, ctx?.translate(canvas.width / 2, canvas.height / 2), 
            ctx?.rotate(angle), posX = -image.width / 2, posY = -image.height / 2;
        }
        return ctx?.scale(scaleH, scaleV), ctx?.drawImage(image, posX, posY, image.width, image.height), 
        canvas;
    }
    stop() {}
}

class HtmlService extends BaseService {
    modulesService;
    start(modulesService) {
        return this.modulesService = modulesService, Promise.resolve();
    }
    addClasses(element, ...classes) {
        for (const curClass of classes) {
            if (!curClass) continue;
            const split = curClass.split(" ");
            for (const curClassItem of split) element.classList.add(curClassItem);
        }
    }
    getClassSelector(classes) {
        return classes.split(" ").map((curClass => curClass.startsWith(".") ? curClass : `.${curClass}`)).join(" ");
    }
    getTextAreaField() {
        const textArea = this.modulesService.classes.TextArea.textArea;
        return document.querySelector(this.getClassSelector(textArea)) ?? void 0;
    }
    getTextAreaContainer() {
        const channelTextArea = this.modulesService.classes.TextArea.channelTextArea;
        return document.querySelector(this.getClassSelector(channelTextArea)) ?? void 0;
    }
    stop() {}
}

var index = void 0 === window.ZeresPluginLibrary ? class RawPlugin {
    meta;
    constructor(meta) {
        this.meta = meta, setLogger(meta.name);
    }
    start() {
        this.showLibraryMissingModal().catch((error => {
            Logger.error(error);
        }));
    }
    async showLibraryMissingModal() {
        const request = await Promise.resolve().then((function() {
            return _interopNamespace(require("request"));
        })), electron = await Promise.resolve().then((function() {
            return _interopNamespace(require("electron"));
        })), fs = await Promise.resolve().then((function() {
            return _interopNamespace(require("fs"));
        })), path = await Promise.resolve().then((function() {
            return _interopNamespace(require("path"));
        }));
        BdApi.showConfirmationModal("Library Missing", `The library plugin needed for ${this.meta.name} is missing. Please click Download Now to install it.`, {
            confirmText: "Download Now",
            cancelText: "Cancel",
            onConfirm: () => {
                request.get("https://rauenzi.github.io/BDPluginLibrary/release/0PluginLibrary.plugin.js", void 0, ((error, _response, body) => {
                    null == error ? fs.writeFile(path.join(BdApi.Plugins.folder, "0PluginLibrary.plugin.js"), body, (() => {})) : electron.shell.openExternal("https://betterdiscord.net/ghdl?url=https://raw.githubusercontent.com/rauenzi/BDPluginLibrary/master/release/0PluginLibrary.plugin.js").catch((error => {
                        Logger.error(error);
                    }));
                }));
            }
        });
    }
    stop() {}
} : class EmoteReplacerPlugin {
    settingsService;
    emoteService;
    completionsService;
    attachService;
    listenersService;
    gifsicleService;
    modulesService;
    sendMessageService;
    htmlService;
    meta;
    updateInterval;
    constructor(meta) {
        this.meta = meta, setLogger(meta.name);
    }
    start() {
        this.doStart().catch((error => {
            Logger.error(error);
        }));
    }
    async doStart() {
        const zeresPluginLibrary = window.ZeresPluginLibrary;
        zeresPluginLibrary.PluginUpdater.checkForUpdate(this.meta.name, this.meta.version, this.meta.source), 
        this.updateInterval = setInterval((() => {
            zeresPluginLibrary.PluginUpdater.checkForUpdate(this.meta.name, this.meta.version, this.meta.source);
        }), 72e5), this.showChangelogIfNeeded(zeresPluginLibrary), await this.startServicesAndPatches();
    }
    showChangelogIfNeeded(zeresPluginLibrary) {
        const currentVersionInfo = BdApi.loadData(this.meta.name, "currentVersionInfo") ?? {};
        if (!0 !== currentVersionInfo.hasShownChangelog || currentVersionInfo.version !== this.meta.version) {
            zeresPluginLibrary.Modals.showChangelogModal(`${this.meta.name} Changelog`, this.meta.version, PLUGIN_CHANGELOG);
            const newVersionInfo = {
                version: this.meta.version,
                hasShownChangelog: !0
            };
            BdApi.saveData(this.meta.name, "currentVersionInfo", newVersionInfo);
        }
    }
    async startServicesAndPatches() {
        const zeresPluginLibrary = window.ZeresPluginLibrary;
        this.listenersService = new ListenersService(this, zeresPluginLibrary), await this.listenersService.start(), 
        this.settingsService = new SettingsService(this, zeresPluginLibrary), await this.settingsService.start(this.listenersService), 
        this.modulesService = new ModulesService(this, zeresPluginLibrary), await this.modulesService.start(), 
        this.htmlService = new HtmlService(this, zeresPluginLibrary), await this.htmlService.start(this.modulesService), 
        this.emoteService = new EmoteService(this, zeresPluginLibrary), await this.emoteService.start(this.listenersService, this.settingsService, this.htmlService), 
        this.completionsService = new CompletionsService(this, zeresPluginLibrary), await this.completionsService.start(this.emoteService, this.settingsService, this.modulesService, this.listenersService, this.htmlService), 
        this.attachService = new AttachService(this, zeresPluginLibrary), await this.attachService.start(this.modulesService), 
        this.gifsicleService = new GifsicleService(this, zeresPluginLibrary), await this.gifsicleService.start(), 
        this.sendMessageService = new SendMessageService(this, zeresPluginLibrary), await this.sendMessageService.start(this.emoteService, this.attachService, this.modulesService, this.settingsService, this.gifsicleService);
        const pluginName = this.meta.name;
        (function changeDraftPatch(pluginName, attachService, completionsService, emoteService, modulesService) {
            BdApi.Patcher.before(pluginName, modulesService.draft, "changeDraft", ((_, args) => function onChangeDraft(args, attachService, completionsService, emoteService) {
                if (!attachService.canAttach) return;
                const draft = args[1];
                if (void 0 !== draft) {
                    completionsService.draft = draft;
                    try {
                        const lastText = completionsService.cached?.draft;
                        if (!emoteService.shouldCompleteEmote(draft) && !emoteService.shouldCompleteCommand(draft)) return void completionsService.destroyCompletions();
                        lastText !== draft && completionsService.renderCompletions();
                    } catch (err) {
                        Logger.warn("Error in onChangeDraft", err);
                    }
                }
            }(args, attachService, completionsService, emoteService)));
        })(pluginName, this.attachService, this.completionsService, this.emoteService, this.modulesService), 
        function deletePendingReplyPatch(pluginName, attachService, modulesService) {
            BdApi.Patcher.instead(pluginName, modulesService.deletePendingReply, "deletePendingReply", ((_, args, original) => async function onDeletePendingReply(args, original, attachService) {
                const callDefault = original;
                try {
                    attachService.pendingUpload && await attachService.pendingUpload, callDefault(...args);
                } catch (err) {
                    Logger.warn("Error in onDeletePendingReply", err);
                }
            }(args, original, attachService)));
        }(pluginName, this.attachService, this.modulesService), function emojiSearchPatch(pluginName, attachService, modulesService) {
            BdApi.Patcher.after(pluginName, modulesService.emojiSearch, "search", ((_, _2, result) => function onEmojiSearch(result, attachService) {
                if (!attachService.canAttach) return;
                const searchResult = result;
                searchResult.unlocked.push(...searchResult.locked), searchResult.locked = [];
            }(result, attachService)));
        }(pluginName, this.attachService, this.modulesService), function lockedEmojisPatch(pluginName, attachService, modulesService) {
            const emojiStore = modulesService.emojiStore;
            BdApi.Patcher.after(pluginName, emojiStore, "getEmojiUnavailableReason", ((_, _2, result) => function onGetEmojiUnavailableReason(result, attachService, modulesService) {
                const EmojiDisabledReasons = modulesService.discordConstants.EmojiDisabledReasons;
                return result !== EmojiDisabledReasons.PREMIUM_LOCKED && result !== EmojiDisabledReasons.GUILD_SUBSCRIPTION_UNAVAILABLE || !attachService.canAttach || (result = null), 
                result;
            }(result, attachService, modulesService))), BdApi.Patcher.after(pluginName, emojiStore, "isEmojiDisabled", ((_, args) => function onIsEmojiDisabled(args, emojiStore) {
                const [emoji, channel, intention] = args;
                return null !== emojiStore.getEmojiUnavailableReason({
                    emoji,
                    channel,
                    intention
                });
            }(args, emojiStore)));
        }(pluginName, this.attachService, this.modulesService);
    }
    observer(e) {
        if (!(e.addedNodes.length && e.addedNodes[0] instanceof Element)) return;
        const elem = e.addedNodes[0], modulesService = this.modulesService;
        if (!modulesService) return;
        const textAreaSelector = this.htmlService?.getClassSelector(modulesService.classes.TextArea.textArea);
        void 0 !== textAreaSelector && elem.querySelector(textAreaSelector) && this.listenersService?.requestAddListeners(CompletionsService.TAG);
    }
    onSwitch() {
        this.completionsService?.destroyCompletions();
    }
    getSettingsPanel() {
        return this.settingsService?.getSettingsElement() ?? new HTMLElement;
    }
    stop() {
        BdApi.Patcher.unpatchAll(this.meta.name), this.updateInterval && (clearTimeout(this.updateInterval), 
        this.updateInterval = void 0), this.sendMessageService?.stop(), this.sendMessageService = void 0, 
        this.gifsicleService?.stop(), this.gifsicleService = void 0, this.attachService?.stop(), 
        this.attachService = void 0, this.completionsService?.stop(), this.completionsService = void 0, 
        this.emoteService?.stop(), this.emoteService = void 0, this.htmlService?.stop(), 
        this.htmlService = void 0, this.modulesService?.stop(), this.modulesService = void 0, 
        this.settingsService?.stop(), this.settingsService = void 0, this.listenersService?.stop(), 
        this.listenersService = void 0;
    }
};

module.exports = index;
